This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  ADR/
    0001-record-architecture-decisions.md
  diagrams/
    architecture-overview.mmd
    cross-cutting-concerns.mmd
    deployment-topology.mmd
    sequence-auth.mmd
    services-context.mmd
  ops/
    backup-restore.md
    runbooks.md
    sops-policy.md
  reports/
    filelist.txt
    sbom.json
  security/
    security-review.md
    threat-model.mmd
  API_REFERENCE.md
  BACKEND.md
  CONTRIBUTING.md
  DATABASE.md
  DEVOPS.md
  FRONTEND.md
  GLOSSARY.md
  MASTER_OVERVIEW.md
  OBSERVABILITY.md
  ONBOARDING.md
  PERFORMANCE.md
  SECURITY.md
public/
  vite.svg
scripts/
  export-tree.mjs
src/
  app/
    providers/
      ErrorProvider.tsx
      MotionProvider.tsx
      ThemeProvider.tsx
    App.tsx
    routes.tsx
  assets/
    react.svg
  components/
    diagnostics/
      DevToggle.tsx
      PerfOverlayMount.tsx
    feedback/
      ErrorBoundary.tsx
      Toasts.tsx
    layout/
      AppChrome.tsx
      AppShell.tsx
      SearchBar.module.css
      SearchBar.tsx
      SidePanel.tsx
      TopBar.tsx
    player/
      AlbumArt.css
      AlbumArt.tsx
      LocalFileLoader.tsx
      MediaKeyBridge.tsx
      PlaybackButtons.tsx
      PlayerCard.css
      PlayerCard.tsx
      Timeline.tsx
      TrackInfo.css
      TrackInfo.tsx
      TransportBar.tsx
      UrlLoader.tsx
      VolumeSlider.tsx
    settings/
      AudioDevicePicker.tsx
      EqPanel.tsx
      SettingsPanel.tsx
      VisualizerControls.tsx
    shortcuts/
      GlobalHotkeys.tsx
    streaming/
      StreamTestWizard.tsx
    visualizer/
      DimmerToggle.tsx
      HdrToggle.tsx
      index.ts
      ParticlesCanvas.tsx
      PresetSelector.tsx
      SceneCanvas.tsx
  lib/
    audio/
      AnalyserBus.ts
      AudioEngine.ts
      DeviceManager.ts
      EQGraph.ts
      eqPresets.json
      Limiter.ts
      OutputDeviceManager.ts
      PlaybackController.ts
      TrackLoader.ts
    diagnostics/
      AdaptiveGuard.ts
      FpsGuard.ts
      PerfEvents.ts
      PerfOverlay.ts
      Probe.ts
    state/
      types.ts
      usePlayerStore.ts
      useSettingsStore.ts
      useUIStore.ts
      useVizStore.ts
    streaming/
      HlsController.ts
    three/
      components/
        ParticlesField.ts
        PostProcessing.ts
      shaders/
        particles.frag
        particles.vert
      ContextLossHandler.ts
      SceneController.ts
      VisualizerParams.ts
      VisualizerScene.ts
    utils/
      ContrastCheck.ts
      FocusRing.ts
      FpsGuard.ts
      Hotkeys.ts
      IconRegistry.ts
      MediaSession.ts
      ReducedMotion.ts
      UrlGuard.ts
      useHotkeys.ts
      Visibility.ts
    visualizer/
      QualityPresets.ts
      SceneController.ts
  styles/
    globals.css
    tokens.css
  App.css
  index.css
  index.tsx
  vite-env.d.ts
.gitignore
.hintrc
CHANGELOG.md
eslint.config.js
index.html
package.json
project-structure.txt
README.md
TODO.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/ADR/0001-record-architecture-decisions.md">
# ADR 0001: Record Architecture Decisions

- Date: <YYYY-MM-DD>
- Status: Proposed
- Context: <What problem are we solving?>
- Decision: <What did we decide and why?>
- Consequences: <Positive/negative outcomes>
- Alternatives considered: <List>
</file>

<file path="docs/diagrams/architecture-overview.mmd">
flowchart LR
  user((User)) -->|UI| web[Web/App Frontend (React)]
  web --> audio[Audio Engine]
  web --> viz[Visualizer (Three.js)]
  web --> state[State Store (Zustand)]
  audio --> device[Device Manager]
  audio --> eq[EQ/FX]
  audio --> playback[Playback Controller]
  playback --> loader[Track Loader]
  web --> settings[Settings Panel]
  web --> player[Player UI]
  viz --> canvas[SceneCanvas]
  viz --> presets[QualityPresets]
  state --> player
  state --> settings
  state --> viz
  player -->|Controls| playback
  player -->|Volume| audio
  settings -->|Config| audio
  settings -->|Config| viz
  loader -->|File/Stream| source[Audio Source]
  device -->|Output| output[Audio Output]
</file>

<file path="docs/diagrams/cross-cutting-concerns.mmd">
flowchart LR
  settings[Settings Store] -->|Feature Flags| player[Player UI]
  settings -->|Theme| web[Web Frontend]
  settings -->|Audio Config| audio[Audio Engine]
  state[State Store] -->|Playback State| player
  state -->|Visualizer State| viz[Visualizer]
  player -->|Error Handling| error[Error Boundary]
  player -->|Validation| audio
  viz -->|Performance Metrics| perf[Perf Overlay]
  web -->|Accessibility| a11y[Accessibility Layer]
</file>

<file path="docs/diagrams/deployment-topology.mmd">
flowchart TD
  user((User))
  user --> cdn[CDN/Static Hosting]
  cdn --> web[Web Frontend (SPA)]
  web --> browser[Browser Audio/Media APIs]
  web --> browser[WebGL/Canvas]
</file>

<file path="docs/diagrams/sequence-auth.mmd">
sequenceDiagram
  participant U as User
  participant FE as Frontend (React)
  participant AE as Audio Engine
  participant VZ as Visualizer
  U->>FE: Load App
  FE->>AE: Initialize Audio Engine
  FE->>VZ: Initialize Visualizer
  U->>FE: Select Track/Stream
  FE->>AE: Load Track/Stream
  AE-->>FE: Ready/Playback State
  FE-->>U: UI Feedback (Ready/Playing)
  U->>FE: Interact with Controls (Play/Pause/Seek)
  FE->>AE: Playback Command
  AE-->>FE: Playback State Update
  FE->>VZ: Update Visualization
  VZ-->>FE: Rendered Frame
  FE-->>U: Visual Feedback
</file>

<file path="docs/diagrams/services-context.mmd">
flowchart TD
  user((User))
  user --> web[Web Frontend (SPA)]
  web --> audio[Audio Engine]
  web --> viz[Visualizer]
  web --> state[State Store]
  audio --> device[Device Manager]
  audio --> eq[EQ]
  audio --> playback[Playback Controller]
  playback --> loader[Track Loader]
  loader --> source[Audio File/Stream]
  device --> output[Audio Output]
</file>

<file path="docs/ops/backup-restore.md">
# Backup & Restore

No server-side data or persistent backend. Users may export/import settings manually via browser dev tools if needed.
</file>

<file path="docs/ops/runbooks.md">
# Runbooks

## Common Operational Tasks
- **Clear LocalStorage:**
  - Open browser dev tools > Application > LocalStorage > Clear site data.
- **Reset App State:**
  - Use in-app settings or clear LocalStorage as above.
- **Update Dependencies:**
  - Run `npm update` and `npm audit fix`.
- **Build for Production:**
  - Run `npm run build`.
- **Test Locally:**
  - Run `npm run dev` and `npm run test`.

## Incident Response
- **UI/Playback Bug:**
  - Check browser console for errors.
  - Try clearing LocalStorage and reloading.
- **Dependency Vulnerability:**
  - Run `npm audit` and update as needed.
</file>

<file path="docs/ops/sops-policy.md">
# SOPS Policy

Not applicable. No secrets or sensitive config are managed in this project.
</file>

<file path="docs/reports/filelist.txt">
.gitignore
CHANGELOG.md
README.md
eslint.config.js
index.html
package-lock.json
package.json
project-structure.txt
public/test.mp3
public/vite.svg
scripts/export-tree.mjs
src/App.css
src/app/App.tsx
src/app/providers/ErrorProvider.tsx
src/app/providers/MotionProvider.tsx
src/app/providers/ThemeProvider.tsx
src/app/routes.tsx
src/assets/react.svg
src/assets/title.jpg
src/components/diagnostics/DevToggle.tsx
src/components/diagnostics/PerfOverlayMount.tsx
src/components/feedback/ErrorBoundary.tsx
src/components/feedback/Toasts.tsx
src/components/layout/AppChrome.tsx
src/components/layout/AppShell.tsx
src/components/layout/SearchBar.module.css
src/components/layout/SearchBar.tsx
src/components/layout/SidePanel.tsx
src/components/layout/TopBar.tsx
src/components/player/AlbumArt.css
src/components/player/AlbumArt.tsx
src/components/player/LocalFileLoader.tsx
src/components/player/MediaKeyBridge.tsx
src/components/player/PlaybackButtons.tsx
src/components/player/PlayerCard.css
src/components/player/PlayerCard.tsx
src/components/player/Timeline.tsx
src/components/player/TrackInfo.css
src/components/player/TrackInfo.tsx
src/components/player/TransportBar.tsx
src/components/player/UrlLoader.tsx
src/components/player/VolumeSlider.tsx
src/components/settings/AudioDevicePicker.tsx
src/components/settings/EqPanel.tsx
src/components/settings/SettingsPanel.tsx
src/components/settings/VisualizerControls.tsx
src/components/shortcuts/GlobalHotkeys.tsx
src/components/streaming/StreamTestWizard.tsx
src/components/visualizer/DimmerToggle.tsx
src/components/visualizer/HdrToggle.tsx
src/components/visualizer/ParticlesCanvas.tsx
src/components/visualizer/PresetSelector.tsx
src/components/visualizer/SceneCanvas.tsx
src/components/visualizer/index.ts
src/index.css
src/index.tsx
src/lib/audio/AnalyserBus.ts
src/lib/audio/AudioEngine.ts
src/lib/audio/DeviceManager.ts
src/lib/audio/EQGraph.ts
src/lib/audio/Limiter.ts
src/lib/audio/OutputDeviceManager.ts
src/lib/audio/PlaybackController.ts
src/lib/audio/TrackLoader.ts
src/lib/audio/eqPresets.json
src/lib/diagnostics/AdaptiveGuard.ts
src/lib/diagnostics/FpsGuard.ts
src/lib/diagnostics/PerfEvents.ts
src/lib/diagnostics/PerfOverlay.ts
src/lib/diagnostics/Probe.ts
src/lib/state/types.ts
src/lib/state/usePlayerStore.ts
src/lib/state/useSettingsStore.ts
src/lib/state/useUIStore.ts
src/lib/state/useVizStore.ts
src/lib/streaming/HlsController.ts
src/lib/three/ContextLossHandler.ts
src/lib/three/SceneController.ts
src/lib/three/VisualizerParams.ts
src/lib/three/VisualizerScene.ts
src/lib/three/components/ParticlesField.ts
src/lib/three/components/PostProcessing.ts
src/lib/three/shaders/particles.frag
src/lib/three/shaders/particles.vert
src/lib/utils/ContrastCheck.ts
src/lib/utils/FocusRing.ts
src/lib/utils/FpsGuard.ts
src/lib/utils/Hotkeys.ts
src/lib/utils/IconRegistry.ts
src/lib/utils/MediaSession.ts
src/lib/utils/ReducedMotion.ts
src/lib/utils/UrlGuard.ts
src/lib/utils/Visibility.ts
src/lib/utils/useHotkeys.ts
src/lib/visualizer/QualityPresets.ts
src/lib/visualizer/SceneController.ts
src/styles/globals.css
src/styles/tokens.css
src/vite-env.d.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</file>

<file path="docs/reports/sbom.json">
{
  "sbom": "Not applicable: no backend, all dependencies are listed in package.json. Use `npm audit` for up-to-date dependency checks."
}
</file>

<file path="docs/security/security-review.md">
# Security Review

## Auth Mechanisms
- No authentication or authorization; all features are local to the browser.

## Sensitive Data Flows
- No PII, PHI, or PCI data is stored or processed.
- All data is local to the browser (LocalStorage, in-memory state).

## Storage Protections
- No server-side storage; browser LocalStorage is used for non-sensitive settings only.

## Common CWE Vectors
- XSS: Minimal risk; no user-generated content or remote data fetching.
- CSRF: Not applicable (no backend).
- SSRF, RCE, Path Traversal, Injections: Not applicable.
- Dependency risk: Mitigated by using trusted, up-to-date packages.

## Risks & Mitigations
- **Dependency vulnerabilities:** Use `npm audit` and keep dependencies updated.
- **Browser storage exposure:** Only non-sensitive data is stored; users can clear at any time.
- **No secrets in repo:** `.gitignore` covers common patterns; no `.env` or secret files found.

## Threat Model
- Main threat is supply chain (dependency) risk.
- No attack surface for network-based exploits.

---

See `docs/security/threat-model.mmd` for diagram.
</file>

<file path="docs/security/threat-model.mmd">
flowchart TD
  user((User)) -->|UI| browser[Browser]
  browser -->|LocalStorage| settings[Settings]
  browser -->|In-memory| state[State Stores]
  browser -->|Audio| audio[Audio Engine]
  browser -->|Visualizer| viz[Visualizer]
  browser -->|Dependencies| deps[NPM Packages]
  deps -.->|Supply Chain| threat[Threat]
  browser -.->|Browser Exploit| threat
</file>

<file path="docs/API_REFERENCE.md">
# API Reference

## API Types

This project is a frontend-only SPA. There are **no REST, GraphQL, gRPC, WebSocket, or webhook APIs** exposed to external consumers.

## Internal Module Boundaries

While there is no external API, the codebase is organized into clear internal modules:
- **Audio Engine**: `src/lib/audio/AudioEngine.ts`, `PlaybackController.ts`, `AnalyserBus.ts`
- **State Stores**: `src/lib/state/usePlayerStore.ts`, `useVizStore.ts`, `useSettingsStore.ts`, `useUIStore.ts`
- **Visualizer**: `src/lib/visualizer/`, `src/components/visualizer/`
- **Player UI**: `src/components/player/`
- **Settings**: `src/components/settings/`
- **Diagnostics**: `src/lib/diagnostics/`, `src/components/diagnostics/`

## Example Requests/Responses

Not applicable. All interactions are in-browser and module-to-module.
</file>

<file path="docs/BACKEND.md">
# Backend Documentation

## Frameworks, Packages, and Versions

There is no backend server or API in this codebase. All business logic, state management, and orchestration are implemented in the frontend (React + TypeScript). The architecture is modular, with a clear separation of concerns for audio, state, diagnostics, and UI.

**Key Packages:**
- React, Zustand, Three.js, Framer Motion, hls.js (all frontend)
- No backend or server-side frameworks

## App Entrypoints

- No Node.js/Express/server entrypoint. The app is a static SPA, entry is `src/index.tsx`.

## Services/Controllers/Handlers

- `AudioEngine` (`src/lib/audio/AudioEngine.ts`): Core audio playback, state, and event handling.
- `PlaybackController` (`src/lib/audio/PlaybackController.ts`): Orchestrates playback, queue, repeat/shuffle, and event forwarding.
- `AnalyserBus` (`src/lib/audio/AnalyserBus.ts`): Audio analysis for visualizations.
- `DeviceManager`, `OutputDeviceManager`, `EQGraph`, `Limiter`: Audio device and effects management.
- `PerfEvents` (`src/lib/diagnostics/PerfEvents.ts`): Performance diagnostics, event pub/sub.

## Middleware Chain

Not applicable (no HTTP stack).

## Auth/Permissions

No authentication or permissions model.

## Validation

Defensive programming in playback and audio modules (never throw on user actions).

## Error Handling

- Error boundaries in React (`src/components/feedback/ErrorBoundary.tsx`).
- Defensive error handling in audio modules.

## Background Jobs

- Performance sampling (RAF loop in `PerfEvents`).
- LocalStorage for developer toggles and settings.

## Configuration (Env Var Table)

- No `.env` or config files. All config is in code or browser storage.

## Performance Practices

- Performance overlays, FPS sampling, and adaptive quality for visualizer.
- No connection pooling, caching, or pagination (not applicable).

## Code Path Citations

- See `src/lib/audio/`, `src/lib/diagnostics/`, `src/lib/state/`, and `src/components/feedback/ErrorBoundary.tsx`.
</file>

<file path="docs/CONTRIBUTING.md">
# Contributing Guide

## Coding Standards

## Commit Style

## PR Checks

## Review Process

## DCO/CLA
</file>

<file path="docs/DATABASE.md">
# Database Documentation

## Databases Used

There is **no backend database**. All data is stored locally in the browser using:
- LocalStorage (for settings, UI state, and developer toggles)
- In-memory state (Zustand stores)
- Audio files are loaded from local disk or streamed (not persisted)

## Models/Entities

- **SettingsStore**: theme, view, reducedMotion, visualizer settings
- **PlayerStore**: playback state, queue, current track
- **VizStore**: visualizer parameters, quality, HDR, dimmer
- **UIStore**: side panel, modals, FPS overlay

## Relationships

- Stores are independent but may reference each other for UI composition.

## ERD

Not applicable (no relational data model).

## Data Retention/Backups

- Data is retained in browser LocalStorage until cleared by the user or browser.
- No automated backup or restore; no PII/PHI/PCI data is stored.
</file>

<file path="docs/DEVOPS.md">
# DevOps Documentation

## CI/CD Pipelines

## Deployment Strategies

## Infrastructure as Code

## Config/Secret Management
</file>

<file path="docs/FRONTEND.md">
# Frontend Documentation

## Routing Tree
- **Store-driven routing**: No external router; routes are managed in `useSettingsStore` and mirrored to `location.hash`.
- **Routes**:  
	- `player`: Now Playing & Visualizer  
	- `settings`: EQ, devices, visualizer controls  
	- `stream`: Streaming test wizard  
- See: `src/app/routes.tsx`

## Data Fetching Strategy
- No remote data fetching; all data is local (audio files, settings, state).
- HLS streams handled via `hls.js` for non-Safari browsers.

## State Stores
- **Zustand** is used for all state management:
	- `usePlayerStore`: playback state
	- `useVizStore`: visualizer state
	- `useSettingsStore`: theme, view, settings, router
	- `useUIStore`: ephemeral UI state (side panel, modals, FPS overlay)

## Key Components
- `AppShell`: Layout scaffold, global utilities, visualizer canvas, navigation, and main content.
- `AppChrome`: Header/footer chrome, quick actions, focus management, a11y.
- `PlayerCard`, `TransportBar`, `Timeline`, `TrackInfo`: Player UI.
- `VisualizerControls`, `SceneCanvas`, `PresetSelector`: Visualizer UI.
- `SettingsPanel`, `AudioDevicePicker`, `EqPanel`: Settings.
- `GlobalHotkeys`, `MediaKeyBridge`: Keyboard and hardware media key support.
- `ErrorBoundary`, `Toasts`: Error and feedback handling.

## Styling Approach
- **CSS**: Design tokens (`src/styles/tokens.css`), global styles (`src/styles/globals.css`), and utility classes.
- **Glassmorphism**: Used throughout for modern UI.
- No CSS-in-JS; all styles are static or token-driven.

## Accessibility Checklist
- Full keyboard navigation for all custom components.
- ARIA roles and states on buttons, sliders, toggles, and navigation.
- WCAG AA contrast enforced via tokens and runtime checks.
- Screen reader labels and skip links.
- Focus ring and modality helpers for visible focus.

## Performance Optimizations
- Code-splitting via Vite.
- Lazy loading of HLS.js.
- Adaptive visualizer quality.
- FPS and performance overlays for diagnostics.
- Minimal re-renders via primitive selectors in Zustand.

## Storybook Links
- No Storybook present.
</file>

<file path="docs/GLOSSARY.md">
# Glossary & Acronyms

## Domain Terms

## Acronyms
</file>

<file path="docs/MASTER_OVERVIEW.md">
# Ethereal Harmony — Master Overview

## System at a Glance

- **Purpose:** Ethereal Harmony is a modern, interactive music player and visualizer built with React, Vite, and Three.js. It provides advanced playback, visualization, and device management features in a single-page application.
- **Business Capabilities:** Local and streaming audio playback, real-time visualizations, device selection, equalizer, and user-friendly controls.
- **High‑level diagram(s):** (See /docs/diagrams)

---

### Repository Discovery & Inventory

**Entrypoints (by language):**

- TypeScript/React SPA:
	- Main entry: `src/index.tsx` (invoked by Vite)
	- App root: `src/app/App.tsx`
	- No backend/server entrypoints detected (frontend-only app)

**Detected Frameworks/Libraries & Versions:**

| Library/Framework      | Version      |
|------------------------|-------------|
| React                  | 19.1.1      |
| Vite                   | 7.1.2       |
| Zustand (state)        | 5.0.7       |
| Three.js (3D)          | 0.179.1     |
| Framer Motion (anim)   | 12.23.12    |
| ESLint                 | 9.33.0      |
| Vitest (test)          | 3.2.4       |
| Playwright (e2e)       | 1.54.2      |

**Build/Test/Lint/Start Commands:**

| Task   | Command                                 |
|--------|-----------------------------------------|
| dev    | `vite`                                  |
| build  | `vite build`                            |
| preview| `vite preview`                          |
| test   | `vitest`                                |
| test:ui| `vitest --ui`                           |
| lint   | `eslint "src/**/*.{ts,tsx}"`            |
| e2e    | `playwright test`                       |

**Environment/Secrets Files:**

- No `.env*`, `config/*`, `settings.*`, or `application.*` files found.
- `.gitignore` covers common secrets and local config patterns.

**Feature Flags/Toggles:**

- Feature toggles are present, mostly for UI/visualizer (e.g., `HdrToggle`, `DimmerToggle`, settings flags).
- No external feature flag service detected; toggles are implemented in code (see `src/components/visualizer/HdrToggle.tsx`, `src/lib/visualizer/QualityPresets.ts`).

**Monorepo Tooling:**

- No monorepo tools detected (Turborepo, Nx, Lerna, etc.).

**Build Tools:**

- Vite, TypeScript, ESLint, Vitest, Playwright.

**Branches/Tags/Commits:**

- 1 branch: `master`
- 0 tags
- 13 commits

**Candidate `/docs` Structure:**

- Already created as per TODO.md (see previous step).

---

## Stack Summary
- Languages, frameworks, hosting, datastores

## Key Flows
- Auth, critical user journeys, batch/cron

## Services
- Table with service name, repo path, owners, SLAs

All services are implemented as frontend modules. There are no backend microservices or external APIs.

## Integrations & External Services

- **No third-party integrations** (payments, email, auth, storage, analytics, search, geo, ML, etc.)
- All features are implemented client-side, with the exception of optional HLS streaming via `hls.js` (loaded dynamically for non-Safari browsers).

## Data
- ERD link, sensitive fields, retention/backup summary

## APIs
- REST/GraphQL/gRPC overview with links to specs

## Security & Compliance
- AuthN/Z, threat model summary, compliance notes

## DevOps
- CI jobs, deploy strategy, environments, feature flags

## Observability
- Logs/metrics/traces, dashboards, SLOs

## Testing
- Levels, coverage, gate policies

## Runbooks & On‑Call
- Links to /docs/ops

## Roadmap & Risks
- Known gaps, tech debt, ADR links
</file>

<file path="docs/OBSERVABILITY.md">
# Observability Documentation

## Logging

- No server-side logging; browser console is used for diagnostics.
- Performance and error overlays available in-app.

## Metrics

- FPS, frame time, and memory usage sampled in-browser (see `src/lib/diagnostics/PerfEvents.ts`).
- No external metrics or dashboards.

## Tracing

- Not applicable (no distributed system).

## Dashboards

- In-app overlays for performance and diagnostics.

## SLOs

- Not formally defined; app is best-effort for end-user experience.
</file>

<file path="docs/ONBOARDING.md">
# Onboarding Guide

## Setup Steps

## Local Environment

## Seed Data

## Common Commands

## Debugging Tips
</file>

<file path="docs/PERFORMANCE.md">
# Performance & Scalability

## Bottlenecks & Hotspots

- Visualizer rendering (WebGL/Three.js) is the main performance hotspot.
- Audio playback is lightweight; bottlenecks are rare.

## Caching Layers

- No HTTP or CDN caching; all assets are static and loaded via Vite.

## Load/Soak Test Plan

- Manual browser testing on a range of devices and browsers.
- Use in-app FPS and performance overlays to monitor.

## Performance Budgets

- Target 60 FPS on modern hardware.
- Bundle size kept minimal by lazy-loading heavy dependencies (e.g., hls.js).

## Autoscaling Policies

- Not applicable (static SPA, no backend).
</file>

<file path="docs/SECURITY.md">
# Security Documentation

## Auth Mechanisms

## Sensitive Data Flows

## Storage Protections

## Common CWE Vectors

## Threat Model
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="scripts/export-tree.mjs">
#!/usr/bin/env node
/**
 * Ethereal Harmony — project tree exporter
 * ---------------------------------------
 * Usage examples:
 *   node scripts/export-tree.mjs
 *   node scripts/export-tree.mjs --out project-structure.txt
 *   node scripts/export-tree.mjs --root src --maxDepth 6
 *   node scripts/export-tree.mjs --include "src,public" --exclude "node_modules,dist,.git,.vite"
 *
 * Writes a text file containing a folder tree of your project with sensible ignores.
 * No external deps; runs on Node 18+.
 */

import { promises as fs } from "node:fs";
import path from "node:path";
import process from "node:process";

const args = parseArgs(process.argv.slice(2));

const CWD = process.cwd();
const ROOT = path.resolve(CWD, args.root ?? ".");
const OUT = path.resolve(CWD, args.out ?? "project-structure.txt");
const MAX_DEPTH = Number.isFinite(Number(args.maxDepth)) ? Number(args.maxDepth) : 12;

const DEFAULT_EXCLUDES = [
  "node_modules",
  ".git",
  "dist",
  "build",
  ".cache",
  ".vite",
  ".turbo",
  ".parcel-cache",
  ".DS_Store",
  ".eslintcache",
  ".next",
  ".vercel",
  ".idea",
  ".vscode",
  ".pnpm-store",
];

const excludes = new Set(
  (args.exclude ?? "")
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean)
    .concat(DEFAULT_EXCLUDES)
);

const includes = new Set(
  (args.include ?? "")
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean)
);

run().catch((err) => {
  console.error("export-tree: fatal error\n", err);
  process.exit(1);
});

async function run() {
  const lines = [];
  const rootLabel = path.basename(ROOT) || ROOT;

  lines.push(`${rootLabel}/`);

  await walk(ROOT, 0, lines, /*prefix*/ "");

  const text = lines.join("\n") + "\n";
  await fs.writeFile(OUT, text, "utf8");

  console.log(`✓ Wrote tree to ${path.relative(CWD, OUT)}`);
}

/**
 * Recursively walks the directory building a tree.
 */
async function walk(dir, depth, lines, prefix) {
  if (depth >= MAX_DEPTH) {
    lines.push(`${prefix}└── … (maxDepth reached)`);
    return;
  }

  let entries = await fs.readdir(dir, { withFileTypes: true });

  // Optional include filter at the top-level only:
  if (depth === 0 && includes.size > 0) {
    entries = entries.filter((e) => includes.has(e.name));
  }

  // Filter out excluded names
  entries = entries.filter((e) => !excludes.has(e.name));

  // Sort: directories first, then files; alphabetical within groups
  entries.sort((a, b) => {
    if (a.isDirectory() !== b.isDirectory()) return a.isDirectory() ? -1 : 1;
    return a.name.localeCompare(b.name, undefined, { numeric: true });
  });

  const lastIdx = entries.length - 1;

  for (let i = 0; i < entries.length; i++) {
    const ent = entries[i];
    const isLast = i === lastIdx;
    const branch = isLast ? "└── " : "├── ";
    const nextPrefix = prefix + (isLast ? "    " : "│   ");
    const p = path.join(dir, ent.name);

    if (ent.isDirectory()) {
      lines.push(`${prefix}${branch}${ent.name}/`);
      await walk(p, depth + 1, lines, nextPrefix);
    } else if (ent.isFile()) {
      lines.push(`${prefix}${branch}${ent.name}`);
    } else if (ent.isSymbolicLink()) {
      const target = await fs.readlink(p).catch(() => "");
      lines.push(`${prefix}${branch}${ent.name} -> ${target}`);
    }
  }
}

/**
 * Tiny argv parser for --k=v and --k v styles.
 */
function parseArgs(argv) {
  const out = {};
  for (let i = 0; i < argv.length; i++) {
    const tok = argv[i];
    if (!tok.startsWith("--")) continue;
    const eq = tok.indexOf("=");
    if (eq !== -1) {
      const k = tok.slice(2, eq);
      const v = tok.slice(eq + 1);
      out[k] = v;
    } else {
      const k = tok.slice(2);
      const v = argv[i + 1] && !argv[i + 1].startsWith("--") ? argv[++i] : true;
      out[k] = v;
    }
  }
  return out;
}
</file>

<file path="src/app/providers/ErrorProvider.tsx">
// src/app/providers/ErrorProvider.tsx
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
  ReactNode,
} from "react";
import { ErrorBoundary } from "@/components/feedback/ErrorBoundary";

/**
 * ErrorProvider
 * -----------------------------------------------------------------------------
 * Phase: 1 (Foundation)
 * Role: App-wide safety net provider that:
 *   - Wraps the React tree with our ErrorBoundary.
 *   - Subscribes to global 'error' and 'unhandledrejection' events to escalate
 *     non-React errors into the boundary.
 *   - Exposes a 'reportError' function via context for any module to escalate
 *     a fatal condition into the boundary without tight coupling.
 *
 * Architecture:
 * - File path: src/app/providers/ErrorProvider.tsx (per blueprint).
 * - No telemetry or external logging in V1 (privacy-first). We only emit a DOM
 *   CustomEvent "eh:error" from the boundary itself (already implemented there).
 * - This provider focuses on capture and escalation; rendering/UI is handled by
 *   ErrorBoundary under src/components/feedback/ErrorBoundary.tsx.
 *
 * Usage:
 *   <ErrorProvider>
 *     <AppShell /> // the rest of the app
 *   </ErrorProvider>
 *
 *   // From anywhere (e.g., async init code), escalate to boundary:
 *   const { reportError } = useError();
 *   reportError(new Error("Catastrophic failure initializing AudioEngine"));
 */

// ----------------------------- Context Types ---------------------------------

export interface GlobalErrorContextValue {
  /**
   * Escalate a fatal application error into the ErrorBoundary overlay.
   * Prefer using this for unrecoverable states (e.g., corrupt persisted data,
   * failed critical initialization) to give users a predictable recovery path.
   */
  reportError: (
    error: unknown,
    info?: { component?: string; extra?: Record<string, unknown> }
  ) => void;
}

const ErrorContext = createContext<GlobalErrorContextValue | undefined>(
  undefined
);

// -------------------------- Internal Escalator Node ---------------------------

/**
 * ErrorEscalator
 * A tiny component that throws during render when it receives a non-null error.
 * Because it is placed inside the ErrorBoundary, throwing here will be caught
 * and the recovery UI will be displayed. This allows us to convert global or
 * async errors into boundary-handled ones without depending on component tree
 * boundaries at the error site.
 */
const ErrorEscalator: React.FC<{ error: Error | null }> = ({ error }) => {
  if (error) {
    // Throwing in render is how React Error Boundaries catch exceptions.
    throw error;
  }
  return null;
};

// --------------------------------- Provider ----------------------------------

export const ErrorProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [escalatedError, setEscalatedError] = useState<Error | null>(null);

  const reportError = useCallback<
    GlobalErrorContextValue["reportError"]
  >((error, info) => {
    const err =
      error instanceof Error
        ? error
        : new Error(
            typeof error === "string"
              ? error
              : "Unknown application error (non-Error thrown)"
          );

    // Non-invasive enrichment for developer visibility in dev tools.
    try {
      (err as any).__eh_info__ = info ?? {};
    } catch {
      /* ignore enrichment failures */
    }

    // Escalate into ErrorBoundary by causing a render throw.
    setEscalatedError(err);
  }, []);

  // Subscribe to global browser error channels and escalate into the boundary.
  useEffect(() => {
    const onUnhandledRejection = (ev: PromiseRejectionEvent) => {
      // Avoid masking the original reason; preserve as much as possible.
      const reason = (ev && (ev as any).reason) ?? "Unhandled promise rejection";
      reportError(reason, { component: "unhandledrejection" });
    };

    const onWindowError = (ev: ErrorEvent) => {
      const enriched =
        ev.error instanceof Error
          ? ev.error
          : new Error(ev.message || "Unhandled error");
      try {
        (enriched as any).__eh_source__ = ev.filename
          ? `${ev.filename}:${ev.lineno}:${ev.colno}`
          : "window.onerror";
      } catch {
        /* ignore */
      }
      reportError(enriched, { component: "window.onerror" });
    };

    window.addEventListener("unhandledrejection", onUnhandledRejection);
    window.addEventListener("error", onWindowError);

    return () => {
      window.removeEventListener("unhandledrejection", onUnhandledRejection);
      window.removeEventListener("error", onWindowError);
    };
  }, [reportError]);

  const ctx = useMemo<GlobalErrorContextValue>(
    () => ({ reportError }),
    [reportError]
  );

  // We pass a key to force a remount of the boundary after escalation if needed.
  // This is conservative; our boundary currently performs a hard reload on user
  // action, but the key keeps the tree deterministic across states.
  const boundaryKey = escalatedError ? "eh-boundary-tripped" : "eh-boundary-ok";

  return (
    <ErrorContext.Provider value={ctx}>
      <ErrorBoundary key={boundaryKey}>
        {/* Placing the escalator first ensures it throws before rendering children */}
        <ErrorEscalator error={escalatedError} />
        {children}
      </ErrorBoundary>
    </ErrorContext.Provider>
  );
};

// ------------------------------- Convenience ---------------------------------

/**
 * useError
 * Hook to access the global error escalation function.
 */
export const useError = (): GlobalErrorContextValue => {
  const ctx = useContext(ErrorContext);
  if (!ctx) {
    throw new Error("useError must be used within <ErrorProvider>");
  }
  return ctx;
};

export default ErrorProvider;
</file>

<file path="src/app/providers/MotionProvider.tsx">
// src/app/providers/MotionProvider.tsx
import React, { ReactNode, useMemo } from "react";
import { MotionConfig } from "framer-motion";

/**
 * MotionProvider
 * -----------------------------------------------------------------------------
 * Phase: 1 (Foundation)
 * Role: Global wrapper around Framer Motion to ensure:
 *   - Respect for user preferences (reduced motion).
 *   - Consistent default transition timings across the app.
 *   - Centralized control so all motion follows the same configuration.
 *
 * Architecture:
 * - Placed in src/app/providers per blueprint.
 * - Consumed at the top level of AppShell (via AppProviders).
 * - We rely on Framer Motion's `MotionConfig` which reads `prefers-reduced-motion`
 *   when configured with `reducedMotion="user"`.
 *
 * Accessibility:
 * - Supports WCAG by reducing or disabling animations when the OS/user agent
 *   indicates reduced motion preference.
 * - All animations should be meaningful and non-distracting.
 *
 * Performance:
 * - Centralizing transitions prevents excessive re-renders and ensures a
 *   predictable, consistent animation budget.
 */

// ----------------------------- Types -----------------------------------------

export interface MotionProviderProps {
  children: ReactNode;
}

// ----------------------------- Provider --------------------------------------

export const MotionProvider: React.FC<MotionProviderProps> = ({ children }) => {
  /**
   * Define app-wide transition defaults.
   * These are tuned for Material-style "fluid but snappy" interactions.
   */
  const transition = useMemo(
    () => ({
      type: "spring" as const,
      damping: 24,
      stiffness: 200,
      mass: 1,
    }),
    []
  );

  return (
    <MotionConfig reducedMotion="user" transition={transition}>
      {children}
    </MotionConfig>
  );
};

export default MotionProvider;
</file>

<file path="src/app/providers/ThemeProvider.tsx">
// src/app/providers/ThemeProvider.tsx
import React, { ReactNode, useEffect, useRef } from "react";
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

/**
 * ThemeProvider
 * -----------------------------------------------------------------------------
 * Phase: 1 (Foundation)
 * Role: Apply global theme (light | dark | system) and density (comfortable | compact)
 *       classes to the <html> root, in line with our glassmorphism design tokens
 *       and WCAG AA contrast requirements.
 *
 * Notes:
 * - Local-only persistence via Zustand persist (no telemetry).
 * - Uses a hasHydrated flag to avoid first-paint flicker.
 * - Responds live to OS theme changes when theme === "system".
 * - Updates <meta name="theme-color"> for browser UI tinting.
 * - Sets `color-scheme` to help UA form controls match the theme.
 *
 * Tokens (defined in styles/tokens.css):
 *   -- Brand colors: #1A2B45 (Deep Indigo), #7F6A9F (Soft Lavender), #00F0FF (Radiant Aqua)
 *   -- Glass: radius 16px; blur 16px; border rgba(255,255,255,0.25)
 *
 * Global classes this provider manages:
 *   eh-dark | eh-light
 *   eh-density-comfortable | eh-density-compact
 */

// ----------------------------- Types & Store ---------------------------------

export type Theme = "dark" | "light" | "system";
export type Density = "comfortable" | "compact";

type SettingsState = {
  version: number;
  theme: Theme;
  density: Density;
  hasHydrated: boolean;
  setTheme: (t: Theme) => void;
  setDensity: (d: Density) => void;
  _setHydrated: (h: boolean) => void;
};

const STORAGE_KEY = "eh-settings-v1";
const STORE_VERSION = 1;

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      version: STORE_VERSION,
      theme: "dark",
      density: "comfortable",
      hasHydrated: false,
      setTheme: (theme) => set({ theme }),
      setDensity: (density) => set({ density }),
      _setHydrated: (h) => set({ hasHydrated: h }),
    }),
    {
      name: STORAGE_KEY,
      version: STORE_VERSION,
      storage: createJSONStorage(() => localStorage),
      // Migration scaffold (future versions can transform shape here)
      migrate: (persisted: any, _from) => {
        if (!persisted) return persisted;
        return persisted;
      },
      onRehydrateStorage: () => (state) => {
        // After rehydration, mark as hydrated to avoid flicker-sensitive consumers.
        state?._setHydrated(true);
      },
      partialize: (s) => ({
        version: s.version,
        theme: s.theme,
        density: s.density,
      }),
    }
  )
);

// ------------------------------ DOM Utilities --------------------------------

/**
 * Ensure a <meta name="theme-color"> exists and is updated.
 * Helps Android address bar and some desktop UIs match the current theme.
 */
const ensureAndSetThemeColorMeta = (color: string) => {
  let meta = document.querySelector('meta[name="theme-color"]') as
    | HTMLMetaElement
    | null;
  if (!meta) {
    meta = document.createElement("meta");
    meta.name = "theme-color";
    document.head.appendChild(meta);
  }
  meta.content = color;
};

/**
 * Apply root classes and attributes for theme and density.
 * This is idempotent and safe to call frequently.
 */
const applyRootAppearance = (theme: Theme, density: Density) => {
  const root = document.documentElement;
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  const effectiveTheme = theme === "system" ? (prefersDark ? "dark" : "light") : theme;

  // Class management
  const cls = new Set(root.className.split(/\s+/).filter(Boolean));
  cls.delete("eh-light");
  cls.delete("eh-dark");
  cls.delete("eh-density-comfortable");
  cls.delete("eh-density-compact");

  cls.add(effectiveTheme === "dark" ? "eh-dark" : "eh-light");
  cls.add(density === "compact" ? "eh-density-compact" : "eh-density-comfortable");
  root.className = Array.from(cls).join(" ");

  // data-theme attribute for CSS hooks and testing
  root.setAttribute("data-theme", effectiveTheme);

  // color-scheme helps native form controls adapt
  root.style.colorScheme = effectiveTheme;

  // Browser UI tint (align with brand surfaces for each theme)
  // Using Deep Indigo for dark, Clean White for light to maximize contrast with UI chrome.
  ensureAndSetThemeColorMeta(effectiveTheme === "dark" ? "#1A2B45" : "#FFFFFF");
};

// ------------------------------- Provider ------------------------------------

export interface ThemeProviderProps {
  children: ReactNode;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const theme = useSettingsStore((s) => s.theme);
  const density = useSettingsStore((s) => s.density);

  // Keep a stable reference to the media query to attach/detach listeners correctly.
  const mqlRef = useRef<MediaQueryList | null>(null);

  // Apply theme & density on mount and whenever settings change.
  useEffect(() => {
    applyRootAppearance(theme, density);
  }, [theme, density]);

  // React to OS theme changes when theme === "system".
  useEffect(() => {
    const mql =
      mqlRef.current ??
      window.matchMedia("(prefers-color-scheme: dark)");

    mqlRef.current = mql;

    const handleChange = () => {
      // Only re-apply when following the system.
      if (useSettingsStore.getState().theme === "system") {
        applyRootAppearance("system", useSettingsStore.getState().density);
      }
    };

    // Modern browsers use 'change', older WebKit may require addListener
    if (typeof mql.addEventListener === "function") {
      mql.addEventListener("change", handleChange);
    } else if (typeof (mql as any).addListener === "function") {
      (mql as any).addListener(handleChange);
    }

    return () => {
      if (typeof mql.removeEventListener === "function") {
        mql.removeEventListener("change", handleChange);
      } else if (typeof (mql as any).removeListener === "function") {
        (mql as any).removeListener(handleChange);
      }
    };
  }, []);

  return <>{children}</>;
};

export default ThemeProvider;
</file>

<file path="src/app/App.tsx">
// src/app/App.tsx
import React, { useEffect, useRef } from "react";
import { ErrorProvider } from "./providers/ErrorProvider";
import { MotionProvider } from "./providers/MotionProvider";
import { ThemeProvider } from "./providers/ThemeProvider";
import { AppShell } from "@/components/layout/AppShell";
import Toasts from "@/components/feedback/Toasts";
import { useHotkeys } from "@/lib/utils/useHotkeys";
import { usePlayerStore } from "@/lib/state/usePlayerStore";
import { setPlaybackState, setPositionState } from "@/lib/utils/MediaSession";

/**
 * App
 * -----------------------------------------------------------------------------
 * Root composition for providers and the main layout.
 * - Wires global hotkeys to the player store (with tolerant fallbacks).
 * - Syncs Media Session playback + position state for OS integrations.
 * - Mounts Toasts once for global notifications.
 */

// ---- Store selectors (primitive for low re-render cost) ---------------------
function usePlayerSelectors() {
  const isPlaying = usePlayerStore((s: any) =>
    typeof s.isPlaying === "boolean" ? s.isPlaying : s.playbackState === "playing"
  );
  const play = usePlayerStore((s: any) => s.play ?? s.playAsync);
  const pause = usePlayerStore((s: any) => s.pause);
  const toggle = usePlayerStore((s: any) => s.toggle ?? s.togglePlay);
  const seek = usePlayerStore((s: any) => s.seek ?? s.seekTo);
  const currentTime = usePlayerStore((s: any) => s.currentTime ?? s.position ?? 0);
  const duration = usePlayerStore((s: any) => s.duration ?? 0);
  const playbackRate = usePlayerStore((s: any) => s.playbackRate ?? 1);
  const volume = usePlayerStore((s: any) => (typeof s.volume === "number" ? s.volume : 1));
  const setVolume = usePlayerStore((s: any) => s.setVolume as ((v: number) => void) | undefined);
  const muted = usePlayerStore((s: any) => Boolean(s.muted));
  const toggleMute = usePlayerStore((s: any) => s.toggleMute as (() => void) | undefined);
  return {
    isPlaying,
    play,
    pause,
    toggle,
    seek,
    currentTime,
    duration,
    playbackRate,
    volume,
    setVolume,
    muted,
    toggleMute,
  };
}

export const App: React.FC = () => {
  const {
    isPlaying,
    play,
    pause,
    toggle,
    seek,
    currentTime,
    duration,
    playbackRate,
    volume,
    setVolume,
    toggleMute,
  } = usePlayerSelectors();

  // ---- Global hotkeys -------------------------------------------------------
  useHotkeys({
    " ": (e) => {
      e.preventDefault();
      // Prefer store toggle if present
      if (typeof toggle === "function") toggle();
      else if (isPlaying) pause?.();
      else play?.();
    },
    arrowleft: (e) => {
      e.preventDefault();
      if (typeof seek === "function") seek(Math.max(0, (currentTime || 0) - 5));
    },
    arrowright: (e) => {
      e.preventDefault();
      if (typeof seek === "function") seek(Math.min(duration || Infinity, (currentTime || 0) + 5));
    },
    arrowup: (e) => {
      e.preventDefault();
      if (typeof setVolume === "function") setVolume(Math.min(1, (volume || 0) + 0.05));
    },
    arrowdown: (e) => {
      e.preventDefault();
      if (typeof setVolume === "function") setVolume(Math.max(0, (volume || 0) - 0.05));
    },
    m: () => {
      if (typeof toggleMute === "function") toggleMute();
      else if (typeof setVolume === "function") setVolume((volume || 0) > 0 ? 0 : 0.8);
    },
    // R, S, T, P reserved for later phases
  });

  // ---- Media Session sync (state + position) --------------------------------
  // Playback state (playing/paused)
  useEffect(() => {
    setPlaybackState(isPlaying ? "playing" : "paused");
  }, [isPlaying]);

  // Position state (duration/position/rate). Throttled to ~2Hz to avoid churn.
  const posTickRef = useRef<number | null>(null);
  useEffect(() => {
    if (posTickRef.current) window.clearInterval(posTickRef.current);
    posTickRef.current = window.setInterval(() => {
      setPositionState({
        duration: Number.isFinite(duration) ? duration : undefined,
        position: Number.isFinite(currentTime) ? currentTime : undefined,
        playbackRate: Number.isFinite(playbackRate) ? playbackRate : undefined,
      });
    }, 500);
    return () => {
      if (posTickRef.current) window.clearInterval(posTickRef.current);
      posTickRef.current = null;
    };
  }, [duration, currentTime, playbackRate]);

  return (
    <ThemeProvider>
      <MotionProvider>
        <ErrorProvider>
          <AppShell />
          {/* Global toasts (mount once) */}
          <Toasts />
        </ErrorProvider>
      </MotionProvider>
    </ThemeProvider>
  );
};

export default App;
</file>

<file path="src/app/routes.tsx">
// src/app/routes.tsx
/**
 * routes.tsx — Store-driven view switcher (no React Router)
 * -----------------------------------------------------------------------------
 * Ethereal Harmony keeps routing intentionally simple for V1:
 *  - A tiny registry of "routes" (player, settings, stream).
 *  - The current route lives in our Settings store (useSettingsStore).
 *  - We mirror the route to location.hash for shareable URLs and back/forward.
 *
 * How it's used:
 *  - SidePanel can render nav using `ROUTE_ORDER` / `ROUTES` and call `navigate`.
 *  - AppShell (or any page frame) can render route-specific content via <RouteSwitch/>.
 *  - If you don’t render <RouteSwitch/>, the "player" view still works:
 *      AppShell already contains the visualizer + player UI as the baseline.
 *
 * Design goals:
 *  - Zero external deps
 *  - Safe in StrictMode
 *  - Works without SSR assumptions
 */

import React, { useEffect } from "react";
import { useSettingsStore } from "@/lib/state/useSettingsStore";
import StreamTestWizard from "@/components/streaming/StreamTestWizard";
import EqPanel from "@/components/settings/EqPanel";
import VisualizerControls from "@/components/settings/VisualizerControls";
import AudioDevicePicker from "@/components/settings/AudioDevicePicker";

/* ----------------------------------------------------------------------------
 * Types & constants
 * ------------------------------------------------------------------------- */

/** Route identifiers for Phase 1/2 */
export type RouteId = "player" | "settings" | "stream";

/** Route definition for simple registry-driven navigation */
export type RouteConfig = {
  id: RouteId;
  /** Human label for SidePanel or TopBar menus */
  label: string;
  /** Hash path (no slashes to keep URLs clean): e.g. #settings */
  hash: string;
  /** Optional short description for tooltips */
  description?: string;
  /** Optional icon (text/emoji or JSX); consumers decide how to render */
  icon?: React.ReactNode;
  /** Optional render function for route-specific panels (see <RouteSwitch/>) */
  render?: () => React.ReactNode;
};

/** Canonical order for menus */
export const ROUTE_ORDER: RouteId[] = ["player", "settings", "stream"];

/** Route registry */
export const ROUTES: Record<RouteId, RouteConfig> = {
  player: {
    id: "player",
    label: "Player",
    hash: "player",
    description: "Now Playing & Visualizer",
    icon: "▶",
    // AppShell already renders the Player baseline; keep this empty by default.
    render: () => null,
  },
  settings: {
    id: "settings",
    label: "Settings",
    hash: "settings",
    description: "EQ, devices, and visualizer controls",
    icon: "⚙️",
    render: () => (
      <section
        aria-label="Settings"
        style={{
          display: "grid",
          gap: 12,
          padding: 12,
        }}
      >
        {/* Visualizer controls (HDR/Dimmer/Preset) */}
        <VisualizerControls />

        {/* Equalizer */}
        <EqPanel />

        {/* Output device picker */}
        <AudioDevicePicker />
      </section>
    ),
  },
  stream: {
    id: "stream",
    label: "Stream Tester",
    hash: "stream",
    description: "Validate HLS or direct audio URLs",
    icon: "📡",
    render: () => (
      <div style={{ padding: 12 }}>
        <StreamTestWizard />
      </div>
    ),
  },
};

/* ----------------------------------------------------------------------------
 * Hash <-> Store synchronization
 * ------------------------------------------------------------------------- */

/** Convert a hash string ("#settings") to a RouteId, defaulting to "player". */
export function routeFromHash(hash: string | null | undefined): RouteId {
  const h = (hash || "").replace(/^#/, "").trim().toLowerCase();
  const ids = new Set<RouteId>(ROUTE_ORDER);
  return (h && ids.has(h as RouteId) ? (h as RouteId) : "player");
}

/** Push a new route to the store and URL hash (without reloading). */
export function navigate(id: RouteId) {
  const conf = ROUTES[id];
  if (!conf) return;

  // Update store (single source of truth for the app)
  try {
    const setView = (useSettingsStore.getState() as any).setView as (v: RouteId) => void;
    if (typeof setView === "function") setView(id);
  } catch {
    // ignore: store not ready (rare)
  }

  // Mirror to URL hash for shareable/back-forward navigation
  if (typeof window !== "undefined") {
    const target = `#${conf.hash}`;
    if (window.location.hash !== target) {
      // pushState keeps the stack; users can go back
      window.history.pushState(null, "", target);
    }
  }
}

/**
 * Install listeners to keep store and hash in sync.
 * Call once at app start; safe to call multiple times (idempotent).
 */
export function installHashSync() {
  if (typeof window === "undefined") return;

  // Initialize store from the current hash
  const initial = routeFromHash(window.location.hash);
  try {
    const setView = (useSettingsStore.getState() as any).setView as (v: RouteId) => void;
    const curView = (useSettingsStore.getState() as any).view as RouteId | undefined;
    if (typeof setView === "function" && initial && curView !== initial) {
      setView(initial);
    }
  } catch {
    // ignore
  }

  // Update store on browser navigation (back/forward or manual hash edits)
  const onHash = () => {
    const id = routeFromHash(window.location.hash);
    try {
      const setView = (useSettingsStore.getState() as any).setView as (v: RouteId) => void;
      if (typeof setView === "function") setView(id);
    } catch {
      // ignore
    }
  };

  // Use both 'hashchange' and 'popstate' for robustness across browsers
  window.addEventListener("hashchange", onHash);
  window.addEventListener("popstate", onHash);

  // HMR cleanup
  if ((import.meta as any)?.hot) {
    (import.meta as any).hot.dispose(() => {
      window.removeEventListener("hashchange", onHash);
      window.removeEventListener("popstate", onHash);
    });
  }
}

/* ----------------------------------------------------------------------------
 * React helpers
 * ------------------------------------------------------------------------- */

/**
 * Hook that returns the active RouteId from the store, installing hash sync on mount.
 */
export function useRoute(): RouteId {
  // Install hash sync once when any consumer mounts
  useEffect(() => {
    installHashSync();
  }, []);

  // Our settings store should expose `view` and `setView`
  const view = useSettingsStore((s: any) => (s.view as RouteId) ?? "player");
  return view;
}

/**
 * RouteSwitch — Optional renderer for route-specific panels.
 * This is intentionally small: AppShell already renders the baseline "player"
 * surface. For "settings" and "stream", we render additional content here.
 *
 * Usage:
 *   <main>
 *     ... baseline UI ...
 *     <RouteSwitch />
 *   </main>
 */
export const RouteSwitch: React.FC = () => {
  const id = useRoute();
  const conf = ROUTES[id];
  if (!conf?.render) return null;
  return <>{conf.render()}</>;
};

/**
 * Helper that returns a lightweight list of routes for menus (e.g., SidePanel).
 * The result is stable across renders (except for identity of JSX icons).
 */
export function useRouteList(): Array<Pick<RouteConfig, "id" | "label" | "hash" | "icon" | "description">> {
  // No state here—static registry. This is provided as a hook for API symmetry.
  return ROUTE_ORDER.map((id) => {
    const { label, hash, icon, description } = ROUTES[id];
    return { id, label, hash, icon, description };
  });
};
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/diagnostics/DevToggle.tsx">
```tsx
/**
 * src/components/diagnostics/DevToggle.tsx
 * Ethereal Harmony — Developer Diagnostics Toggle
 *
 * Purpose within the project:
 * - A compact, always-available floating control to enable/disable "dev mode"
 *   and common diagnostics for Phase 1–2 development. This is intentionally
 *   minimal and safe: it does not alter audio behavior, and only toggles UI/
 *   visualizer diagnostics flags in our domain stores when those flags exist.
 *
 * How it integrates:
 * - UI domain (useUIStore): reads/writes a conventional `devMode` boolean and an
 *   optional `toggleDevMode()` action if present.
 * - Visualizer domain (useVizStore): reads/writes optional diagnostics flags such
 *   as `showStats` (FPS meter), `showBounds`, `wireframe`, etc. If a flag/action
 *   is not defined in the store yet, the toggle gracefully no-ops and still
 *   persists a local shadow value to localStorage (`eh.dev.*`) so future code can
 *   pick it up on boot without breaking the current app.
 * - Settings (useSettingsStore): currently not required for Phase 1; left as a
 *   soft integration spot if we add settings-driven diagnostics later.
 *
 * Design/system:
 * - React 18 + TypeScript + Vite
 * - Zustand (selectors kept primitive to avoid re-renders)
 * - Framer Motion for panel animation (Material-like fluidity)
 * - Glassmorphism tokens (radius 16px, blur 16px, rgba(255,255,255,0.12), border rgba(255,255,255,0.25))
 * - Palette: #1A2B45 (bg), #7F6A9F (accent), #00F0FF (highlight)
 * - Fonts: Montserrat (700) for headings, Lato (400) for body (inherited globally)
 * - WCAG AA: sufficient contrast, focus-visible ring, ARIA-correct controls
 *
 * Accessibility:
 * - Main control is a toggle button (aria-pressed, role="switch") with a label.
 * - Panel controls are checkbox inputs with labels and keyboard support.
 * - Global hotkey: Ctrl+` toggles the dev panel quickly (desktop convenience).
 *
 * Privacy:
 * - Only local persistence (localStorage). No external logging/telemetry.
 *
 * SSR/rehydration safety:
 * - Guards all window/localStorage access.
 * - Does not assume store fields exist; defensive feature-detection with
 *   optional chaining and "shadow" local persistence.
 */

import * as React from "react";
import { motion, AnimatePresence } from "framer-motion";

// Domain stores (Phase 1/2). We avoid deep type coupling by using `any`-safe selectors.
// The files exist in this project per the build plan. If a particular flag/action
// isn't implemented yet in a store, we gracefully no-op.
import { useUIStore } from "@/lib/state/useUIStore";
import { useVizStore } from "@/lib/state/useVizStore";
// Optional future wiring: import { useSettingsStore } from "@/lib/state/useSettingsStore";

/* --------------------------------- Helpers -------------------------------- */

const IS_BROWSER = typeof window !== "undefined";

const readLS = (key: string, fallback = "false") =>
  IS_BROWSER ? window.localStorage.getItem(key) ?? fallback : fallback;

const writeLS = (key: string, value: string) => {
  if (!IS_BROWSER) return;
  try {
    window.localStorage.setItem(key, value);
  } catch {
    // ignore quota/denied
  }
};

const toggleBooleanLS = (key: string): boolean => {
  const current = readLS(key, "false") === "true";
  const next = (!current).toString();
  writeLS(key, next);
  return !current;
};

// Selector helpers (primitive). We intentionally accept `any` to avoid hard coupling.
// Components subscribe to minimal primitives to prevent render loops.
const selectDevMode = (s: any) => (typeof s?.devMode === "boolean" ? s.devMode : false);
const selectToggleDevMode = (s: any) => (typeof s?.toggleDevMode === "function" ? s.toggleDevMode : undefined);

const selectShowStats = (s: any) => (typeof s?.showStats === "boolean" ? s.showStats : readLS("eh.dev.showStats") === "true");
const selectSetShowStats = (s: any) => (typeof s?.setShowStats === "function" ? s.setShowStats : undefined);

const selectShowBounds = (s: any) => (typeof s?.showBounds === "boolean" ? s.showBounds : readLS("eh.dev.showBounds") === "true");
const selectSetShowBounds = (s: any) => (typeof s?.setShowBounds === "function" ? s.setShowBounds : undefined);

const selectWireframe = (s: any) => (typeof s?.wireframe === "boolean" ? s.wireframe : readLS("eh.dev.wireframe") === "true");
const selectSetWireframe = (s: any) => (typeof s?.setWireframe === "function" ? s.setWireframe : undefined);

/* ------------------------------ UI Component ------------------------------ */

export const DevToggle: React.FC = () => {
  // ------------------------------ Store wiring -----------------------------
  // UI store: dev mode
  const devMode = useUIStore(selectDevMode);
  const toggleDevMode = useUIStore(selectToggleDevMode);

  // Visualizer diagnostics (optional flags)
  const showStats = useVizStore(selectShowStats);
  const setShowStats = useVizStore(selectSetShowStats);

  const showBounds = useVizStore(selectShowBounds);
  const setShowBounds = useVizStore(selectSetShowBounds);

  const wireframe = useVizStore(selectWireframe);
  const setWireframe = useVizStore(selectSetWireframe);

  // ------------------------------ Local state ------------------------------
  // Panel visibility is local UI-only: do not persist to stores
  const [open, setOpen] = React.useState<boolean>(false);
  // Hydration guard for any DOM-only behavior
  const [mounted, setMounted] = React.useState<boolean>(false);

  React.useEffect(() => {
    setMounted(true);
  }, []);

  // Sync a local "shadow" devMode if store action not present yet
  const localDevMode = React.useMemo<boolean>(() => readLS("eh.dev.mode") === "true", []);
  const effectiveDevMode = toggleDevMode ? devMode : localDevMode;

  // ------------------------------ Handlers ---------------------------------
  const handleToggleDevMode = () => {
    if (toggleDevMode) {
      toggleDevMode();
      // Also mirror into LS for tools that read outside of React
      writeLS("eh.dev.mode", (!devMode).toString());
    } else {
      const next = toggleBooleanLS("eh.dev.mode");
      // Broadcast a custom event so any non-React diagnostics can react.
      if (IS_BROWSER) window.dispatchEvent(new CustomEvent("eh:devmode", { detail: { enabled: next } }));
    }
  };

  const handleToggleStats = () => {
    if (setShowStats) {
      setShowStats(!showStats);
      writeLS("eh.dev.showStats", (!showStats).toString());
    } else {
      const next = toggleBooleanLS("eh.dev.showStats");
      if (IS_BROWSER) window.dispatchEvent(new CustomEvent("eh:viz:stats", { detail: { enabled: next } }));
    }
  };

  const handleToggleBounds = () => {
    if (setShowBounds) {
      setShowBounds(!showBounds);
      writeLS("eh.dev.showBounds", (!showBounds).toString());
    } else {
      const next = toggleBooleanLS("eh.dev.showBounds");
      if (IS_BROWSER) window.dispatchEvent(new CustomEvent("eh:viz:bounds", { detail: { enabled: next } }));
    }
  };

  const handleToggleWireframe = () => {
    if (setWireframe) {
      setWireframe(!wireframe);
      writeLS("eh.dev.wireframe", (!wireframe).toString());
    } else {
      const next = toggleBooleanLS("eh.dev.wireframe");
      if (IS_BROWSER) window.dispatchEvent(new CustomEvent("eh:viz:wireframe", { detail: { enabled: next } }));
    }
  };

  // Keyboard shortcut: Ctrl + ` toggles the panel
  React.useEffect(() => {
    if (!mounted) return;
    const onKey = (e: KeyboardEvent) => {
      // Windows/Linux/Chromebook: ctrlKey; macOS devs can use ctrlKey as well
      if (e.ctrlKey && (e.key === "`" || e.code === "Backquote")) {
        e.preventDefault();
        setOpen((o) => !o);
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [mounted]);

  // ------------------------------- Rendering -------------------------------
  // Colors/tokens (centralized here to avoid external CSS for a one-off dev tool)
  const TOKENS = {
    radius: 16,
    blur: 16,
    bg: "rgba(255,255,255,0.12)",
    border: "1px solid rgba(255,255,255,0.25)",
    base: "#1A2B45",
    accent: "#7F6A9F",
    highlight: "#00F0FF",
  };

  // Button + panel share a11y name
  const label = "Developer diagnostics";

  return (
    <div
      aria-label="Developer diagnostics controls"
      style={{
        position: "fixed",
        zIndex: 9999,
        right: 16,
        bottom: 16,
        display: "flex",
        flexDirection: "column",
        alignItems: "flex-end",
        gap: 8,
        pointerEvents: "none", // container ignores clicks; children re-enable
      }}
    >
      {/* Panel */}
      <AnimatePresence>
        {open && (
          <motion.div
            key="dev-panel"
            initial={{ opacity: 0, y: 8, scale: 0.98 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: 8, scale: 0.98 }}
            transition={{ type: "spring", stiffness: 420, damping: 36, mass: 0.8 }}
            role="region"
            aria-label="Diagnostics panel"
            style={{
              pointerEvents: "auto",
              backdropFilter: `blur(${TOKENS.blur}px)`,
              WebkitBackdropFilter: `blur(${TOKENS.blur}px)`,
              background: TOKENS.bg,
              border: TOKENS.border,
              borderRadius: TOKENS.radius,
              color: "white",
              boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
              padding: 12,
              minWidth: 260,
            }}
          >
            <div
              style={{
                fontFamily: "Montserrat, system-ui, sans-serif",
                fontWeight: 700,
                fontSize: 12,
                letterSpacing: 0.5,
                textTransform: "uppercase",
                color: TOKENS.highlight,
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: 8,
              }}
            >
              <span>Diagnostics</span>
              <kbd
                aria-label="Shortcut"
                title="Ctrl + `"
                style={{
                  fontFamily: "monospace",
                  background: "rgba(0,0,0,0.35)",
                  border: "1px solid rgba(255,255,255,0.2)",
                  borderRadius: 6,
                  padding: "2px 6px",
                  color: "#fff",
                }}
              >
                Ctrl+`
              </kbd>
            </div>

            {/* Toggles */}
            <fieldset
              aria-label="Developer options"
              style={{
                border: "none",
                margin: 0,
                padding: 0,
                display: "grid",
                gap: 8,
              }}
            >
              {/* Dev Mode */}
              <label
                style={{
                  display: "grid",
                  gridTemplateColumns: "1fr auto",
                  alignItems: "center",
                  gap: 12,
                  fontFamily: "Lato, system-ui, sans-serif",
                  fontSize: 13.5,
                }}
              >
                <span>Enable dev mode</span>
                <input
                  type="checkbox"
                  role="switch"
                  aria-checked={effectiveDevMode}
                  checked={effectiveDevMode}
                  onChange={handleToggleDevMode}
                  style={{ width: 18, height: 18, accentColor: TOKENS.highlight, cursor: "pointer" }}
                />
              </label>

              {/* FPS / Stats */}
              <label
                style={{
                  display: "grid",
                  gridTemplateColumns: "1fr auto",
                  alignItems: "center",
                  gap: 12,
                  fontFamily: "Lato, system-ui, sans-serif",
                  fontSize: 13.5,
                }}
              >
                <span>Visualizer FPS / stats</span>
                <input
                  type="checkbox"
                  role="switch"
                  aria-checked={!!showStats}
                  checked={!!showStats}
                  onChange={handleToggleStats}
                  style={{ width: 18, height: 18, accentColor: TOKENS.highlight, cursor: "pointer" }}
                />
              </label>

              {/* Bounds */}
              <label
                style={{
                  display: "grid",
                  gridTemplateColumns: "1fr auto",
                  alignItems: "center",
                  gap: 12,
                  fontFamily: "Lato, system-ui, sans-serif",
                  fontSize: 13.5,
                }}
              >
                <span>Show object bounds</span>
                <input
                  type="checkbox"
                  role="switch"
                  aria-checked={!!showBounds}
                  checked={!!showBounds}
                  onChange={handleToggleBounds}
                  style={{ width: 18, height: 18, accentColor: TOKENS.highlight, cursor: "pointer" }}
                />
              </label>

              {/* Wireframe */}
              <label
                style={{
                  display: "grid",
                  gridTemplateColumns: "1fr auto",
                  alignItems: "center",
                  gap: 12,
                  fontFamily: "Lato, system-ui, sans-serif",
                  fontSize: 13.5,
                }}
              >
                <span>Wireframe materials</span>
                <input
                  type="checkbox"
                  role="switch"
                  aria-checked={!!wireframe}
                  checked={!!wireframe}
                  onChange={handleToggleWireframe}
                  style={{ width: 18, height: 18, accentColor: TOKENS.highlight, cursor: "pointer" }}
                />
              </label>
            </fieldset>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Floating main toggle button */}
      <motion.button
        type="button"
        aria-label={label}
        title={label}
        role="switch"
        aria-pressed={open}
        onClick={() => setOpen((o) => !o)}
        onKeyDown={(e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            setOpen((o) => !o);
          }
        }}
        style={{
          pointerEvents: "auto",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          width: 44,
          height: 44,
          borderRadius: TOKENS.radius,
          backdropFilter: `blur(${TOKENS.blur}px)`,
          WebkitBackdropFilter: `blur(${TOKENS.blur}px)`,
          background: TOKENS.bg,
          border: TOKENS.border,
          color: open ? TOKENS.highlight : "#FFFFFF",
          boxShadow: open ? "0 8px 24px rgba(0, 240, 255, 0.35)" : "0 8px 24px rgba(0,0,0,0.35)",
          outline: "none",
          cursor: "pointer",
        }}
        whileTap={{ scale: 0.96 }}
        whileHover={{ scale: 1.05 }}
        transition={{ type: "spring", stiffness: 460, damping: 32, mass: 0.7 }}
      >
        {/* Simple glyph (</>) */}
        <svg
          aria-hidden="true"
          width="22"
          height="22"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="1.8"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <polyline points="16 18 22 12 16 6" />
          <polyline points="8 6 2 12 8 18" />
        </svg>
      </motion.button>
    </div>
  );
};

export default DevToggle;
```
</file>

<file path="src/components/diagnostics/PerfOverlayMount.tsx">
// src/components/diagnostics/PerfOverlayMount.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * PerfOverlayMount
 * -----------------------------------------------------------------------------
 * React wrapper that mounts/unmounts the *non-React* PerfOverlay based on:
 *   1) A persisted dev toggle in localStorage ("eh.dev.showStats"), and
 *   2) An optional `force` prop to always enable during development sessions.
 *
 * Why a wrapper?
 * - The overlay itself is framework-agnostic (implemented in src/lib/diagnostics/PerfOverlay.ts)
 *   and paints directly to the DOM for minimal overhead. This wrapper simply
 *   decides *when* to mount/unmount it and *where* (a container we own).
 *
 * Persistence contract:
 * - DevToggle writes the boolean preference to localStorage under the key
 *   "eh.dev.showStats". We listen to storage changes so toggling it elsewhere
 *   (DevToggle, another tab) updates the overlay live.
 *
 * Safety:
 * - Dynamic import of the overlay to keep it out of the main bundle (perf).
 * - Duck-typing its API so refactors in PerfOverlay don’t crash the app.
 * - No hard dependency on telemetry or other diagnostics.
 *
 * Accessibility:
 * - The overlay is visual-only and marked aria-hidden. It does not trap focus.
 *
 * Usage:
 *   <PerfOverlayMount />                         // respect saved toggle
 *   <PerfOverlayMount force={import.meta.env.DEV} /> // always on in dev
 */

// -------------------------- Config & Utilities -------------------------------

const STORAGE_KEY = "eh.dev.showStats";

/** Read boolean-ish value from localStorage safely. */
const readStoredEnabled = (): boolean => {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    // accept "true", "1", true
    return raw === "true" || raw === "1";
  } catch {
    return false;
  }
};

/** Write persisted value (DevToggle usually does this; included for completeness). */
const writeStoredEnabled = (value: boolean) => {
  try {
    localStorage.setItem(STORAGE_KEY, value ? "true" : "false");
  } catch {
    /* ignore storage failures */
  }
};

// ------------------------------- Types ---------------------------------------

export interface PerfOverlayMountProps {
  /**
   * Force-enable the overlay regardless of stored preference.
   * Useful during development or profiling sessions.
   */
  force?: boolean;

  /**
   * Optional inline style for the container that the non-React overlay mounts to.
   * Usually not needed, as the overlay positions itself (fixed) internally.
   */
  style?: React.CSSProperties;

  /**
   * Optional className for the mount container (not the overlay itself).
   */
  className?: string;
}

// ------------------------------ Component ------------------------------------

const PerfOverlayMount: React.FC<PerfOverlayMountProps> = ({
  force = false,
  style,
  className,
}) => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const overlayRef = useRef<any>(null);

  // Local state mirrors persisted toggle (unless `force` overrides it).
  const [persistedOn, setPersistedOn] = useState<boolean>(() => readStoredEnabled());

  // Effective flag combines force + persisted toggle.
  const enabled = useMemo(() => Boolean(force || persistedOn), [force, persistedOn]);

  // Keep in sync with external changes to localStorage (e.g., DevToggle or other tabs).
  useEffect(() => {
    const onStorage = (ev: StorageEvent) => {
      if (ev.key === STORAGE_KEY) {
        setPersistedOn(readStoredEnabled());
      }
    };
    window.addEventListener("storage", onStorage);
    return () => window.removeEventListener("storage", onStorage);
  }, []);

  // Mount / unmount overlay when `enabled` changes.
  useEffect(() => {
    let cancelled = false;

    const mount = async () => {
      try {
        // Lazy-load to keep core bundle lean.
        const mod = await import("@/lib/diagnostics/PerfOverlay");
        const OverlayCtor = (mod as any).PerfOverlay ?? (mod as any).default;

        if (!OverlayCtor || cancelled) return;

        // If we already have one, destroy it before creating a new one (defensive).
        if (overlayRef.current?.destroy) {
          try {
            overlayRef.current.destroy();
          } catch {
            /* noop */
          }
          overlayRef.current = null;
        }

        // Create overlay instance. We pass a parent container so it doesn't
        // attach at document.body unless that’s what it prefers.
        const instance = new OverlayCtor({
          parent:
            containerRef.current ??
            // Fallback to body if no container (shouldn't happen in normal flow).
            document.body,
        });

        // Duck-typed lifecycle: support any of start/mount/show as entrypoints.
        if (typeof instance.mount === "function") instance.mount();
        else if (typeof instance.start === "function") instance.start();
        else if (typeof instance.show === "function") instance.show();

        // Keep a reference for cleanup.
        overlayRef.current = instance;

        // Expose in dev tools for quick inspection.
        try {
          (window as any).__EH_PERF_OVERLAY__ = instance;
        } catch {
          /* ignore */
        }
      } catch (err) {
        // eslint-disable-next-line no-console
        console.warn("[Ethereal Harmony] Failed to load PerfOverlay:", err);
      }
    };

    const unmount = () => {
      if (!overlayRef.current) return;
      try {
        // Duck-typed cleanup: stop/hide/destroy, whatever is available.
        if (typeof overlayRef.current.destroy === "function") overlayRef.current.destroy();
        else if (typeof overlayRef.current.stop === "function") overlayRef.current.stop();
        else if (typeof overlayRef.current.hide === "function") overlayRef.current.hide();
      } catch {
        /* noop */
      } finally {
        overlayRef.current = null;
      }
    };

    if (enabled) {
      mount();
    } else {
      unmount();
    }

    return () => {
      cancelled = true;
      unmount();
    };
  }, [enabled]);

  // If `force` toggles, mirror the new state into storage so DevToggle UI stays consistent.
  useEffect(() => {
    // Do not overwrite user preference if not forcing.
    if (force) writeStoredEnabled(true);
  }, [force]);

  return (
    // This container is a mounting anchor for the non-React overlay.
    // It is visually inert; the overlay paints its own fixed-position surface.
    <div
      ref={containerRef}
      className={className}
      style={{
        position: "relative",
        // Intentionally non-intrusive: no size; overlay handles its own layout.
        width: 0,
        height: 0,
        // Allow consumers to override if they really want to.
        ...style,
      }}
      aria-hidden="true"
      data-perf-overlay-anchor
    />
  );
};

export default PerfOverlayMount;
</file>

<file path="src/components/feedback/ErrorBoundary.tsx">
// src/components/feedback/ErrorBoundary.tsx
import React from "react";

/**
 * ErrorBoundary
 * -----------------------------------------------------------------------------
 * Phase: 1 (Foundation)
 * Scope: App-wide crash containment and user-friendly recovery UI.
 *
 * Design + Architecture notes (kept as code comments for maintainability):
 * - Lives under `src/components/feedback/` as defined in the build plan.
 * - Presents an accessible, keyboard-navigable recovery panel with WCAG-AA
 *   contrast on a glassmorphism surface, matching the tokens in styles/tokens.css.
 * - Avoids coupling to telemetry for V1; logs to console and emits a DOM CustomEvent
 *   ("eh:error") so diagnostics modules (e.g., PerfOverlay/PerfEvents) can optionally
 *   listen without hard imports to keep the boundary self-contained and resilient.
 * - Provides three actions:
 *     1) Reload (hard refresh)
 *     2) Soft Reset (clear likely persisted keys, then reload)
 *     3) Copy Details (error + component stack) for bug reports (dev-friendly)
 * - Details panel is collapsed by default; visible in development or when the user
 *   requests it, to avoid overwhelming end users.
 *
 * A11y:
 * - Uses role="alertdialog" with aria-labelledby/aria-describedby.
 * - First heading is auto-focused when the boundary is shown.
 * - All actions have clear, descriptive labels and keyboard focus states.
 *
 * Styling:
 * - Uses CSS variables from tokens.css (colors, radii, blur).
 * - Kept inline here to avoid adding a separate CSS file for a single surface,
 *   but strictly adheres to the project's glass tokens and motion preferences.
 */

type Props = { children: React.ReactNode };
type State = {
  hasError: boolean;
  errorMessage?: string;
  componentStack?: string;
  timestamp?: number;
  showDetails: boolean;
};

export class ErrorBoundary extends React.Component<Props, State> {
  private headingRef = React.createRef<HTMLHeadingElement>();

  state: State = {
    hasError: false,
    errorMessage: undefined,
    componentStack: undefined,
    timestamp: undefined,
    showDetails: false,
  };

  static getDerivedStateFromError(error: unknown): Partial<State> {
    return {
      hasError: true,
      errorMessage: ErrorBoundary.stringifyError(error),
      timestamp: Date.now(),
    };
  }

  componentDidCatch(error: unknown, info: React.ErrorInfo) {
    // Minimal, local-first logging (telemetry is opt-in and handled separately in diagnostics).
    // eslint-disable-next-line no-console
    console.error("[Ethereal Harmony] Uncaught error:", error, info);

    // Store the component stack for "Copy details" and internal visibility.
    this.setState({ componentStack: info?.componentStack ?? "" });

    // Emit a DOM event that diagnostics/overlays can subscribe to without a compile-time dependency.
    try {
      const detail = {
        error: ErrorBoundary.stringifyError(error),
        stack: info?.componentStack ?? "",
        ts: Date.now(),
      };
      window.dispatchEvent(new CustomEvent("eh:error", { detail }));
      // Stash the last error on window for quick manual inspection during dev.
      (window as any).__EH_LAST_ERROR__ = detail;
    } catch {
      /* no-op */
    }
  }

  componentDidUpdate(_: Props, prevState: State) {
    if (!prevState.hasError && this.state.hasError && this.headingRef.current) {
      // After showing the boundary, move keyboard focus to the heading for SR and keyboard users.
      this.headingRef.current.focus();
    }
  }

  private static stringifyError(error: unknown): string {
    if (error instanceof Error) {
      return error.message || String(error);
    }
    try {
      return JSON.stringify(error);
    } catch {
      return String(error);
    }
  }

  private handleReload = () => {
    // Hard refresh to recover from unrecoverable error states (most reliable).
    location.reload();
  };

  private handleSoftReset = () => {
    // Best-effort soft reset: clear most likely persisted app keys while avoiding a full storage wipe.
    // Keys are subject to change; we match common prefixes and known store keys per blueprint.
    try {
      const candidates: string[] = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (!key) continue;
        const k = key.toLowerCase();
        if (
          k.includes("eh:") ||
          k.includes("ethereal-harmony") ||
          k.includes("zustand") ||
          k.includes("useplayerstore") ||
          k.includes("usevizstore") ||
          k.includes("usesettingsstore") ||
          k.includes("useuistore")
        ) {
          candidates.push(key);
        }
      }
      candidates.forEach((k) => localStorage.removeItem(k));
    } catch {
      /* ignore */
    } finally {
      location.reload();
    }
  };

  private handleCopyDetails = async () => {
    const { errorMessage, componentStack, timestamp } = this.state;
    const payload =
      `Ethereal Harmony — Crash Report\n` +
      `Time: ${new Date(timestamp ?? Date.now()).toISOString()}\n\n` +
      `Error: ${errorMessage ?? "(none)"}\n\n` +
      `Component Stack:\n${componentStack ?? "(none)"}\n\n` +
      `User Agent: ${navigator.userAgent}\n` +
      `URL: ${location.href}\n`;

    try {
      await navigator.clipboard.writeText(payload);
      // eslint-disable-next-line no-console
      console.info("[Ethereal Harmony] Error details copied to clipboard.");
    } catch {
      // Fallback: open a blob for manual copy
      const blob = new Blob([payload], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "eh-crash-report.txt";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    }
  };

  private toggleDetails = () => {
    this.setState((s) => ({ showDetails: !s.showDetails }));
  };

  render() {
    if (!this.state.hasError) {
      return this.props.children;
    }

    // Glassmorphism surface and overlay using tokens from styles/tokens.css.
    // Keeping inline JS styles limited to component-scoped layout so we don’t add a new CSS file.
    const overlayStyle: React.CSSProperties = {
      position: "fixed",
      inset: 0,
      display: "grid",
      placeItems: "center",
      background:
        "linear-gradient(135deg, rgba(26,43,69,0.92), rgba(127,106,159,0.85))", // Brand gradient tinted for contrast
      zIndex: 9999,
      padding: "24px",
    };

    const panelStyle: React.CSSProperties = {
      width: "min(720px, 92vw)",
      maxWidth: "92vw",
      color: "var(--eh-color-text, #FFFFFF)",
      background: "rgba(255,255,255,0.12)",
      backdropFilter: "blur(16px) saturate(120%)",
      WebkitBackdropFilter: "blur(16px) saturate(120%)",
      border: "1px solid rgba(255,255,255,0.25)",
      borderRadius: "16px",
      boxShadow:
        "0 8px 24px rgba(0,0,0,0.28), inset 0 1px 0 rgba(255,255,255,0.2)",
      padding: "24px",
      outline: "2px solid transparent",
    };

    const titleStyle: React.CSSProperties = {
      fontFamily: 'Montserrat, ui-sans-serif, system-ui, "Segoe UI", Roboto',
      fontWeight: 700,
      fontSize: "1.75rem",
      lineHeight: 1.25,
      margin: 0,
      marginBottom: "8px",
    };

    const descStyle: React.CSSProperties = {
      fontFamily: 'Lato, ui-sans-serif, system-ui, "Segoe UI", Roboto',
      fontSize: "1rem",
      lineHeight: 1.6,
      margin: 0,
      marginBottom: "16px",
      color: "rgba(255,255,255,0.9)",
    };

    const hintStyle: React.CSSProperties = {
      fontSize: "0.875rem",
      marginTop: "4px",
      marginBottom: "16px",
      color: "rgba(255,255,255,0.8)",
    };

    const buttonRowStyle: React.CSSProperties = {
      display: "flex",
      gap: "12px",
      flexWrap: "wrap",
      marginTop: "8px",
    };

    const buttonStyleBase: React.CSSProperties = {
      appearance: "none",
      fontFamily: 'Lato, ui-sans-serif, system-ui, "Segoe UI", Roboto',
      fontSize: "0.95rem",
      lineHeight: 1,
      borderRadius: "12px",
      padding: "12px 16px",
      border: "1px solid rgba(255,255,255,0.25)",
      background: "rgba(255,255,255,0.14)",
      color: "#FFFFFF",
      cursor: "pointer",
      transition: "transform 120ms ease, box-shadow 160ms ease, background 160ms",
      outlineOffset: "2px",
    };

    const primaryButton: React.CSSProperties = {
      ...buttonStyleBase,
      background:
        "linear-gradient(180deg, rgba(0,240,255,0.32), rgba(0,240,255,0.18))",
      borderColor: "rgba(0,240,255,0.6)",
      boxShadow: "0 4px 14px rgba(0,240,255,0.25)",
    };

    const secondaryButton: React.CSSProperties = {
      ...buttonStyleBase,
    };

    const detailBlockStyle: React.CSSProperties = {
      marginTop: "16px",
      padding: "12px 14px",
      borderRadius: "12px",
      border: "1px solid rgba(255,255,255,0.2)",
      background: "rgba(255,255,255,0.08)",
      fontFamily:
        'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
      fontSize: "0.85rem",
      whiteSpace: "pre-wrap",
      maxHeight: "30vh",
      overflow: "auto",
      color: "rgba(255,255,255,0.95)",
    };

    const linkLike: React.CSSProperties = {
      background: "none",
      border: "none",
      color: "rgba(0,240,255,1)",
      textDecoration: "underline",
      cursor: "pointer",
      padding: 0,
      margin: 0,
      font: "inherit",
    };

    const titleId = "eh-error-title";
    const descId = "eh-error-desc";

    const { errorMessage, componentStack, showDetails, timestamp } = this.state;

    return (
      <div
        style={overlayStyle}
        role="presentation"
        aria-hidden={false}
        data-testid="error-boundary-overlay"
      >
        <section
          style={panelStyle}
          role="alertdialog"
          aria-labelledby={titleId}
          aria-describedby={descId}
        >
          <h1
            id={titleId}
            ref={this.headingRef}
            tabIndex={-1}
            style={titleStyle}
          >
            Something went wrong
          </h1>

          <p id={descId} style={descStyle}>
            The app hit an unexpected error. You can reload, or try a soft
            reset if the issue persists.
          </p>
          <p style={hintStyle}>
            <strong>Time</strong>:{" "}
            {new Date(timestamp ?? Date.now()).toLocaleString()} •{" "}
            <strong>URL</strong>: {location.href}
          </p>

          <div style={buttonRowStyle}>
            <button
              type="button"
              onClick={this.handleReload}
              style={primaryButton}
              aria-label="Reload the application"
            >
              Reload
            </button>

            <button
              type="button"
              onClick={this.handleSoftReset}
              style={secondaryButton}
              aria-label="Reset saved settings and reload"
            >
              Soft reset & reload
            </button>

            <button
              type="button"
              onClick={this.handleCopyDetails}
              style={secondaryButton}
              aria-label="Copy error details to clipboard"
            >
              Copy details
            </button>

            <button
              type="button"
              onClick={this.toggleDetails}
              style={secondaryButton}
              aria-expanded={showDetails}
              aria-controls="eh-error-details"
            >
              {showDetails ? "Hide details" : "Show details"}
            </button>
          </div>

          {showDetails && (
            <div id="eh-error-details" style={detailBlockStyle}>
              <div>
                <strong>Error</strong>: {errorMessage ?? "(none)"}
              </div>
              <div>
                <strong>Component Stack</strong>:
              </div>
              <pre style={{ margin: 0 }}>{componentStack ?? "(none)"}</pre>
              <div style={{ marginTop: 8 }}>
                Having trouble repeatedly?{" "}
                <button onClick={this.handleSoftReset} style={linkLike}>
                  try a soft reset
                </button>{" "}
                or{" "}
                <button onClick={this.handleReload} style={linkLike}>
                  reload the app
                </button>
                .
              </div>
            </div>
          )}
        </section>
      </div>
    );
  }
}

export default ErrorBoundary;
</file>

<file path="src/components/feedback/Toasts.tsx">
// src/components/feedback/Toasts.tsx
/**
 * Toasts (Phase 2)
 * -----------------------------------------------------------------------------
 * Glassmorphism toasts with Framer Motion animations.
 * - Accessible: uses aria-live and role="status"/"alert" based on variant.
 * - Programmatic API: import { toast } and call toast.success("..."), etc.
 * - Auto-dismiss with per-toast duration; manual close is always available.
 * - No persistence; transient UI only.
 *
 * Usage:
 *  <Toasts />  // mount once near App root
 *  toast.success("Saved changes");
 */

import React, { useEffect } from "react";
import { create } from "zustand";
import { motion, AnimatePresence } from "framer-motion";

// ---- Types ------------------------------------------------------------------

type ToastVariant = "success" | "error" | "info";

export type ToastItem = {
  id: string;
  message: string;
  title?: string;
  variant?: ToastVariant;
  duration?: number; // ms; default 2800
};

// ---- Store (local, transient) -----------------------------------------------

type ToastState = {
  toasts: ToastItem[];
  add: (t: ToastItem) => void;
  remove: (id: string) => void;
  clear: () => void;
};

const useToastStore = create<ToastState>((set) => ({
  toasts: [],
  add: (t) =>
    set((s) => ({
      toasts: [...s.toasts, { duration: 2800, variant: "info", ...t }],
    })),
  remove: (id) =>
    set((s) => ({
      toasts: s.toasts.filter((t) => t.id !== id),
    })),
  clear: () => set({ toasts: [] }),
}));

// ---- Programmatic API -------------------------------------------------------

let _seq = 0;
const makeId = () => `${Date.now().toString(36)}-${(++_seq).toString(36)}`;

function push(message: string, opts: Omit<ToastItem, "id" | "message"> = {}) {
  const id = makeId();
  useToastStore.getState().add({ id, message, ...opts });
  return id;
}

function dismiss(id: string) {
  useToastStore.getState().remove(id);
}

function clear() {
  useToastStore.getState().clear();
}

export const toast = {
  push,
  dismiss,
  clear,
  success: (message: string, opts: Omit<ToastItem, "id" | "message" | "variant"> = {}) =>
    push(message, { ...opts, variant: "success" }),
  error: (message: string, opts: Omit<ToastItem, "id" | "message" | "variant"> = {}) =>
    push(message, { ...opts, variant: "error" }),
  info: (message: string, opts: Omit<ToastItem, "id" | "message" | "variant"> = {}) =>
    push(message, { ...opts, variant: "info" }),
};

// ---- Icons (inline SVGs) ----------------------------------------------------

const Icon: React.FC<{ variant: ToastVariant }> = ({ variant }) => {
  if (variant === "success") {
    return (
      <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
        <path
          d="M12 22a10 10 0 1 1 0-20 10 10 0 0 1 0 20Zm-1.2-6.2 6-6-1.4-1.4-4.6 4.58-2.2-2.18-1.4 1.42 3.6 3.58Z"
          fill="currentColor"
        />
      </svg>
    );
  }
  if (variant === "error") {
    return (
      <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
        <path
          d="M12 22a10 10 0 1 1 0-20 10 10 0 0 1 0 20Zm-1-6h2v2h-2v-2Zm0-8h2v6h-2V8Z"
          fill="currentColor"
        />
      </svg>
    );
  }
  return (
    <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
      <path
        d="M11 7h2v2h-2V7Zm0 4h2v6h-2v-6Zm1 11A10 10 0 1 1 12 1a10 10 0 0 1 0 20Z"
        fill="currentColor"
      />
    </svg>
  );
};

// ---- Single Toast view ------------------------------------------------------

const ToastView: React.FC<{ toast: ToastItem; onClose: (id: string) => void }> = ({
  toast,
  onClose,
}) => {
  const { id, message, title, duration = 2800, variant = "info" } = toast;

  // auto-dismiss
  useEffect(() => {
    const t = window.setTimeout(() => onClose(id), duration);
    return () => window.clearTimeout(t);
  }, [id, duration, onClose]);

  // color accent per variant
  const accent =
    variant === "success"
      ? "#00F0FF" // Radiant Aqua (on-brand)
      : variant === "error"
      ? "#ff6b6b"
      : "#7F6A9F"; // Soft Lavender

  return (
    <motion.div
      layout
      initial={{ y: 16, opacity: 0, scale: 0.98 }}
      animate={{ y: 0, opacity: 1, scale: 1 }}
      exit={{ y: 8, opacity: 0, scale: 0.98 }}
      transition={{ type: "spring", stiffness: 420, damping: 34, mass: 0.6 }}
      className="eh-toast"
      role={variant === "error" ? "alert" : "status"}
      aria-live={variant === "error" ? "assertive" : "polite"}
      style={{
        display: "grid",
        gridTemplateColumns: "18px 1fr auto",
        gap: 12,
        alignItems: "center",
        padding: "10px 12px",
        borderRadius: 16,
        // glass surface
        background: "rgba(255,255,255,0.12)",
        border: "1px solid rgba(255,255,255,0.25)",
        backdropFilter: "blur(16px)",
        boxShadow: "0 8px 24px rgba(0,0,0,0.28)",
        color: "#fff",
        minWidth: 280,
        maxWidth: 420,
      }}
    >
      <div
        aria-hidden
        style={{
          color: accent,
          display: "grid",
          placeItems: "center",
        }}
      >
        <Icon variant={variant} />
      </div>

      <div style={{ minWidth: 0 }}>
        {title ? (
          <div
            className="eh-toast-title"
            style={{ fontWeight: 700, fontFamily: "Montserrat, ui-sans-serif", marginBottom: 2 }}
          >
            {title}
          </div>
        ) : null}
        <div
          className="eh-toast-message"
          style={{
            fontFamily: "Lato, ui-sans-serif",
            fontSize: 14,
            lineHeight: 1.3,
            wordBreak: "break-word",
          }}
        >
          {message}
        </div>
      </div>

      <button
        type="button"
        className="eh-btn eh-btn--glass"
        aria-label="Dismiss notification"
        onClick={() => onClose(id)}
        style={{
          borderRadius: 10,
          padding: "4px 8px",
          color: "#fff",
          border: "1px solid rgba(255,255,255,0.25)",
          background: "rgba(255,255,255,0.10)",
        }}
      >
        ✕
      </button>

      {/* Accent bar */}
      <div
        aria-hidden
        style={{
          position: "absolute",
          left: 0,
          bottom: 0,
          height: 2,
          width: "100%",
          background:
            "linear-gradient(90deg, rgba(255,255,255,0.0) 0%, rgba(255,255,255,0.2) 35%, rgba(255,255,255,0.0) 100%)",
        }}
      />
      <div
        aria-hidden
        style={{
          position: "absolute",
          left: 0,
          bottom: 0,
          height: 2,
          width: "100%",
          transformOrigin: "left",
          background: accent,
          opacity: 0.7,
          // simple CSS progress via animation duration
          animation: `eh-toast-progress ${Math.max(800, duration)}ms linear forwards`,
        }}
      />
    </motion.div>
  );
};

// ---- Container --------------------------------------------------------------

const containerStyle: React.CSSProperties = {
  position: "fixed",
  bottom: 16,
  right: 16,
  display: "grid",
  gap: 10,
  zIndex: 9999,
  pointerEvents: "none", // allow clicks to pass through gaps
};

const listStyle: React.CSSProperties = {
  display: "grid",
  gap: 10,
  pointerEvents: "auto", // but toasts themselves are interactive
};

export const Toasts: React.FC = () => {
  const toasts = useToastStore((s) => s.toasts);
  const remove = useToastStore((s) => s.remove);

  return (
    <div className="eh-toasts" style={containerStyle} aria-live="polite" aria-atomic="false">
      <AnimatePresence initial={false}>
        <div style={listStyle}>
          {toasts.map((t) => (
            <ToastView key={t.id} toast={t} onClose={remove} />
          ))}
        </div>
      </AnimatePresence>
      {/* Inline keyframes (scoped) */}
      <style>
        {`
          @keyframes eh-toast-progress {
            from { transform: scaleX(1); }
            to { transform: scaleX(0); }
          }
        `}
      </style>
    </div>
  );
};

export default Toasts;
</file>

<file path="src/components/layout/AppChrome.tsx">
// src/components/layout/AppChrome.tsx
/**
 * AppChrome
 * -----------------------------------------------------------------------------
 * Purpose
 * - Provides header/footer "chrome" around the core application content.
 * - Hosts DevToggle (perf stats), quick-access icon actions, and keyboard focus
 *   management (FocusRing utilities) for a11y.
 *
 * Design
 * - Glassmorphism surfaces using project tokens/classes (see globals.css/tokens.css).
 * - Keyboard-only focus rings via :focus-visible AND a modality attribute helper.
 * - Fully accessible: landmark roles, skip link, ARIA labels/states, tooltips.
 *
 * Integration points
 * - Reads/writes settings from useSettingsStore (theme, view, showStats, hotkeys).
 * - Uses IconRegistry for consistent, cachable SVG icons.
 * - Emits "eh:viz:stats" via setShowStats() (store dispatches DOM event).
 *
 * Notes
 * - Keep this component dumb: it orchestrates chrome & actions but does not render
 *   the main route content. AppShell/Routes will sit between header/footer.
 * - No external CSS-in-JS; we rely on our global tokens and utility classes.
 */

import React, { useEffect, useId, useMemo, useRef, useState } from "react";
import {
  useSettingsStore,
  selectTheme,
  selectView,
  selectShowStats,
  selectHotkeysEnabled,
  selectVizPreset,
  selectHdrEnabled,
  selectDimmerEnabled,
  selectDimmerStrength,
} from "@/lib/state/useSettingsStore";
import { setTheme, setView, setShowStats } from "@/lib/state/useSettingsStore";
import type { ThemeMode, AppView } from "@/lib/state/useSettingsStore";
import { Icon } from "@/lib/utils/IconRegistry";

/* ----------------------------------------------------------------------------
 * FocusRing utilities
 * - :focus-visible covers most modern browsers. We add a tiny "modality" helper
 *   to annotate the <html> element with data-modality="keyboard" | "pointer"
 *   so we can gate any future component behaviors (e.g., show focus only if kbd).
 * ------------------------------------------------------------------------- */

function useFocusModality() {
  useEffect(() => {
    const root = document.documentElement;

    const toKeyboard = (e: KeyboardEvent) => {
      // Only consider real navigation keys (Tab/Arrows) to avoid toggling when typing.
      const navKeys = new Set(["Tab", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
      if (!navKeys.has(e.key)) return;
      root.setAttribute("data-modality", "keyboard");
    };

    const toPointer = () => {
      root.setAttribute("data-modality", "pointer");
    };

    // Initialize
    root.setAttribute("data-modality", "pointer");

    window.addEventListener("keydown", toKeyboard, { passive: true });
    window.addEventListener("mousedown", toPointer, { passive: true });
    window.addEventListener("pointerdown", toPointer, { passive: true });
    window.addEventListener("touchstart", toPointer, { passive: true });

    return () => {
      window.removeEventListener("keydown", toKeyboard);
      window.removeEventListener("mousedown", toPointer);
      window.removeEventListener("pointerdown", toPointer);
      window.removeEventListener("touchstart", toPointer);
    };
  }, []);
}

/* ----------------------------------------------------------------------------
 * A11y: Skip link for keyboard users to jump over repeated chrome.
 * - Appears on focus, otherwise visually hidden.
 * ------------------------------------------------------------------------- */

const SkipLink: React.FC<{ targetId?: string }> = ({ targetId = "main-content" }) => {
  return (
    <a
      href={`#${targetId}`}
      className="sr-only"
      onFocus={(e) => {
        // Reveal while focused (CSS-only alternative is fine; here’s a tiny JS nudge)
        (e.currentTarget as HTMLAnchorElement).style.position = "static";
      }}
      onBlur={(e) => {
        (e.currentTarget as HTMLAnchorElement).style.position = "";
      }}
    >
      Skip to main content
    </a>
  );
};

/* ----------------------------------------------------------------------------
 * DevToggle
 * - Button to toggle perf stats overlay (wired to useSettingsStore.showStats).
 * - Announces state to screen readers via aria-pressed and tooltip text.
 * ------------------------------------------------------------------------- */

const DevToggle: React.FC = () => {
  const showStats = useSettingsStore(selectShowStats);
  const buttonId = useId();

  return (
    <button
      id={buttonId}
      type="button"
      className="eh-btn eh-iconbtn"
      aria-pressed={showStats}
      aria-label={showStats ? "Hide performance overlay" : "Show performance overlay"}
      onClick={() => setShowStats(!showStats)}
      title={showStats ? "Hide FPS (Alt+S)" : "Show FPS (Alt+S)"}
    >
      {/* Icon name should exist in IconRegistry; "bar-chart" is a common alias */}
      <Icon name="bar-chart" aria-hidden="true" />
    </button>
  );
};

/* ----------------------------------------------------------------------------
 * ThemeToggle
 * - Cycles between "dark" and "system" (we only ship dark/system in V1).
 * - Instant DOM theme class reflection handled by store side-effects.
 * ------------------------------------------------------------------------- */

const ThemeToggle: React.FC = () => {
  const theme = useSettingsStore(selectTheme);
  const isDark = theme === "dark";
  const next: ThemeMode = isDark ? "system" : "dark";

  return (
    <button
      type="button"
      className="eh-btn eh-iconbtn"
      aria-pressed={isDark}
      aria-label={isDark ? "Switch to system theme" : "Switch to dark theme"}
      onClick={() => setTheme(next)}
      title={isDark ? "System theme" : "Dark theme"}
    >
      {/* Common names: moon (dark), desktop (system) */}
      <Icon name={isDark ? "moon" : "desktop"} aria-hidden="true" />
    </button>
  );
};

/* ----------------------------------------------------------------------------
 * HotkeysToggle
 * - Toggle global keyboard shortcuts on/off (for users who prefer none).
 * ------------------------------------------------------------------------- */

const HotkeysToggle: React.FC = () => {
  const hotkeysEnabled = useSettingsStore(selectHotkeysEnabled);
  const setHotkeysEnabled = useSettingsStore((s) => s.setHotkeysEnabled);

  return (
    <button
      type="button"
      className="eh-btn eh-iconbtn"
      aria-pressed={hotkeysEnabled}
      aria-label={hotkeysEnabled ? "Disable keyboard shortcuts" : "Enable keyboard shortcuts"}
      onClick={() => setHotkeysEnabled(!hotkeysEnabled)}
      title={hotkeysEnabled ? "Hotkeys on (toggle)" : "Hotkeys off (toggle)"}
    >
      <Icon name="keyboard" aria-hidden="true" />
    </button>
  );
};

/* ----------------------------------------------------------------------------
 * ViewSwitch
 * - Quickly jump between primary views (player, settings).
 * - Uses store-driven router (no external routing library in V1).
 * ------------------------------------------------------------------------- */

const ViewSwitch: React.FC = () => {
  const view = useSettingsStore(selectView);
  const goPlayer = () => setView("player");
  const goSettings = () => setView("settings");

  return (
    <div className="eh-hstack" role="group" aria-label="Primary views">
      <button
        type="button"
        className="eh-btn eh-iconbtn"
        aria-pressed={view === "player"}
        aria-label="Go to Player"
        title="Player"
        onClick={goPlayer}
      >
        <Icon name="home" aria-hidden="true" />
      </button>

      <button
        type="button"
        className="eh-btn eh-iconbtn"
        aria-pressed={view === "settings"}
        aria-label="Go to Settings"
        title="Settings"
        onClick={goSettings}
      >
        <Icon name="settings" aria-hidden="true" />
      </button>
    </div>
  );
};

/* ----------------------------------------------------------------------------
 * Header
 * - Brand area + quick actions aligned right.
 * - Uses glass surface; height is governed by --eh-topbar-h.
 * ------------------------------------------------------------------------- */

const HeaderChrome: React.FC = () => {
  return (
    <header
      className="eh-glass"
      role="banner"
      style={{
        // Keep inline styles minimal; we rely on tokens for most styling.
        height: "var(--eh-topbar-h)",
        display: "grid",
        gridTemplateColumns: "1fr auto",
        alignItems: "center",
        paddingInline: "var(--eh-gap-lg)",
        gap: "var(--eh-gap-lg)",
      }}
    >
      <div className="eh-hstack" aria-label="Brand">
        {/* Brand indicator dot (Radiant Aqua) + Title */}
        <span
          aria-hidden="true"
          style={{
            width: 10,
            height: 10,
            borderRadius: 999,
            background: "var(--eh-highlight)",
            boxShadow: "0 0 16px rgba(0,240,255,0.5)",
          }}
        />
        <h1 className="eh-title" style={{ fontSize: "var(--eh-fs-lg)", margin: 0 }}>
          Ethereal Harmony
        </h1>
      </div>

      {/* Quick actions: view switch, dev toggle, hotkeys, theme */}
      <nav aria-label="Quick actions">
        <div className="eh-hstack">
          <ViewSwitch />
          <DevToggle />
          <HotkeysToggle />
          <ThemeToggle />
        </div>
      </nav>
    </header>
  );
};

/* ----------------------------------------------------------------------------
 * Footer
 * - Subtle status bar: current viz preset and visual flags (HDR/Dimmer).
 * - Keep compact to avoid stealing vertical real estate.
 * ------------------------------------------------------------------------- */

const FooterChrome: React.FC = () => {
  const preset = useSettingsStore(selectVizPreset);
  const hdr = useSettingsStore(selectHdrEnabled);
  const dimmer = useSettingsStore(selectDimmerEnabled);
  const dimmerStrength = useSettingsStore(selectDimmerStrength);

  const status = useMemo(() => {
    const bits: string[] = [`Preset: ${preset}`];
    if (hdr) bits.push("HDR");
    if (dimmer) bits.push(`Dimmer ${Math.round(dimmerStrength * 100)}%`);
    return bits.join(" • ");
  }, [preset, hdr, dimmer, dimmerStrength]);

  return (
    <footer
      className="eh-glass"
      role="contentinfo"
      style={{
        minHeight: 40,
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        gap: "var(--eh-gap-md)",
        padding: "6px var(--eh-gap-lg)",
        marginTop: "var(--eh-gap-lg)",
      }}
    >
      <div
        aria-live="polite"
        aria-atomic="true"
        style={{ fontSize: "var(--eh-fs-sm)", color: "var(--eh-text-muted)" }}
      >
        {status}
      </div>

      {/* Room for small right-aligned affordances (e.g., help/about) */}
      <div className="eh-hstack" aria-label="Footer actions">
        <a href="https://example.com/docs" target="_blank" rel="noreferrer" title="Docs">
          <span className="sr-only">Open documentation</span>
          <Icon name="book-open" aria-hidden="true" />
        </a>
      </div>
    </footer>
  );
};

/* ----------------------------------------------------------------------------
 * AppChrome (default export)
 * - Renders SkipLink + HeaderChrome + slot for children + FooterChrome.
 * - Applies focus modality helpers for a11y polish.
 * ------------------------------------------------------------------------- */

export interface AppChromeProps {
  /** The main application content; ensure it renders an element with id="main-content". */
  children?: React.ReactNode;
  /** Optionally override the main landmark id used by the skip link. */
  mainId?: string;
  /** Optional className for the wrapper (useful when composing in AppShell). */
  className?: string;
}

const AppChrome: React.FC<AppChromeProps> = ({ children, mainId = "main-content", className }) => {
  useFocusModality();

  // Ensure the main content has a landmark and an id for skip link.
  const mainRef = useRef<HTMLElement | null>(null);

  useEffect(() => {
    const el = mainRef.current;
    if (!el) return;
    // Ensure role="main" is present for a11y tools (SSR-safe).
    if (!el.getAttribute("role")) el.setAttribute("role", "main");
    // Ensure id matches skip link target
    if (el.id !== mainId) el.id = mainId;
  }, [mainId]);

  return (
    <div
      className={className}
      style={{
        minHeight: "100%",
        display: "grid",
        gridTemplateRows: "var(--eh-topbar-h) 1fr auto",
        gap: "var(--eh-gap-lg)",
      }}
    >
      {/* Skip to content link for keyboard users (appears on focus). */}
      <SkipLink targetId={mainId} />

      {/* Header chrome */}
      <HeaderChrome />

      {/* Main application content slot.
          - The parent (AppShell) should render routes inside this slot,
            or you can directly pass children when composing locally. */}
      <section ref={mainRef as any} />

      {/* Render children into the main slot if provided. */}
      {children}

      {/* Footer chrome */}
      <FooterChrome />
    </div>
  );
};

export default AppChrome;
</file>

<file path="src/components/layout/AppShell.tsx">
// src/components/layout/AppShell.tsx
/**
 * AppShell
 * -----------------------------------------------------------------------------
 * The structural container for the entire Ethereal Harmony SPA.
 *
 * Responsibilities
 * - Provides a consistent, persistent layout scaffold:
 *     • Full-viewport WebGL canvas (non-interactive) behind all UI
 *     • Top bar (header) + left navigation rail (SidePanel)
 *     • Main content area where views/cards render
 * - Hosts global, app-scoped utilities that should be mounted once:
 *     • GlobalHotkeys: keyboard shortcuts (Space/Left/Right, etc.)
 *     • MediaKeyBridge: hardware media keys (play/pause/prev/next)
 *     • PerfOverlayMount: dev performance overlay (FPS), wired to settings
 *
 * A11y & UX
 * - Keeps the WebGL canvas non-interactive via pointer-events: none so it never
 *   steals focus or pointer events from the UI overlay.
 * - Applies ARIA landmarks and ids so skip links can target #main-content.
 * - Uses our glass tokens and layout variables to keep a cohesive aesthetic.
 *
 * Performance
 * - The canvas sits in a fixed layer (z-index 0) to avoid layout thrash.
 * - Foreground UI in a separate stacking context (z-index 1) to keep GPU
 *   compositing predictable.
 *
 * Scope
 * - Pure layout/composition; does not manage business logic or routes beyond
 *   providing a slot for content. View switching is store-driven (Phase 1/2).
 */

import React from "react";

// Core chrome
import TopBar from "@/components/layout/TopBar";
import SidePanel from "@/components/layout/SidePanel";

// Player surface (main content example — additional views render here)
import PlayerCard from "@/components/player/PlayerCard";

// Global utilities (mounted once)
import GlobalHotkeys from "@/components/shortcuts/GlobalHotkeys";
import MediaKeyBridge from "@/components/player/MediaKeyBridge";
import PerfOverlayMount from "@/components/diagnostics/PerfOverlayMount";

// Visualizer (Three.js) — SceneCanvas is our WebGL renderer wrapper
import SceneCanvas from "@/components/visualizer/SceneCanvas";

// Settings rail (compact) — hosts preset/HDR/Dimmer controls
import SettingsPanel from "@/components/settings/SettingsPanel";

/**
 * Inline, token-driven styles for the top-level shell. We keep these minimal to
 * avoid a bespoke stylesheet while still meeting our layout requirements.
 * (globals.css already defines most tokens/utilities we need.)
 */
const styles = {
  root: {
    minHeight: "100vh",
    background: "var(--eh-bg)",
    color: "var(--eh-text)",
  } as React.CSSProperties,

  // Fixed background canvas layer
  canvasLayer: {
    position: "fixed" as const,
    inset: 0,
    zIndex: 0, // behind everything
    pointerEvents: "none" as const, // decorative only
  },

  // Foreground overlay (all interactive UI)
  uiLayer: {
    position: "relative" as const,
    zIndex: 1, // above canvas
    display: "grid",
    gridTemplateRows: "var(--eh-topbar-h) 1fr", // header + content
    minHeight: "100vh",
  },

  // 2-column content grid: side rail + main
  contentGrid: {
    display: "grid",
    gridTemplateColumns: "var(--eh-sidepanel-w) 1fr",
    minHeight: "calc(100vh - var(--eh-topbar-h))",
    gap: "var(--eh-component-gap)",
    padding: "var(--eh-component-gap)",
  } as React.CSSProperties,

  aside: {
    paddingBlock: 0,
  },

  main: {
    position: "relative" as const,
    display: "grid",
    gridTemplateRows: "auto 1fr", // controls rail + main content
    gap: "var(--eh-controls-gap)",
    outline: "none",
  } as React.CSSProperties,

  // Compact controls rail that uses our glass tokens
  controls: {
    // .eh-glass + .eh-controls-grid in CSS; we replicate minimal spacing here
    padding: "var(--eh-gap-md)",
    marginBottom: "var(--eh-controls-gap)",
  },
};

const AppShell: React.FC = () => {
  return (
    <div style={styles.root}>
      {/* ----------------------------------------------------------------------
          Global once-per-app utilities
          - Keyboard shortcuts: Space/Arrows/… (reads useSettingsStore)
          - Hardware media keys: MediaSession bridge
          - Perf overlay mount: listens to settings flag / DOM event
         ------------------------------------------------------------------- */}
      <GlobalHotkeys />
      <MediaKeyBridge />
      <PerfOverlayMount />

      {/* ----------------------------------------------------------------------
          1) FIXED BACKGROUND LAYER — WebGL (visualizer)
          - Completely non-interactive; does not affect layout or hit-testing.
         ------------------------------------------------------------------- */}
      <div style={styles.canvasLayer} aria-hidden="true">
        <SceneCanvas />
      </div>

      {/* ----------------------------------------------------------------------
          2) FOREGROUND UI OVERLAY — header + content grid
         ------------------------------------------------------------------- */}
      <div style={styles.uiLayer}>
        {/* Header / Top bar (role="banner" is inside TopBar) */}
        <TopBar />

        {/* Content grid: left navigation + main content */}
        <div style={styles.contentGrid}>
          {/* Left navigation / app rail */}
          <aside aria-label="Primary navigation" style={styles.aside}>
            <SidePanel />
          </aside>

          {/* Main column / route host */}
          <main id="main-content" role="main" style={styles.main} tabIndex={-1}>
            {/* Controls rail — compact glass panel with preset/HDR/Dimmer */}
            <section
              className="eh-glass eh-controls-grid"
              style={styles.controls}
              role="toolbar"
              aria-label="Visualizer settings"
            >
              {/* SettingsPanel internally renders the Preset selector, HDR and Dimmer toggles;
                  it is fully keyboard-accessible and uses ARIA semantics. */}
              <SettingsPanel />
            </section>

            {/* Primary view content (Phase 2 shows PlayerCard). Other views will
               mount here based on our store-driven router. */}
            <section aria-label="Player area">
              <PlayerCard />
            </section>
          </main>
        </div>
      </div>
    </div>
  );
};

// Export both named and default for flexible imports
export { AppShell };
export default AppShell;
</file>

<file path="src/components/layout/SearchBar.module.css">
/* Ethereal Harmony — SearchBar
   Glassmorphism + responsive behaviors
   Tokens expected (from :root or tokens.css):
   --eh-bg, --eh-accent, --eh-highlight, --eh-radius, --eh-blur
*/

.searchShell {
  --h: 40px;
  --padX: 12px;
  display: inline-flex;
  align-items: center;
  height: var(--h);
  border-radius: var(--eh-radius, 16px);
  backdrop-filter: blur(var(--eh-blur, 16px));
  background: rgba(255,255,255,0.15);
  border: 1px solid rgba(255,255,255,0.3);
  transition: width 180ms ease, box-shadow 180ms ease, background 180ms ease;
  box-shadow: 0 2px 12px rgba(0,0,0,0.25);
  position: relative;
  width: 240px; /* default compact; overridden by .expanded */
}

.compact {
  width: 240px;
}

.expanded {
  width: 400px; /* expands on focus or when typing */
}

.leadingIcon {
  display: inline-grid;
  place-items: center;
  width: 36px;
  margin-left: 6px;
  opacity: 0.9;
}

.input {
  flex: 1 1 auto;
  height: 100%;
  border: none;
  outline: none;
  background: transparent;
  color: #fff;
  font-family: Lato, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  font-size: 14px;
  padding: 0 var(--padX);
  min-width: 0;
}

.input::placeholder {
  color: rgba(255,255,255,0.72);
}

.trailing {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding-right: 8px;
}

.clearBtn,
.submitBtn,
.trailingBtn,
.iconBtn,
.closeBtn {
  display: inline-grid;
  place-items: center;
  width: 32px;
  height: 32px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(255,255,255,0.12);
  backdrop-filter: blur(var(--eh-blur, 16px));
  border-radius: 12px;
  cursor: pointer;
  color: #fff;
}

.clearBtn[disabled] {
  opacity: 0.4;
  cursor: default;
}

.kbd {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(255,255,255,0.08);
  opacity: 0.9;
}

/* Small-screen icon entry */
.iconBtn {
  width: 40px;
  height: 40px;
  border-radius: 16px;
  padding: 0;
}

/* Modal styles */
.modalBackdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.55);
  z-index: 70;
}

.modal {
  position: fixed;
  inset: 0;
  margin: auto;
  width: min(680px, calc(100vw - 24px));
  height: auto;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(26, 43, 69, 0.72);
  backdrop-filter: blur(16px);
  border-radius: 16px;
  padding: 16px 16px 12px;
  z-index: 80;
}

.form {
  display: grid;
  grid-template-columns: 36px 1fr auto auto;
  gap: 8px;
  align-items: center;
  height: 48px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(255,255,255,0.12);
  backdrop-filter: blur(16px);
  padding: 0 8px;
}

.helpRow {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  margin-top: 12px;
  color: rgba(255,255,255,0.8);
  font-size: 13px;
}

.closeBtn {
  position: absolute;
  top: 10px;
  right: 10px;
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  .searchShell {
    transition: none;
  }
}

/* Ensure width never breaks TopBar layout */
@media (max-width: 1200px) {
  .expanded { width: 440px; }
}
@media (max-width: 1024px) {
  .expanded { width: 380px; }
}
@media (max-width: 900px) {
  .expanded { width: 340px; }
}
</file>

<file path="src/components/layout/SearchBar.tsx">
import React from "react";
import { AnimatePresence, motion } from "framer-motion";
import styles from "./SearchBar.module.css";
import { Icon } from "@/lib/utils/IconRegistry";

/**
 * SearchBar
 * - Default: compact width, expands on focus/typing
 * - <= sm screens: icon-only button; opens modal overlay
 * - Keyboard: Ctrl/Cmd+K to focus/open
 * - A11y: proper labeling, roles, aria-expanded on container
 */
type SearchBarProps = {
  placeholder?: string;
  onSubmit?: (value: string) => void;
  className?: string;
  /** If you already have a global store modal, pass controlled props; otherwise this self-manages */
  useModalOnSmall?: boolean;
};

export const SearchBar: React.FC<SearchBarProps> = ({
  placeholder = "Search library…",
  onSubmit,
  className,
  useModalOnSmall = true,
}) => {
  const inputRef = React.useRef<HTMLInputElement>(null);
  const [value, setValue] = React.useState("");
  const [isFocused, setIsFocused] = React.useState(false);
  const [isSmall, setIsSmall] = React.useState(false);
  const [modalOpen, setModalOpen] = React.useState(false);

  // Responsive breakpoint (match our small layout)
  React.useEffect(() => {
    const mql = window.matchMedia("(max-width: 768px)");
    const handle = (e: MediaQueryListEvent | MediaQueryList) =>
      setIsSmall("matches" in e ? e.matches : (e as MediaQueryList).matches);
    handle(mql);
    mql.addEventListener?.("change", handle as any);
    return () => mql.removeEventListener?.("change", handle as any);
  }, []);

  // Ctrl/Cmd+K opens/focuses search
  React.useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      const meta = e.ctrlKey || e.metaKey;
      if (meta && (e.key.toLowerCase() === "k")) {
        e.preventDefault();
        if (useModalOnSmall && isSmall) {
          setModalOpen(true);
          return;
        }
        inputRef.current?.focus();
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [isSmall, useModalOnSmall]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSubmit?.(value.trim());
  };

  // Small-screen entry point: icon that triggers modal
  if (useModalOnSmall && isSmall) {
    return (
      <>
        <button
          type="button"
          className={`${styles.iconBtn} eh-glass`}
          aria-label="Open search"
          aria-haspopup="dialog"
          aria-expanded={modalOpen}
          onClick={() => setModalOpen(true)}
        >
          <Icon name="search" aria-hidden="true" />
          <kbd className={styles.kbd}>⌘K</kbd>
        </button>

        <AnimatePresence>
          {modalOpen && (
            <motion.div
              className={styles.modalBackdrop}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              aria-hidden="true"
            />
          )}
        </AnimatePresence>

        <AnimatePresence>
          {modalOpen && (
            <motion.dialog
              role="dialog"
              aria-modal="true"
              aria-label="Search"
              className={`${styles.modal} eh-glass glass-surface`}
              initial={{ opacity: 0, scale: 0.96 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.98 }}
              onClose={() => setModalOpen(false)}
              open
            >
              <form className={styles.form} onSubmit={handleSubmit}>
                <span className={styles.leadingIcon} aria-hidden="true">
                  <Icon name="search" />
                </span>

                <input
                  ref={inputRef}
                  type="search"
                  className={styles.input}
                  placeholder={placeholder}
                  value={value}
                  onChange={(e) => setValue(e.target.value)}
                  autoFocus
                  aria-label="Search library"
                />

                <button
                  type="button"
                  className={styles.trailingBtn}
                  onClick={() => {
                    setValue("");
                    inputRef.current?.focus();
                  }}
                  aria-label="Clear search"
                >
                  <Icon name="x" aria-hidden="true" />
                </button>

                <button type="submit" className={styles.submitBtn} aria-label="Run search">
                  <Icon name="enter" aria-hidden="true" />
                </button>
              </form>

              <div className={styles.helpRow}>
                <span><kbd>↑↓</kbd> navigate</span>
                <span><kbd>Enter</kbd> open</span>
                <span><kbd>Esc</kbd> close</span>
              </div>

              <button
                type="button"
                className={styles.closeBtn}
                onClick={() => setModalOpen(false)}
                aria-label="Close search"
              >
                <Icon name="x" aria-hidden="true" />
              </button>
            </motion.dialog>
          )}
        </AnimatePresence>
      </>
    );
  }

  // Desktop / large layout: compact → expands on focus or when typing
  const expanded = isFocused || value.length > 0;

  return (
    <form
      role="search"
      aria-label="Search library"
      className={[
        styles.searchShell,
        "eh-glass glass-surface",
        expanded ? styles.expanded : styles.compact,
        className ?? "",
      ].join(" ")}
      data-state={expanded ? "expanded" : "compact"}
      onSubmit={handleSubmit}
      onFocus={() => setIsFocused(true)}
      onBlur={(e) => {
        // collapse only if focus leaves the whole shell
        if (!e.currentTarget.contains(e.relatedTarget as Node)) {
          setIsFocused(false);
        }
      }}
    >
      <span className={styles.leadingIcon} aria-hidden="true">
        <Icon name="search" />
      </span>

      <input
        ref={inputRef}
        type="search"
        className={styles.input}
        placeholder={placeholder}
        value={value}
        onChange={(e) => setValue(e.target.value)}
        aria-label="Search library"
      />

      <div className={styles.trailing}>
        <button
          type="button"
          className={styles.clearBtn}
          onClick={() => {
            setValue("");
            inputRef.current?.focus();
          }}
          aria-label="Clear search"
          aria-disabled={value.length === 0}
          disabled={value.length === 0}
        >
          <Icon name="x" aria-hidden="true" />
        </button>
        <kbd className={styles.kbd}>⌘K</kbd>
      </div>
    </form>
  );
};

export default SearchBar;
</file>

<file path="src/components/layout/SidePanel.tsx">
/**
 * SidePanel.tsx
 * Primary navigation drawer (Library, Playlists, Discovery).
 * - Opens/closes via global toggle (TopBar) and a local header chevron.
 * - Auto-opens on desktop (≥1024px) on first mount so it's “out” by default.
 * - Includes compact SearchBar in header.
 *
 * A11y:
 * - <aside> with aria-label for landmark nav.
 * - aria-expanded/aria-controls on the toggle.
 * - aria-hidden mirrors visibility for SRs.
 */

import React, { useState } from "react";
import { useUIStore } from "@/lib/state/useUIStore";
import { Icon } from "@/lib/utils/IconRegistry";
import SearchBar from "@/components/layout/SearchBar";

export const SidePanel: React.FC = () => {
  const isOpen = useUIStore((s) => s.sidePanelOpen);
  const toggleSidePanel = useUIStore((s) => s.toggleSidePanel);
  const [isCollapsed, setIsCollapsed] = useState(false);

  const handleToggle = () => {
    toggleSidePanel();
  };

  const toggleCollapse = () => {
    setIsCollapsed(!isCollapsed);
  };

  // Add the missing handleSearch function
  const handleSearch = (q: string) => {
    // TODO: integrate with library filter action when that store lands
    console.log('Search query:', q);
  };

  // Ensure panel is "out" on desktop by default (first mount only).
  React.useEffect(() => {
    const mql = window.matchMedia("(min-width: 1024px)");
    const state: any = useUIStore.getState();
    // Only auto-open if currently closed and no explicit user action recorded.
    // If a setter exists we use it; otherwise hard set.
    if (mql.matches && state.sidePanelOpen === false) {
      if (typeof state.setSidePanelOpen === "function") {
        state.setSidePanelOpen(true);
      } else {
        useUIStore.setState({ sidePanelOpen: true });
      }
    }
  }, []);

  // Close with Escape key for convenience; Ctrl/Cmd+B toggles
  React.useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      const metaB = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "b";
      if (metaB) {
        e.preventDefault();
        handleToggle();
      } else if (e.key === "Escape" && isOpen) {
        e.preventDefault();
        toggleSidePanel(); // Use existing toggleSidePanel instead of undefined setSidePanelOpen
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [handleToggle, isOpen, toggleSidePanel]); // Add toggleSidePanel to dependencies

  const panelId = "eh-sidepanel";

  if (isCollapsed) {
    return (
      <div className="sidepanel-collapsed">
        <button
          type="button"
          className="collapse-toggle"
          onClick={toggleCollapse}
          aria-label="Expand sidepanel"
          style={{
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="chevronRight" aria-hidden="true" />
        </button>
      </div>
    );
  }

  return (
    <aside
      id={panelId}
      className="sidepanel eh-glass glass-surface"
      data-open={isOpen ? "true" : "false"}
      data-state={isOpen ? "open" : "closed"}
      aria-label="Primary navigation"
      aria-hidden={!isOpen ? "true" : "false"}
    >
      {/* Header: just the Navigation label centered */}
      <div className="sidepanel__header">
        <div className="sidepanel__brand">
          <span className="sidepanel__label">Navigation</span>
        </div>
        {/* Hide/return icons in the header field */}
        <button
          type="button"
          className="icon-btn sidepanel__toggle"
          aria-label="Hide sidepanel"
          onClick={toggleCollapse}
          style={{
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="chevronLeft" aria-hidden="true" />
        </button>
      </div>

      {/* Primary nav with integrated search */}
      <nav className="sidepanel__nav">
        <div className="sidepanel__search" role="search" aria-label="Library search">
          <SearchBar onSearch={handleSearch} />
        </div>
        
        <ul className="navlist" role="list">
          <li>
            <a className="navitem" href="#library">
              <span className="navitem__icon" aria-hidden="true">
                <Icon name="library" aria-hidden="true" />
              </span>
              <span className="navitem__label">Library</span>
            </a>
          </li>
          <li>
            <a className="navitem" href="#playlists">
              <span className="navitem__icon" aria-hidden="true">
                <Icon name="playlists" aria-hidden="true" />
              </span>
              <span className="navitem__label">Playlists</span>
            </a>
          </li>
          <li>
            <a className="navitem" href="#discovery">
              <span className="navitem__icon" aria-hidden="true">
                <Icon name="discovery" aria-hidden="true" />
              </span>
              <span className="navitem__label">Discovery</span>
            </a>
          </li>
        </ul>
      </nav>
    </aside>
  );
};

export default SidePanel;
</file>

<file path="src/components/layout/TopBar.tsx">
/**
 * TopBar.tsx
 * Global header: brand slot (logomark + neutral silhouette), Search (center),
 * and Settings (right). Contains the single global toggle for the SidePanel.
 */

import React, { useState } from "react";
import { useUIStore } from "@/lib/state/useUIStore";
import Icon from "@/lib/utils/IconRegistry";
import SearchBar from "@/components/layout/SearchBar";

export const TopBar: React.FC = () => {
  const isOpen = useUIStore((s) => s.sidePanelOpen);
  const toggleSidePanel = useUIStore((s) => s.toggleSidePanel);
  const [isCollapsed, setIsCollapsed] = useState(false);

  // Optional: wire to library filtering when that store lands.
  const handleSearch = (q: string) => {
    // TODO: integrate with library filter action (e.g., useLibraryStore.getState().setQuery(q))
    // For now, this is a no-op to keep TopBar decoupled.
  };

  const toggleCollapse = () => {
    setIsCollapsed(!isCollapsed);
  };

  if (isCollapsed) {
    return (
      <div className="topbar-collapsed">
        <button
          type="button"
          className="collapse-toggle"
          onClick={toggleCollapse}
          aria-label="Expand topbar"
          style={{
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="chevronDown" aria-hidden="true" />
        </button>
      </div>
    );
  }

  return (
    <header className="topbar eh-glass glass-surface" role="banner">
      {/* Left cluster: global SidePanel toggle + LED indicator */}
      <div className="topbar__left">
        <button
          type="button"
          className="icon-btn"
          aria-label="Toggle navigation"
          aria-expanded={isOpen ? "true" : "false"}
          aria-controls="eh-sidepanel"
          onClick={toggleSidePanel}
          style={{
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="menu" aria-hidden="true" />
        </button>
        
        {/* LED Light Indicator */}
        <div className="led-indicator" style={{
          width: "12px",
          height: "12px",
          borderRadius: "50%",
          background: "var(--eh-aqua)",
          boxShadow: "0 0 10px var(--eh-aqua), 0 0 20px rgba(0,240,255,.6)",
          marginLeft: "8px",
          animation: "pulse 2s ease-in-out infinite alternate"
        }} />
        
        {/* Application Title */}
        <div className="topbar__title">
          <h1 style={{
            fontSize: "18px",
            fontWeight: 700,
            color: "var(--eh-text)",
            margin: 0,
            letterSpacing: "0.5px"
          }}>
            ETHEREAL PLAYER
          </h1>
        </div>
        
        {/* Menu Items */}
        <div className="topbar__menu">
          <span className="menu-item">File</span>
          <span className="menu-item">Edit</span>
          <span className="menu-item">View</span>
          <span className="menu-item">Analyze</span>
          <span className="menu-item">Tools</span>
          <span className="menu-item">Help</span>
        </div>
      </div>

      {/* Center cluster: Empty space for balance */}
      <div className="topbar__center" />

      {/* Right cluster: Search + User Avatar + Settings + Collapse Button */}
      <div className="topbar__right">
        {/* Search moved to right side */}
        <div className="topbar__search" role="search" aria-label="Library search">
          <SearchBar onSearch={handleSearch} />
        </div>
        
        {/* User Avatar - Enhanced glassmorphism */}
        <div className="topbar__user" aria-hidden="true">
          <div className="user-avatar" style={{
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}>
            <Icon name="user" size={20} aria-hidden="true" />
          </div>
        </div>
        
        {/* Settings Icon - Enhanced glassmorphism */}
        <button
          type="button"
          className="icon-btn topbar__settings"
          aria-label="Settings"
          style={{
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="settings" aria-hidden="true" />
        </button>

        {/* Collapse Button */}
        <button
          type="button"
          className="icon-btn collapse-toggle"
          onClick={toggleCollapse}
          aria-label="Collapse topbar"
          style={{
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="chevronUp" aria-hidden="true" />
        </button>
      </div>
    </header>
  );
};

export default TopBar;
</file>

<file path="src/components/player/AlbumArt.css">
.eh-album-art {
  display: grid;
  place-items: center;
  overflow: hidden;
  border-radius: 8px;
}

.eh-album-art img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.eh-album-art__placeholder {
  color: var(--eh-text-muted);
  font-size: 24px;
  line-height: 1;
}
</file>

<file path="src/components/player/AlbumArt.tsx">
// src/components/player/AlbumArt.tsx
/**
 * AlbumArt
 * -----------------------------------------------------------------------------
 * Glass-bordered square artwork with robust fallback.
 * - Lazy-loads image and shows a placeholder on error or when src is missing.
 * - Size is a square in pixels; defaults to 96.
 * - Keeps aspect cover, rounded corners (16px), and non-distorting layout.
 */

import React, { useMemo, useState } from "react";
import "./AlbumArt.css";

export interface AlbumArtProps {
  src?: string;
  alt?: string;
  size?: number; // square px size
  /** Optional test hook */
  "data-testid"?: string;
}

const AlbumArt: React.FC<AlbumArtProps> = ({ src, alt, size = 96, "data-testid": testId }) => {
  const [failed, setFailed] = useState(false);

  // Decide whether to show the image or the placeholder
  const showImage = useMemo(() => Boolean(src && !failed), [src, failed]);

  // Safe alt text for the <img>; container still has an aria-label for context
  const imgAlt = alt && alt.trim().length > 0 ? alt : "Album artwork";

  return (
    <div
      className="eh-album-art eh-glass"
      style={{
        width: size,
        height: size,
        borderRadius: 16,
        overflow: "hidden",
        display: "grid",
        placeItems: "center",
      }}
      aria-label="Album artwork"
      data-testid={testId ?? "album-art"}
    >
      {showImage ? (
        <img
          className="eh-album-art__img"
          src={src}
          alt={imgAlt}
          loading="lazy"
          decoding="async"
          onError={() => setFailed(true)}
          style={{
            width: "100%",
            height: "100%",
            objectFit: "cover",
            display: "block",
          }}
        />
      ) : (
        <div
          className="eh-album-art__placeholder"
          aria-hidden="true"
          style={{
            fontSize: Math.max(16, Math.floor(size * 0.4)),
            lineHeight: 1,
            userSelect: "none",
            opacity: 0.85,
          }}
        >
          ♪
        </div>
      )}
    </div>
  );
};

export default AlbumArt;
</file>

<file path="src/components/player/LocalFileLoader.tsx">
import { usePlayerStore } from '@/lib/state/usePlayerStore'

export const LocalFileLoader = () => {
  const { load, play } = usePlayerStore()

  const handleChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {
    const file = e.target.files?.[0]
    if (!file) return
    const url = URL.createObjectURL(file)
    load(url)
    play()
  }

  return (
    <label className="eh-glass" style={{ padding: '8px 12px', cursor: 'pointer', display: 'inline-block' }}>
      <span aria-hidden="true">📂</span> <span>Open audio file</span>
      <input
        type="file"
        accept="audio/*"
        onChange={handleChange}
        style={{ display: 'none' }}
        aria-label="Open local audio file"
      />
    </label>
  )
}
</file>

<file path="src/components/player/MediaKeyBridge.tsx">
// src/components/player/MediaKeyBridge.tsx
/**
 * MediaKeyBridge (Phase 2)
 * -----------------------------------------------------------------------------
 * Bridges hardware/media keys to **PlaybackController** (NOT the raw engine).
 *
 * What it does
 * - Registers Media Session action handlers (play/pause/prev/next/seekto/seek±)
 *   and delegates them to the controller.
 * - Safe on SSR and in browsers without MediaSession (no-ops).
 *
 * Why this exists when PlaybackController also updates MediaSession?
 * - The controller sets metadata and *may* register actions, but this bridge
 *   ensures a single, centralized place in the React tree to bind handlers
 *   and to re-bind them on hot reloads. Both implementations point to the same
 *   controller methods, so there’s no divergence.
 */

import React, { useEffect } from "react";
import playbackController from "@/lib/audio/PlaybackController";

const MediaKeyBridge: React.FC = () => {
  useEffect(() => {
    if (typeof navigator === "undefined" || !("mediaSession" in navigator)) return;

    const ms = navigator.mediaSession;

    // Helper to guard handler assignments across varying TS DOM lib versions
    const setHandler = (action: any, handler: any) => {
      try {
        // @ts-expect-error - browser types vary
        ms.setActionHandler(action, handler);
      } catch {
        /* ignore */
      }
    };

    // Map actions to controller
    setHandler("play", async () => {
      await playbackController.play();
    });
    setHandler("pause", async () => {
      await playbackController.pause();
    });
    setHandler("previoustrack", async () => {
      await playbackController.prevTrack(true);
    });
    setHandler("nexttrack", async () => {
      await playbackController.nextTrack(true);
    });
    setHandler("seekto", (details: any) => {
      const pos = Number(details?.seekTime ?? 0);
      playbackController.seek(pos);
    });
    setHandler("seekforward", () => playbackController.seekBy(10));
    setHandler("seekbackward", () => playbackController.seekBy(-10));

    // Cleanup: unset handlers on unmount to avoid dangling references
    return () => {
      const clear = (action: any) => setHandler(action, null);
      clear("play");
      clear("pause");
      clear("previoustrack");
      clear("nexttrack");
      clear("seekto");
      clear("seekforward");
      clear("seekbackward");
    };
  }, []);

  // No UI; purely behavioral
  return null;
};

export default MediaKeyBridge;
</file>

<file path="src/components/player/PlaybackButtons.tsx">
import React from "react";
import { motion } from "framer-motion";
import { getIcon } from "@/lib/utils/IconRegistry";
import { usePlayerStore } from "@/lib/state/usePlayerStore";

/**
 * PlaybackButtons
 * Transport controls: Prev | Play/Pause | Next + optional Shuffle/Repeat + Mute
 *
 * A11y:
 * - role="group" with accessible label
 * - aria-pressed on toggle buttons (shuffle, repeat, mute)
 * - distinct aria-labels for each action
 *
 * Design:
 * - Glass buttons via existing utility classes (glass-btn, glass-btn--primary)
 * - 44px min tap target
 */

type ButtonProps = {
  label: string;
  pressed?: boolean;
  onClick: () => void;
  icon: ReturnType<typeof getIcon>;
  variant?: "default" | "primary";
};

const GlassIconButton: React.FC<ButtonProps> = ({
  label,
  pressed,
  onClick,
  icon: Icon,
  variant = "default",
}) => {
  return (
    <motion.button
      type="button"
      className={`glass-btn ${variant === "primary" ? "glass-btn--primary" : ""}`}
      aria-label={label}
      aria-pressed={pressed ?? undefined}
      onClick={onClick}
      whileTap={{ scale: 0.96 }}
    >
      <Icon aria-hidden width={20} height={20} />
    </motion.button>
  );
};

export const PlaybackButtons: React.FC = () => {
  // Player state and actions from the store.
  const isPlaying = usePlayerStore((s) => s.isPlaying);
  const play = usePlayerStore((s) => s.play);
  const pause = usePlayerStore((s) => s.pause);
  const next = usePlayerStore((s) => s.next);
  const prev = usePlayerStore((s) => s.prev);

  const shuffle = usePlayerStore((s) => s.shuffle);
  const setShuffle = usePlayerStore((s) => s.setShuffle);

  const repeatMode = usePlayerStore((s) => s.repeat); // "off" | "one" | "all"
  const setRepeat = usePlayerStore((s) => s.setRepeat);

  // Mute handling: either explicit isMuted or derived from volume === 0
  const isMuted = usePlayerStore((s) => s.isMuted ?? s.volume === 0);
  const toggleMute = usePlayerStore((s) => s.toggleMute ?? (() => s.setVolume(isMuted ? 0.8 : 0)));

  const handlePlayPause = () => {
    if (isPlaying) pause();
    else play();
  };

  const handleToggleShuffle = () => setShuffle(!shuffle);

  const handleCycleRepeat = () => {
    // Cycle off -> all -> one -> off (matches common native players)
    if (repeatMode === "off") setRepeat("all");
    else if (repeatMode === "all") setRepeat("one");
    else setRepeat("off");
  };

  const PlayPauseIcon = getIcon(isPlaying ? "pause" : "play");
  const MuteIcon = getIcon(isMuted ? "mute" : "volume");
  const RepeatIcon = getIcon(repeatMode === "one" ? "repeatOne" : "repeat");

  return (
    <div
      role="group"
      aria-label="Playback controls"
      className="playback-buttons"
    >
      {/* Left cluster (A / Prev) */}
      <GlassIconButton
        label="Previous track"
        onClick={prev}
        icon={getIcon("prev")}
      />

      {/* Center cluster (B: Play/Pause) */}
      <GlassIconButton
        label={isPlaying ? "Pause" : "Play"}
        onClick={handlePlayPause}
        icon={PlayPauseIcon}
        variant="primary"
      />

      {/* Right cluster (C / Next) */}
      <GlassIconButton
        label="Next track"
        onClick={next}
        icon={getIcon("next")}
      />

      {/* Spacer */}
      <span className="playback-buttons__spacer" aria-hidden />

      {/* Toggles: Shuffle / Repeat / Mute */}
      <GlassIconButton
        label="Toggle shuffle"
        onClick={handleToggleShuffle}
        icon={getIcon("shuffle")}
        pressed={shuffle}
      />

      <GlassIconButton
        label={
          repeatMode === "one"
            ? "Repeat single track"
            : repeatMode === "all"
            ? "Repeat all tracks"
            : "Repeat off"
        }
        onClick={handleCycleRepeat}
        icon={RepeatIcon}
        pressed={repeatMode !== "off"}
      />

      <GlassIconButton
        label={isMuted ? "Unmute" : "Mute"}
        onClick={toggleMute}
        icon={MuteIcon}
        pressed={isMuted}
      />
    </div>
  );
};

export default PlaybackButtons;
</file>

<file path="src/components/player/PlayerCard.css">
/* Glass player card container */
.eh-player-card {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 12px 16px;
  border-radius: var(--eh-glass-radius);
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  backdrop-filter: blur(var(--eh-glass-blur));
}

.eh-player-empty {
  color: var(--eh-text-muted);
  font-style: italic;
}
</file>

<file path="src/components/player/PlayerCard.tsx">
// src/components/player/PlayerCard.tsx
/**
 * PlayerCard (Phase 2)
 * -----------------------------------------------------------------------------
 * A glassy, accessible playback surface that talks **only** to PlaybackController.
 *
 * Responsibilities
 * - Display current track metadata (title/artist/artwork).
 * - Provide transport controls: prev / play-pause / next.
 * - Provide timeline scrubbing (seek), volume, and rate controls.
 * - Reflect live playback state from the controller’s events (no direct engine refs).
 *
 * A11y
 * - Buttons have aria-labels and pressed state where applicable.
 * - Timeline is an <input type="range"> with min/max equal to media duration.
 * - Live regions announce track/time changes to assistive tech.
 *
 * Styling
 * - Uses global glass tokens via `.eh-glass` and spacing variables.
 *
 * NOTE
 * - This component does not own queue logic; it relies on PlaybackController.
 * - Hardware media-keys are handled separately by MediaKeyBridge (also using controller).
 */

import React, { useEffect, useMemo, useRef, useState } from "react";
import playbackController from "@/lib/audio/PlaybackController";
import { Icon } from "@/lib/utils/IconRegistry";

type TrackMeta = {
  title?: string;
  artist?: string;
  album?: string;
  artworkUrl?: string;
};

const fmtTime = (s: number) => {
  if (!Number.isFinite(s) || s < 0) s = 0;
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = Math.floor(s % 60);
  const mm = String(m).padStart(2, "0");
  const ss = String(sec).padStart(2, "0");
  return h > 0 ? `${h}:${mm}:${ss}` : `${m}:${ss}`;
};

const RATE_OPTIONS = [0.5, 0.75, 1, 1.25, 1.5, 2];

const PlayerCard: React.FC = () => {
  // UI state mirrored from controller events
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const [currentTime, setCurrentTime] = useState<number>(0);
  const [duration, setDuration] = useState<number>(0);
  const [rate, setRate] = useState<number>(1);
  const [volume, setVolume] = useState<number>(1);
  const [muted, setMuted] = useState<boolean>(false);
  const [track, setTrack] = useState<TrackMeta | null>(null);
  const [playbackRate, setPlaybackRate] = useState<number>(1);

  // Scrub state (avoid fighting controller timeupdates while the user drags)
  const [isScrubbing, setIsScrubbing] = useState(false);
  const scrubValueRef = useRef<number>(0);

  // Subscribe to controller lifecycle
  useEffect(() => {
    const offPlay = playbackController.on("play", () => setIsPlaying(true));
    const offPause = playbackController.on("pause", () => setIsPlaying(false));
    const offEnded = playbackController.on("ended", () => setIsPlaying(false));
    const offTime = playbackController.on("timeupdate", (e) => {
      if (!isScrubbing) setCurrentTime(e.currentTime);
    });
    const offDur = playbackController.on("durationchange", (e) => setDuration(e.duration));
    const offRate = playbackController.on("ratechange", (e) => setRate(e.rate));
    const offVol = playbackController.on("volumechange", (e) => {
      setVolume(e.volume);
      setMuted(e.muted);
    });
    const offTrack = playbackController.on("trackchange", (e) => {
      const t = e.track ?? {};
      setTrack({
        title: t.title,
        artist: t.artist,
        album: t.album,
        artworkUrl: t.artworkUrl,
      });
      // Reset times for new track
      setCurrentTime(0);
      setDuration(0);
    });

    // Initialize from controller (covers reload/mount)
    setIsPlaying(playbackController.isPlaying);
    setCurrentTime(playbackController.currentTime);
    setDuration(playbackController.duration);
    setRate(1);
    setMuted(false);

    return () => {
      offPlay();
      offPause();
      offEnded();
      offTime();
      offDur();
      offRate();
      offVol();
      offTrack();
    };
  }, [isScrubbing]);

  // Handlers: transport
  const onToggle = async () => {
    await playbackController.toggle();
  };
  const onPrev = async () => {
    await playbackController.prevTrack(true);
  };
  const onNext = async () => {
    await playbackController.nextTrack(true);
  };

  // Handlers: seek
  const onSeekInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const v = Number(e.currentTarget.value);
    scrubValueRef.current = v;
    setIsScrubbing(true);
    setCurrentTime(v);
  };
  const commitSeek = async () => {
    const t = scrubValueRef.current;
    setIsScrubbing(false);
    playbackController.seek(t);
  };

  // Handlers: volume / mute
  const onVolume = (e: React.ChangeEvent<HTMLInputElement>) => {
    const v = Number(e.currentTarget.value);
    setVolume(v);
    playbackController.setVolume(v);
    if (v > 0 && muted) playbackController.setMuted(false);
  };
  const onMute = () => {
    const next = !muted;
    setMuted(next);
    playbackController.setMuted(next);
  };

  // Handlers: rate
  const onRate = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const r = Number(e.currentTarget.value);
    setRate(r);
    playbackController.setRate(r);
  };

  // Handler: file upload
  const handleFileUpload = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'audio/*';
    input.multiple = false;
    
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (file) {
        try {
          // Create a basic track object from the file
          const newTrack = {
            title: file.name.replace(/\.[^/.]+$/, ""), // Remove file extension
            artist: "Uploaded Track",
            album: "Local Files",
            artworkUrl: undefined
          };
          
          // Set the track and load it into the player
          setTrack(newTrack);
          
          // Load the audio file into the playback controller using the correct method
          await playbackController.loadFromFile(file, true);
          
        } catch (error) {
          console.error('Error loading audio file:', error);
          alert('Error loading audio file. Please try again.');
        }
      }
    };
    
    input.click();
  };

  const progressText = useMemo(() => {
    return `${fmtTime(currentTime)} / ${fmtTime(duration || 0)}`;
  }, [currentTime, duration]);

  return (
    <article 
      className="eh-glass" 
      aria-label="Audio player" 
      style={{ 
        padding: "20px",
        marginTop: "var(--eh-controls-gap)"
      }}
    >
      {/* Metadata row */}
      <div className="eh-hstack" style={{ justifyContent: "space-between", marginBottom: 8 }}>
        <div className="eh-hstack" style={{ gap: 12 }}>
          {/* Artwork - 50% larger with enhanced glassmorphism */}
          <div
            aria-hidden="true"
            style={{
              width: 84, // Increased from 56 (50% larger)
              height: 84, // Increased from 56 (50% larger)
              borderRadius: 8,
              overflow: "hidden",
              background: "rgba(255, 255, 255, 0.06)",
              border: "1px solid rgba(255, 255, 255, 0.25)",
              boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
              backdropFilter: "blur(12px)",
              opacity: 0.75
            }}
          >
            {track?.artworkUrl ? (
              <img src={track.artworkUrl} alt="" style={{ width: "100%", height: "100%", objectFit: "cover" }} />
            ) : (
              <div style={{ 
                width: "100%", 
                height: "100%", 
                display: "flex", 
                alignItems: "center", 
                justifyContent: "center",
                color: "rgba(255,255,255,0.3)",
                fontSize: "12px"
              }}>
                No Art
              </div>
            )}
          </div>
          
          {/* Track info - positioned further right */}
          <div className="eh-vstack" style={{ gap: 8, minWidth: 200 }}>
            <div style={{ 
              fontSize: "16px", 
              fontWeight: 600, 
              color: "var(--eh-text)",
              textAlign: "left",
              width: "100%"
            }}>
              {track?.title || "No track loaded"}
            </div>
            <div style={{ 
              fontSize: "14px", 
              color: "var(--eh-text-muted)",
              textAlign: "left",
              width: "100%"
            }}>
              {track?.artist || "Unknown Artist"}
            </div>
          </div>
        </div>
        {/* Upload button - enhanced glassmorphism with subtle shadows */}
        <button
          type="button"
          className="icon-btn"
          aria-label="Upload audio file"
          onClick={handleFileUpload}
          style={{
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="upload" aria-hidden="true" />
        </button>
      </div>

      {/* Progress bar */}
      <div style={{ marginBottom: 16, position: "relative" }}>
        <div style={{ 
          height: 4, 
          background: "rgba(255,255,255,0.1)", 
          borderRadius: 2,
          marginBottom: 8
        }}>
          <div style={{ 
            width: `${((currentTime / duration) * 100) || 0}%`, 
            height: "100%", 
            background: "var(--eh-aqua)", 
            borderRadius: 2 
          }} />
        </div>
        <div style={{ 
          fontSize: "12px", 
          color: "var(--eh-text-muted)",
          textAlign: "center"
        }}>
          {progressText}
        </div>
        {/* Hidden seek input for accessibility */}
        <input
          type="range"
          min="0"
          max={duration || 0}
          value={currentTime}
          onChange={onSeekInput}
          onMouseUp={commitSeek}
          onKeyUp={commitSeek}
          style={{
            width: "100%",
            height: "4px",
            background: "transparent",
            position: "absolute",
            top: 0,
            left: 0,
            opacity: 0,
            cursor: "pointer"
          }}
          aria-label="Seek through track"
        />
      </div>

      {/* Player controls - enhanced glassmorphism with subtle shadows */}
      <div className="eh-hstack" style={{ 
        justifyContent: "center", 
        gap: 16, 
        marginBottom: 16 
      }}>
        <button
          type="button"
          className="icon-btn"
          aria-label="Previous track"
          onClick={onPrev}
          style={{
            width: "52px", // 30% larger from 40px
            height: "52px", // 30% larger from 40px
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="prev" aria-hidden="true" size={24} />
        </button>
        
        <button
          type="button"
          className="icon-btn"
          aria-label={isPlaying ? "Pause" : "Play"}
          aria-pressed={isPlaying ? "true" : "false"}
          onClick={onToggle}
          style={{
            width: "52px", // 30% larger from 40px
            height: "52px", // 30% larger from 40px
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name={isPlaying ? "pause" : "play"} aria-hidden="true" size={24} />
        </button>
        
        <button
          type="button"
          className="icon-btn"
          aria-label="Next track"
          onClick={onNext}
          style={{
            width: "52px", // 30% larger from 40px
            height: "52px", // 30% larger from 40px
            background: "rgba(255, 255, 255, 0.06)",
            border: "1px solid rgba(255, 255, 255, 0.25)",
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
            backdropFilter: "blur(12px)",
            opacity: 0.75
          }}
        >
          <Icon name="next" aria-hidden="true" size={24} />
        </button>
      </div>

      {/* Volume control - enhanced glassmorphism with subtle shadows */}
      <div className="eh-hstack" style={{ 
        gap: 12, 
        alignItems: "center",
        justifyContent: "space-between"
      }}>
        <div className="eh-hstack" style={{ gap: 8, alignItems: "center" }}>
          <button
            type="button"
            className="icon-btn"
            aria-label={muted ? "Unmute" : "Mute"}
            aria-pressed={muted ? "true" : "false"}
            onClick={onMute}
            style={{
              width: "37px", // 15% larger from 32px
              height: "37px", // 15% larger from 32px
              background: "rgba(255, 255, 255, 0.06)",
              border: "1px solid rgba(255, 255, 255, 0.25)",
              boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
              backdropFilter: "blur(12px)",
              opacity: 0.75
            }}
          >
            <Icon name={muted ? "mute" : "volume"} aria-hidden="true" size={20} />
          </button>
          
          {/* Volume slider - extended to arrow tip position */}
          <label className="eh-hstack" style={{ gap: 8, alignItems: "center" }}>
            <span className="sr-only">Volume</span>
            <div style={{ width: "200px" }}> {/* Extended from 120px to arrow tip position */}
              <input
                type="range"
                min="0"
                max="100"
                value={volume}
                onChange={(e) => setVolume(Number(e.target.value))}
                aria-label="Volume"
                style={{
                  width: "100%",
                  height: "4px",
                  background: "rgba(255,255,255,0.1)",
                  borderRadius: "2px",
                  outline: "none",
                  cursor: "pointer"
                }}
              />
            </div>
          </label>
        </div>

        {/* Speed control - moved to right side with enhanced glassmorphism */}
        <div className="eh-hstack" style={{ gap: 8, alignItems: "center" }}>
          <span style={{ 
            fontSize: "12px", 
            color: "var(--eh-text-muted)",
            whiteSpace: "nowrap"
          }}>
            Speed:
          </span>
          <select
            value={rate}
            onChange={onRate}
            aria-label="Playback speed"
            style={{
              background: "rgba(255, 255, 255, 0.06)",
              border: "1px solid rgba(255, 255, 255, 0.25)",
              borderRadius: "8px",
              padding: "4px 8px",
              color: "var(--eh-text)",
              fontSize: "12px",
              backdropFilter: "blur(12px)",
              boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
              opacity: 0.75
            }}
          >
            {RATE_OPTIONS.map((r) => (
              <option key={r} value={r}>
                {r}×
              </option>
            ))}
          </select>
        </div>
      </div>
    </article>
  );
};

export default PlayerCard;
</file>

<file path="src/components/player/Timeline.tsx">
// src/components/player/Timeline.tsx
import React, { useCallback, useEffect, useRef, useState } from "react";
import { usePlayerStore } from "@/lib/state/usePlayerStore";

const formatTime = (sec?: number) => {
  const s = Number.isFinite(sec) && (sec as number) > 0 ? Math.floor(sec as number) : 0;
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const ss = String(s % 60).padStart(2, "0");
  return h > 0 ? `${h}:${String(m).padStart(2, "0")}:${ss}` : `${m}:${ss}`;
};

const clamp = (v: number, lo: number, hi: number) => Math.min(hi, Math.max(lo, v));

const TRACK_HEIGHT = 10;

const barStyle: React.CSSProperties = {
  position: "relative",
  height: TRACK_HEIGHT,
  borderRadius: TRACK_HEIGHT / 2,
  cursor: "pointer",
  // Glass base; project styles may further enhance via .eh-glass
  background: "rgba(255,255,255,0.12)",
  border: "1px solid rgba(255,255,255,0.25)",
  backdropFilter: "blur(16px)",
};

const fillStyle: React.CSSProperties = {
  position: "absolute",
  left: 0,
  top: 0,
  bottom: 0,
  borderRadius: TRACK_HEIGHT / 2,
  background: "var(--eh-highlight, #00F0FF)",
  width: "0%",
  pointerEvents: "none",
};

const handleStyle: React.CSSProperties = {
  position: "absolute",
  top: -3,
  width: 14,
  height: TRACK_HEIGHT + 6,
  marginLeft: -7, // center on progress edge
  borderRadius: 8,
  background: "rgba(255,255,255,0.85)",
  boxShadow: "0 2px 8px rgba(0,0,0,0.25)",
  pointerEvents: "none",
};

export const Timeline: React.FC = () => {
  // Select only what we need from the store to minimize re-renders
  const position = usePlayerStore((s: any) => s.position ?? s.currentTime ?? 0);
  const duration = usePlayerStore((s: any) => s.duration ?? 0);
  const seek = usePlayerStore((s: any) => s.seek ?? s.seekTo ?? ((_: number) => {}));

  const barRef = useRef<HTMLDivElement>(null);
  const draggingRef = useRef(false);
  const rafRef = useRef<number | null>(null);

  const [isHover, setIsHover] = useState(false);
  const [hoverPct, setHoverPct] = useState(0);

  const safeDuration = Math.max(0, Number(duration) || 0);
  const safePos = clamp(Number(position) || 0, 0, safeDuration);
  const pct = safeDuration > 0 ? (safePos / safeDuration) * 100 : 0;

  const posFromClientX = useCallback(
    (clientX: number) => {
      const el = barRef.current;
      if (!el || safeDuration <= 0) return 0;
      const rect = el.getBoundingClientRect();
      const local = clamp((clientX - rect.left) / rect.width, 0, 1);
      return local * safeDuration;
    },
    [safeDuration]
  );

  const updateSeekFromClientX = useCallback(
    (clientX: number) => {
      if (safeDuration <= 0) return;
      const t = posFromClientX(clientX);
      // use rAF to avoid flooding store updates
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = requestAnimationFrame(() => seek(t));
    },
    [posFromClientX, seek, safeDuration]
  );

  const onPointerDown = (clientX: number) => {
    if (safeDuration <= 0) return;
    draggingRef.current = true;
    updateSeekFromClientX(clientX);
  };

  const onGlobalPointerMove = useCallback(
    (e: MouseEvent | TouchEvent) => {
      if (!draggingRef.current) return;
      const clientX =
        e instanceof MouseEvent ? e.clientX : (e.touches && e.touches[0]?.clientX) || 0;
      updateSeekFromClientX(clientX);
    },
    [updateSeekFromClientX]
  );

  const onGlobalPointerUp = useCallback(() => {
    draggingRef.current = false;
  }, []);

  useEffect(() => {
    const move = (e: MouseEvent) => onGlobalPointerMove(e);
    const touchMove = (e: TouchEvent) => onGlobalPointerMove(e);
    window.addEventListener("mousemove", move, { passive: true });
    window.addEventListener("mouseup", onGlobalPointerUp, { passive: true });
    window.addEventListener("touchmove", touchMove, { passive: true });
    window.addEventListener("touchend", onGlobalPointerUp, { passive: true });
    return () => {
      window.removeEventListener("mousemove", move);
      window.removeEventListener("mouseup", onGlobalPointerUp);
      window.removeEventListener("touchmove", touchMove);
      window.removeEventListener("touchend", onGlobalPointerUp);
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [onGlobalPointerMove, onGlobalPointerUp]);

  const onKeyDown: React.KeyboardEventHandler<HTMLDivElement> = (e) => {
    if (safeDuration <= 0) return;
    const stepSmall = 5; // seconds
    const stepLarge = 10; // seconds
    if (e.key === "ArrowLeft") {
      e.preventDefault();
      seek(clamp(safePos - stepSmall, 0, safeDuration));
    } else if (e.key === "ArrowRight") {
      e.preventDefault();
      seek(clamp(safePos + stepSmall, 0, safeDuration));
    } else if (e.key === "PageDown") {
      e.preventDefault();
      seek(clamp(safePos - stepLarge, 0, safeDuration));
    } else if (e.key === "PageUp") {
      e.preventDefault();
      seek(clamp(safePos + stepLarge, 0, safeDuration));
    } else if (e.key === "Home") {
      e.preventDefault();
      seek(0);
    } else if (e.key === "End") {
      e.preventDefault();
      seek(safeDuration);
    }
  };

  const onBarClick: React.MouseEventHandler<HTMLDivElement> = (e) => {
    if (!barRef.current || safeDuration <= 0) return;
    onPointerDown(e.clientX);
  };

  const onBarMouseMove: React.MouseEventHandler<HTMLDivElement> = (e) => {
    if (!barRef.current || safeDuration <= 0) return;
    const rect = barRef.current.getBoundingClientRect();
    const local = clamp((e.clientX - rect.left) / rect.width, 0, 1);
    setHoverPct(local * 100);
  };

  const onTouchStart: React.TouchEventHandler<HTMLDivElement> = (e) => {
    const x = e.touches[0]?.clientX;
    if (typeof x === "number") onPointerDown(x);
  };

  return (
    <div style={{ width: "100%" }}>
      {/* Time labels */}
      <div
        className="eh-hstack"
        style={{ justifyContent: "space-between", fontSize: 12 }}
        aria-hidden={safeDuration <= 0}
      >
        <span aria-label="Elapsed time">{formatTime(safePos)}</span>
        <span aria-label="Total duration">{formatTime(safeDuration)}</span>
      </div>

      {/* Slider */}
      <div
        ref={barRef}
        className="eh-glass eh-timeline"
        role="slider"
        aria-label="Seek position"
        aria-valuemin={0}
        aria-valuemax={safeDuration || 0}
        aria-valuenow={safePos}
        aria-valuetext={`${formatTime(safePos)} of ${formatTime(safeDuration)}`}
        aria-disabled={safeDuration <= 0}
        tabIndex={safeDuration > 0 ? 0 : -1}
        onKeyDown={onKeyDown}
        onClick={onBarClick}
        onMouseEnter={() => setIsHover(true)}
        onMouseLeave={() => setIsHover(false)}
        onMouseMove={onBarMouseMove}
        onTouchStart={onTouchStart}
        style={{
          ...barStyle,
          marginTop: 6,
        }}
      >
        {/* Progress fill */}
        <div style={{ ...fillStyle, width: `${pct}%` }} />

        {/* Drag handle */}
        <div style={{ ...handleStyle, left: `${pct}%`, opacity: safeDuration > 0 ? 1 : 0.4 }} />

        {/* Hover indicator (thin line) */}
        {isHover && safeDuration > 0 && (
          <div
            aria-hidden
            style={{
              position: "absolute",
              top: 0,
              bottom: 0,
              left: `${hoverPct}%`,
              width: 2,
              transform: "translateX(-1px)",
              background: "rgba(255,255,255,0.6)",
              borderRadius: 1,
              pointerEvents: "none",
            }}
          />
        )}
      </div>
    </div>
  );
};

export default Timeline;
</file>

<file path="src/components/player/TrackInfo.css">
.eh-track-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0; /* enable text ellipsis */
}

.eh-track-title {
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.eh-track-artist,
.eh-track-album {
  font-size: 0.9rem;
  color: var(--eh-text-muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
</file>

<file path="src/components/player/TrackInfo.tsx">
// src/components/player/TrackInfo.tsx
/**
 * TrackInfo
 * -----------------------------------------------------------------------------
 * Simple track metadata block — semantic markup + lightweight render logic.
 * Uses glass tokens via CSS classes defined in ./TrackInfo.css
 */

import React from "react";
import "./TrackInfo.css";

export interface TrackInfoProps {
  title?: string;
  artist?: string;
  album?: string;
  /** Optional test hook */
  "data-testid"?: string;
}

const TrackInfo: React.FC<TrackInfoProps> = React.memo(
  ({ title, artist, album, "data-testid": testId }) => {
    // Normalize to avoid rendering "undefined"
    const safeTitle = (title ?? "").trim();
    const safeArtist = (artist ?? "").trim();
    const safeAlbum = (album ?? "").trim();

    return (
      <div
        className="eh-track-info"
        role="group"
        aria-label="Track information"
        data-testid={testId ?? "track-info"}
      >
        {/* Title is the primary heading for screen readers within the player card */}
        <h2
          className="eh-track-title eh-title"
          title={safeTitle || "Unknown title"}
          aria-label="Title"
        >
          {safeTitle || "Unknown title"}
        </h2>

        {/* Artist */}
        <div
          className="eh-track-artist"
          title={safeArtist || "Unknown artist"}
          aria-label="Artist"
        >
          {safeArtist || "Unknown artist"}
        </div>

        {/* Album (optional) */}
        {safeAlbum.length > 0 && (
          <div className="eh-track-album" title={safeAlbum} aria-label="Album">
            {safeAlbum}
          </div>
        )}
      </div>
    );
  }
);

TrackInfo.displayName = "TrackInfo";

export default TrackInfo;
</file>

<file path="src/components/player/TransportBar.tsx">
// src/components/player/TransportBar.tsx
/**
 * TransportBar
 * -----------------------------------------------------------------------------
 * Phase 2 time readout (elapsed / duration) with minimal dependencies.
 * This component intentionally does NOT render playback buttons; those live in
 * `PlaybackButtons.tsx`. TransportBar focuses on displaying timecodes and can
 * be placed above/below the Timeline component.
 */

import React from "react";
import { usePlayerStore } from "@/lib/state/usePlayerStore";

/** Format seconds -> mm:ss (or hh:mm:ss for long tracks) */
function formatTime(totalSeconds?: number): string {
  const s = Number.isFinite(totalSeconds) && totalSeconds! >= 0 ? Math.floor(totalSeconds!) : 0;
  const hours = Math.floor(s / 3600);
  const minutes = Math.floor((s % 3600) / 60);
  const seconds = s % 60;

  const pad = (n: number) => String(n).padStart(2, "0");
  return hours > 0 ? `${hours}:${pad(minutes)}:${pad(seconds)}` : `${minutes}:${pad(seconds)}`;
}

const TransportBar: React.FC = () => {
  // Select only what we need to minimize re-renders.
  const currentTime = usePlayerStore((s: any) => s.currentTime ?? 0);
  const duration = usePlayerStore((s: any) => s.duration ?? 0);

  // Derived, clamped values to keep UI stable.
  const safeCurrent = Math.max(0, Math.min(Number(currentTime) || 0, Number(duration) || Infinity));
  const safeDuration = Math.max(0, Number(duration) || 0);

  const elapsedText = formatTime(safeCurrent);
  const durationText = safeDuration > 0 ? formatTime(safeDuration) : "--:--";

  return (
    <div
      className="eh-transport eh-hstack"
      role="group"
      aria-label="Transport time"
      style={{
        alignItems: "center",
        justifyContent: "space-between",
        gap: 16,
      }}
    >
      {/* Elapsed time */}
      <time
        className="eh-time eh-time--elapsed tabular-nums"
        aria-label="Elapsed time"
        dateTime={`PT${Math.floor(safeCurrent)}S`}
      >
        {elapsedText}
      </time>

      {/* Spacer for center alignment if needed by layout */}
      <div aria-hidden />

      {/* Duration */}
      <time
        className="eh-time eh-time--duration tabular-nums"
        aria-label="Track duration"
        dateTime={`PT${Math.floor(safeDuration)}S`}
      >
        {durationText}
      </time>
    </div>
  );
};

export { TransportBar };
export default TransportBar;
</file>

<file path="src/components/player/UrlLoader.tsx">
import { FormEvent, useState } from 'react'
import { usePlayerStore } from '@/lib/state/usePlayerStore'
import { isHttpsUrl } from '@/lib/utils/UrlGuard'

export const UrlLoader = () => {
  const { load, play } = usePlayerStore()
  const [url, setUrl] = useState('https://files.freemusicarchive.org/storage-freemusicarchive-org/music/no_curator/Loyalty_Freak_Music/LOFI_and_chill/Loyalty_Freak_Music_-_01_-_Just_Because.mp3')

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    if (!isHttpsUrl(url)) {
      alert('Only HTTPS URLs are allowed.')
      return
    }
    load(url)
    play()
  }

  return (
    <form onSubmit={handleSubmit} className="eh-hstack" aria-label="Load from URL" style={{ gap: 8 }}>
      <input
        type="url"
        required
        value={url}
        onChange={(e) => setUrl(e.target.value)}
        placeholder="https://example.com/track.mp3"
        aria-label="Audio URL"
        className="eh-glass"
        style={{ padding: '8px 12px', width: '100%', borderRadius: '12px', background: 'rgba(255,255,255,0.06)' }}
      />
      <button type="submit" className="eh-glass" style={{ padding: '8px 12px', cursor: 'pointer' }}>
        Load URL
      </button>
    </form>
  )
}
</file>

<file path="src/components/player/VolumeSlider.tsx">
// src/components/player/VolumeSlider.tsx
/**
 * VolumeSlider
 * -----------------------------------------------------------------------------
 * Compact volume control (icon + horizontal slider).
 * - Width capped via CSS var (--eh-vol-max, default 180px).
 * - Debounces setVolume to protect main thread during drags.
 * - Supports either mute API (toggleMute/setMuted) or pure volume.
 * - A11y: SR label, live pct readout, correct ARIA values.
 */

import React, { useEffect, useMemo, useRef } from "react";
import { usePlayerStore } from "@/lib/state/usePlayerStore";

const clamp01 = (n: number) => Math.min(1, Math.max(0, n));

/** Choose an icon based on the effective volume (0..1). */
function useVolumeIcon(vol: number, muted: boolean): string {
  if (muted || vol === 0) return "🔇";
  if (vol < 0.34) return "🔈";
  if (vol < 0.67) return "🔉";
  return "🔊";
}

const VolumeSlider: React.FC = () => {
  // --- Store slices (primitive selectors keep renders cheap) -----------------
  const volume = usePlayerStore((s: any) => (typeof s.volume === "number" ? s.volume : 1));
  const setVolume = usePlayerStore((s: any) => s.setVolume as ((v: number) => void) | undefined);

  const muted = usePlayerStore((s: any) => Boolean(s.muted));
  const toggleMute = usePlayerStore((s: any) => s.toggleMute as (() => void) | undefined);
  const setMuted = usePlayerStore((s: any) => s.setMuted as ((v: boolean) => void) | undefined);

  // --- Locals ----------------------------------------------------------------
  const lastNonZeroRef = useRef(0.8); // fallback when unmuting without store support
  const safeVol = clamp01(Number.isFinite(volume) ? volume : 1);
  const effectiveVol = muted ? 0 : safeVol;
  const icon = useVolumeIcon(effectiveVol, muted);
  const pctText = useMemo(() => `${Math.round(effectiveVol * 100)}%`, [effectiveVol]);

  // Debounce to avoid spamming the audio engine during drags
  const debRef = useRef<number | null>(null);
  const emitVolume = (v: number) => {
    if (!setVolume) return;
    if (debRef.current) window.clearTimeout(debRef.current);
    debRef.current = window.setTimeout(() => setVolume(v), 80) as unknown as number;
  };
  useEffect(() => () => debRef.current && window.clearTimeout(debRef.current), []);

  // --- Handlers --------------------------------------------------------------
  const onChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {
    const next = clamp01(parseFloat(e.currentTarget.value));
    // If the store supports mute, unmute on user interaction
    if (muted && (setMuted || toggleMute)) {
      if (setMuted) setMuted(false);
      else toggleMute?.();
    }
    if (next > 0) lastNonZeroRef.current = next;
    emitVolume(next);
  };

  const onToggleMute = () => {
    if (toggleMute) {
      toggleMute();
      return;
    }
    if (setMuted) {
      setMuted(!muted);
      return;
    }
    // Fallback: emulate mute via volume
    if (effectiveVol === 0) {
      setVolume?.(lastNonZeroRef.current);
    } else {
      lastNonZeroRef.current = safeVol || lastNonZeroRef.current;
      setVolume?.(0);
    }
  };

  const onKeyAdjust: React.KeyboardEventHandler<HTMLInputElement> = (e) => {
    const step = e.shiftKey ? 0.1 : 0.02;
    if (e.key === "ArrowLeft" || e.key === "ArrowDown") {
      emitVolume(clamp01(effectiveVol - step));
      e.preventDefault();
    } else if (e.key === "ArrowRight" || e.key === "ArrowUp") {
      emitVolume(clamp01(effectiveVol + step));
      e.preventDefault();
    }
  };

  return (
    <div
      className="eh-volume-shell eh-hstack items-center"
      role="group"
      aria-label="Volume"
      // Layout width should be controlled via CSS var; default to 180px.
      // In tokens or a component stylesheet: .eh-volume-shell { max-inline-size: var(--eh-vol-max, 180px); }
      style={{ gap: 8 }}
    >
      {/* Mute toggle (button) */}
      <button
        type="button"
        className="eh-btn eh-btn--glass eh-btn--icon"
        aria-label={muted ? "Unmute" : "Mute"}
        aria-pressed={muted}
        onClick={onToggleMute}
        title={muted ? "Unmute" : "Mute"}
      >
        <span aria-hidden="true">{icon}</span>
      </button>

      {/* Slider (compact) */}
      <label className="sr-only" htmlFor="eh-volume">
        Volume
      </label>
      <input
        id="eh-volume"
        type="range"
        min={0}
        max={1}
        step={0.01}
        value={effectiveVol}
        onChange={onChange}
        onKeyDown={onKeyAdjust}
        aria-valuemin={0}
        aria-valuemax={1}
        aria-valuenow={Number.isFinite(effectiveVol) ? Number(effectiveVol.toFixed(2)) : 0}
        aria-valuetext={pctText}
        aria-label="Volume control"
        className="eh-volume-slider"
      />

      {/* Percent readout (optional) */}
      <output
        htmlFor="eh-volume"
        className="tabular-nums eh-volume-pct"
        aria-live="polite"
      >
        {pctText}
      </output>
    </div>
  );
};

export { VolumeSlider };
export default VolumeSlider;
</file>

<file path="src/components/settings/AudioDevicePicker.tsx">
// src/components/settings/AudioDevicePicker.tsx
/**
 * AudioDevicePicker (Phase 2)
 * -----------------------------------------------------------------------------
 * Unified output device selection UI backed by OutputDeviceManager.
 *
 * Goals
 * - Provide a single, accessible control to choose the app’s audio output
 *   device (speakers/headphones), using HTMLMediaElement.setSinkId when available.
 * - Replace all previous usages of legacy DeviceManager with OutputDeviceManager.
 *
 * Key behaviors
 * - Secure-context & feature detection; renders graceful fallback if unsupported.
 * - Enumerates `audiooutput` devices (labels may be empty until user grants permission).
 * - Persists user selection (handled inside OutputDeviceManager).
 * - Reacts to hotplug/permission changes via manager events.
 * - Offers a one-click “Enable device names” button to request audio permission,
 *   which unlocks readable device labels without using the stream.
 *
 * A11y
 * - Labeled <select> with role="combobox" semantics built-in.
 * - Announces state changes (aria-live).
 *
 * Styling
 * - Glass surface (“eh-glass”) with tokens from globals/tokens.css.
 */

import React, { useEffect, useMemo, useState } from "react";
import outputDeviceManager from "@/lib/audio/OutputDeviceManager";

type Option = { value: string; label: string };

const SUPPORT_TEXT =
  "Output routing (setSinkId) is only available on Chromium-based browsers over HTTPS or localhost.";

const AudioDevicePicker: React.FC = () => {
  const [supported, setSupported] = useState<boolean>(false);
  const [canEnumerate, setCanEnumerate] = useState<boolean>(false);
  const [options, setOptions] = useState<Option[]>([]);
  const [selected, setSelected] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [labelsUnlocked, setLabelsUnlocked] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // Determine support once on mount, then load devices & reapply persisted sink.
  useEffect(() => {
    let cancelled = false;

    const init = async () => {
      try {
        const hasSupport = outputDeviceManager.isAvailable();
        const canEnum = outputDeviceManager.canEnumerate();
        if (cancelled) return;
        setSupported(hasSupport);
        setCanEnumerate(canEnum);

        if (canEnum) {
          const opts = await outputDeviceManager.getOutputOptions();
          if (cancelled) return;
          setOptions(opts);
        }

        // Reflect current sinkId; if none, attempt persisted reapply.
        const sinkId = outputDeviceManager.getSinkId();
        if (!sinkId) {
          await outputDeviceManager.reapplyPersistedSink();
        }
        if (cancelled) return;
        setSelected(outputDeviceManager.getSinkId());

        setError(null);
      } catch (e: any) {
        if (!cancelled) setError(e?.message || "Failed to initialize audio devices");
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    init();

    // Subscribe to device and sink changes
    const offDevices = outputDeviceManager.on("deviceschanged", async () => {
      if (cancelled) return;
      try {
        const opts = await outputDeviceManager.getOutputOptions();
        if (cancelled) return;
        setOptions(opts);
      } catch {
        // ignore
      }
    });

    const offSink = outputDeviceManager.on("sinkchange", ({ sinkId, ok }) => {
      if (cancelled) return;
      setSelected(sinkId);
      if (!ok) {
        setError("Failed to switch output device");
      } else {
        setError(null);
      }
    });

    return () => {
      cancelled = true;
      offDevices?.();
      offSink?.();
    };
  }, []);

  const onChange = async (e: React.ChangeEvent<HTMLSelectElement>) => {
    const id = e.currentTarget.value;
    setSelected(id);
    try {
      await outputDeviceManager.setSinkId(id);
      setError(null);
    } catch (err: any) {
      setError(err?.message || "Unable to apply output device");
    }
  };

  const onUnlockLabels = async () => {
    try {
      const ok = await outputDeviceManager.ensurePermissionForLabels();
      setLabelsUnlocked(ok);
      // Re-enumerate to fetch device labels
      const opts = await outputDeviceManager.getOutputOptions();
      setOptions(opts);
    } catch (e: any) {
      setError(e?.message || "Permission request failed");
    }
  };

  const unavailableMsg = useMemo(() => {
    if (!supported) return SUPPORT_TEXT;
    if (!canEnumerate) return "This browser cannot enumerate audio devices.";
    return null;
  }, [supported, canEnumerate]);

  return (
    <section
      className="eh-glass"
      role="group"
      aria-label="Audio output device"
      style={{ padding: "var(--eh-gap-md)" }}
    >
      <div
        className="eh-hstack"
        style={{ justifyContent: "space-between", marginBottom: "var(--eh-gap-md)" }}
      >
        <div className="eh-vstack" style={{ gap: 2 }}>
          <h3 className="eh-title" style={{ margin: 0, fontSize: "var(--eh-fs-md)" }}>
            Output Device
          </h3>
          <p
            style={{
              margin: 0,
              fontSize: "var(--eh-fs-sm)",
              color: "var(--eh-text-muted)",
            }}
          >
            Route playback to your preferred speakers or headphones.
          </p>
        </div>

        {/* Optional helper to unlock human-readable labels */}
        {supported && canEnumerate && (
          <button
            type="button"
            className="eh-btn"
            onClick={onUnlockLabels}
            aria-pressed={labelsUnlocked}
            title="Enable device names"
          >
            {labelsUnlocked ? "Device names enabled" : "Enable device names"}
          </button>
        )}
      </div>

      {/* Unsupported / unavailable state */}
      {unavailableMsg && (
        <div
          role="note"
          style={{ fontSize: "var(--eh-fs-sm)", color: "var(--eh-text-muted)", marginBottom: 8 }}
        >
          {unavailableMsg}
        </div>
      )}

      {/* Picker */}
      <label className="eh-vstack" style={{ gap: "var(--eh-gap-sm)" }}>
        <span style={{ fontSize: "var(--eh-fs-sm)" }}>Select output</span>

        <select
          value={selected ?? ""}
          onChange={onChange}
          disabled={!supported || !canEnumerate || loading}
          aria-disabled={!supported || !canEnumerate || loading}
          aria-busy={loading}
          style={{
            height: 36,
            borderRadius: "var(--eh-button-radius)",
            border: "var(--eh-glass-border)",
            background: "var(--eh-glass-bg)",
            color: "var(--eh-text)",
            padding: "0 10px",
            outline: "none",
          }}
        >
          {/* If selected is null, surface a placeholder that maps to "default" */}
          {!selected && <option value="">System Default</option>}
          {options.map((o) => (
            <option key={o.value} value={o.value}>
              {o.label}
            </option>
          ))}
        </select>
      </label>

      {/* Status */}
      <div
        aria-live="polite"
        aria-atomic="true"
        style={{
          marginTop: "var(--eh-gap-sm)",
          fontSize: "var(--eh-fs-sm)",
          color: error ? "var(--eh-danger, #ff6b6b)" : "var(--eh-text-muted)",
        }}
      >
        {loading
          ? "Loading devices…"
          : error
          ? error
          : selected
          ? `Current sink: ${selected}`
          : "Using system default"}
      </div>
    </section>
  );
};

export default AudioDevicePicker;
</file>

<file path="src/components/settings/EqPanel.tsx">
// src/components/settings/EqPanel.tsx
/**
 * EqPanel (Phase 2)
 * -----------------------------------------------------------------------------
 * Small, accessible UI for adjusting the 10-band EQ and toggling bypass.
 *
 * Integration
 * - Talks to the audio engine through the high-level facade:
 *     • audioEngine.setEqGain(index, gainDb)
 *     • audioEngine.setEqBypassed(boolean)
 *     • audioEngine.getEqBands() → readonly { freq, gain }[]
 * - The first call (mount) will lazily create the EQ graph via AudioEngine.ensureEq().
 *
 * A11y
 * - Each slider uses role=slider semantics provided by <input type="range">.
 * - Proper aria-labels that include the center frequency.
 *
 * Styling
 * - Uses glass tokens from globals/tokens (eh-glass, range styling already defined).
 */

import React, { useEffect, useMemo, useState } from "react";
import audioEngine from "@/lib/audio/AudioEngine";

type Band = { freq: number; gain: number };

const formatHz = (hz: number) => {
  if (hz >= 1000) return `${(hz / 1000).toFixed(hz % 1000 === 0 ? 0 : 1)} kHz`;
  return `${hz} Hz`;
};

const GAIN_MIN = -12;
const GAIN_MAX = 12;
const GAIN_STEP = 0.5;

const EqPanel: React.FC = () => {
  const [bands, setBands] = useState<Band[]>([]);
  const [bypassed, setBypassed] = useState(false);

  // On mount: ensure EQ graph exists and hydrate local state from engine.
  useEffect(() => {
    let cancelled = false;

    (async () => {
      try {
        // Ensures the EQ module is loaded and chain rewired (no audible change: gains default 0).
        await audioEngine.setEqBypassed(false);
        const initial = audioEngine.getEqBands();
        if (!cancelled) setBands(initial.slice());
      } catch {
        // EQ is optional; if not available, keep panel empty.
      }
    })();

    return () => {
      cancelled = true;
    };
  }, []);

  // Slider handler: update a single band gain
  const onChangeGain = (idx: number) => async (e: React.ChangeEvent<HTMLInputElement>) => {
    const val = parseFloat(e.currentTarget.value);
    try {
      await audioEngine.setEqGain(idx, val);
      setBands((prev) => {
        const next = prev.slice();
        if (next[idx]) next[idx] = { ...next[idx], gain: val };
        return next;
      });
    } catch {
      // ignore if EQ module absent
    }
  };

  // Bypass toggle
  const onToggleBypass = async () => {
    const next = !bypassed;
    setBypassed(next);
    try {
      await audioEngine.setEqBypassed(next);
    } catch {
      // ignore
    }
  };

  // Render nothing if EQ unavailable
  if (!bands.length) {
    return (
      <section
        className="eh-glass"
        role="region"
        aria-label="Equalizer"
        style={{ padding: "var(--eh-gap-md)" }}
      >
        <div style={{ fontSize: "var(--eh-fs-sm)", color: "var(--eh-text-muted)" }}>
          Equalizer unavailable
        </div>
      </section>
    );
  }

  return (
    <section
      className="eh-glass"
      role="region"
      aria-label="Equalizer"
      style={{ padding: "var(--eh-gap-md)" }}
    >
      <div className="eh-hstack" style={{ justifyContent: "space-between", marginBottom: 8 }}>
        <h3 className="eh-title" style={{ fontSize: "var(--eh-fs-md)", margin: 0 }}>
          Equalizer
        </h3>
        <button
          className="eh-btn"
          type="button"
          aria-pressed={bypassed}
          aria-label={bypassed ? "EQ bypassed — click to enable" : "EQ enabled — click to bypass"}
          onClick={onToggleBypass}
          title={bypassed ? "Enable EQ" : "Bypass EQ"}
        >
          {bypassed ? "Bypassed" : "Enabled"}
        </button>
      </div>

      {/* Sliders grid */}
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(5, minmax(140px, 1fr))",
          gap: "var(--eh-gap-md)",
        }}
      >
        {bands.map((b, i) => (
          <label key={b.freq} className="eh-vstack" style={{ alignItems: "stretch" }}>
            <span
              style={{
                fontSize: "var(--eh-fs-sm)",
                color: "var(--eh-text-muted)",
                textAlign: "left",
              }}
            >
              {formatHz(b.freq)}
              <span className="sr-only"> gain</span>
            </span>
            <input
              type="range"
              min={GAIN_MIN}
              max={GAIN_MAX}
              step={GAIN_STEP}
              value={b.gain}
              aria-label={`Gain for ${formatHz(b.freq)}`}
              onChange={onChangeGain(i)}
              // Disabled UI state mirrors bypass but still lets users stage values;
              // we keep it interactive to preview slider positions. If you prefer
              // strict disable, uncomment the next line:
              // disabled={bypassed}
            />
            <span style={{ fontSize: "var(--eh-fs-xs)", color: "var(--eh-text-subtle)" }}>
              {b.gain > 0 ? `+${b.gain.toFixed(1)} dB` : `${b.gain.toFixed(1)} dB`}
            </span>
          </label>
        ))}
      </div>
    </section>
  );
};

export default EqPanel;
</file>

<file path="src/components/settings/SettingsPanel.tsx">
// src/components/settings/SettingsPanel.tsx
/**
 * SettingsPanel
 * -----------------------------------------------------------------------------
 * Unified, single source of truth for visualizer/tooling settings.
 *
 * Why this change?
 * - We previously had multiple “subpanels” (`VisualizerControls`, `EqPanel`,
 *   `AudioDevicePicker`). To avoid duplication and drift, this component now
 *   owns the compact toolbar (Preset/HDR/Dimmer) **and** can optionally render
 *   advanced subpanels (EQ + Output Device) when asked.
 *
 * Usage
 * - AppShell mounts the compact toolbar:
 *     <section className="eh-glass eh-controls-grid" role="toolbar" ...>
 *       <SettingsPanel />   // default: compact
 *     </section>
 *
 * - A full Settings view (later phases) can expand advanced panels:
 *     <SettingsPanel mode="full" />
 *
 * Accessibility
 * - Toolbar controls remain keyboard accessible and labeled.
 * - Advanced panels are wrapped in <details> groups with <summary> buttons,
 *   each with appropriate aria-labels.
 *
 * Styling
 * - This component renders **content only** (no glass wrapper) because AppShell
 *   already provides the container. If you need a standalone usage elsewhere,
 *   wrap it in `.eh-glass` yourself.
 */

import React from "react";
import PresetSelector from "@/components/visualizer/PresetSelector";
import HdrToggle from "@/components/visualizer/HdrToggle";
import DimmerToggle from "@/components/visualizer/DimmerToggle";
import EqPanel from "@/components/settings/EqPanel";
import AudioDevicePicker from "@/components/settings/AudioDevicePicker";

type SettingsPanelProps = {
  /** "compact" (toolbar-only) or "full" (toolbar + advanced panels). */
  mode?: "compact" | "full";
  /** When mode="compact", optionally show the advanced panels inline. */
  showAdvanced?: boolean;
};

const SettingsPanel: React.FC<SettingsPanelProps> = ({ mode = "compact", showAdvanced = false }) => {
  const renderAdvanced = mode === "full" || showAdvanced;

  return (
    <div className="eh-vstack" style={{ gap: "var(--eh-gap-md)" }}>
      {/* --------------------------------------------------------------------
          Toolbar row: Preset / HDR / Dimmer
         ------------------------------------------------------------------ */}
      <div className="eh-hstack" style={{ 
          gap: 16, 
          justifyContent: "space-between", 
          padding: "var(--eh-gap-md)",
          background: "rgba(255, 255, 255, 0.05)",
          borderRadius: "var(--eh-glass-radius)",
          border: "1px solid rgba(255, 255, 255, 0.1)"
        }}>
          <span className="eh-title" style={{ fontSize: "14px", fontWeight: 600 }}>
            Visualizer quick controls
          </span>
          <div className="eh-hstack" style={{ gap: 12 }}>
            <button 
              className="eh-btn eh-btn--hdr"
              style={{
                background: "rgba(255, 255, 255, 0.06)",
                border: "1px solid rgba(255, 255, 255, 0.25)",
                boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
                backdropFilter: "blur(12px)",
                opacity: 0.75
              }}
            >
              HDR Off
            </button>
            <button 
              className="eh-btn eh-btn--dimmer"
              style={{
                background: "rgba(255, 255, 255, 0.06)",
                border: "1px solid rgba(255, 255, 255, 0.25)",
                boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2)",
                backdropFilter: "blur(12px)",
                opacity: 0.75
              }}
            >
              Dimmer Off
            </button>
          </div>
        </div>

      {/* --------------------------------------------------------------------
          Advanced panels (optional): EQ and Output Device
          - Collapsed by default via <details>, suitable for the compact rail.
         ------------------------------------------------------------------ */}
      {renderAdvanced && (
        <div className="eh-vstack" style={{ gap: "var(--eh-gap-md)" }}>
          <details className="eh-glass" style={{ padding: "var(--eh-gap-md)" }}>
            <summary
              className="eh-hstack"
              role="button"
              aria-label="Toggle equalizer settings"
              style={{ cursor: "pointer", gap: 8 }}
            >
              <span className="eh-title" style={{ fontSize: "var(--eh-fs-md)" }}>
                Equalizer
              </span>
              <span style={{ fontSize: "var(--eh-fs-sm)", color: "var(--eh-text-muted)" }}>
                10-band parametric (optional)
              </span>
            </summary>
            <div style={{ marginTop: "var(--eh-gap-md)" }}>
              <EqPanel />
            </div>
          </details>

          <details className="eh-glass" style={{ padding: "var(--eh-gap-md)" }}>
            <summary
              className="eh-hstack"
              role="button"
              aria-label="Toggle output device selector"
              style={{ cursor: "pointer", gap: 8 }}
            >
              <span className="eh-title" style={{ fontSize: "var(--eh-fs-md)" }}>
                Output Device
              </span>
              <span style={{ fontSize: "var(--eh-fs-sm)", color: "var(--eh-text-muted)" }}>
                Route audio to speakers/headphones
              </span>
            </summary>
            <div style={{ marginTop: "var(--eh-gap-md)" }}>
              <AudioDevicePicker />
            </div>
          </details>
        </div>
      )}
    </div>
  );
};

export default SettingsPanel;
</file>

<file path="src/components/settings/VisualizerControls.tsx">
// src/components/settings/VisualizerControls.tsx
/**
 * DEPRECATED: VisualizerControls
 * -----------------------------------------------------------------------------
 * This component previously exposed the quick visualizer controls (Preset/HDR/Dimmer).
 * To reduce duplication, **SettingsPanel** is now the single entry point for both
 * compact toolbar and advanced settings.
 *
 * Migrate imports to:
 *   import SettingsPanel from "@/components/settings/SettingsPanel";
 *
 * For a drop-in replacement (toolbar only), this shim renders:
 *   <SettingsPanel mode="compact" />
 */

import React from "react";
import SettingsPanel from "@/components/settings/SettingsPanel";

/** @deprecated Use `SettingsPanel` instead. */
const VisualizerControls: React.FC = () => {
  if (process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line no-console
    console.warn(
      "[Ethereal Harmony] `VisualizerControls` is deprecated. Use `SettingsPanel` instead."
    );
  }
  return <SettingsPanel mode="compact" />;
};

export default VisualizerControls;
export { VisualizerControls };
</file>

<file path="src/components/shortcuts/GlobalHotkeys.tsx">
// src/components/shortcuts/GlobalHotkeys.tsx
import React from "react";
import { useHotkeys } from "@/lib/utils/useHotkeys";
import { usePlayerStore } from "@/lib/state/usePlayerStore";

/**
 * GlobalHotkeys
 * -----------------------------------------------------------------------------
 * Small, renderless component that registers global keyboard shortcuts using
 * our shared `useHotkeys` utility. It wires keys into playback controls
 * provided by `usePlayerStore` / PlaybackController.
 *
 * Scope (V1, per request):
 *   - Space: Play/Pause toggle
 *   - Left Arrow: Previous track
 *   - Right Arrow: Next track
 *
 * Behavior details:
 * - `useHotkeys` already guards against firing inside text inputs (per util).
 * - We read the minimal slice from the player store to avoid unnecessary
 *   re-renders and keep the component inert outside of key presses.
 * - We do not render any UI; this component solely binds handlers on mount.
 *
 * Integration:
 * - Mount once near the app root (e.g., in AppShell).
 * - `enableDefaults: true` lets the util register any foundational shortcuts
 *   (e.g., escape to close modals) while we append playback-specific ones via
 *   the `extra` array below.
 */

const clamp = (v: number, min = 0, max = 1) => (v < min ? min : v > max ? max : v);

const GlobalHotkeys: React.FC = () => {
  // Select only what we need from the store to minimize subscriptions.
  const isPlaying = usePlayerStore((s) => s.isPlaying);
  const play = usePlayerStore((s) => s.play);
  const pause = usePlayerStore((s) => s.pause);
  const next = usePlayerStore((s) => s.next);
  const prev = usePlayerStore((s) => s.prev);

  // (Optional future hook-ups if desired later)
  // const setVolume = usePlayerStore((s) => s.setVolume);
  // const volume = usePlayerStore((s) => s.volume);

  useHotkeys({
    enableDefaults: true,
    extra: [
      // Space → toggle play/pause
      {
        keys: [" "], // note: a single space denotes Spacebar in our util
        description: "Play/Pause",
        handler: (e: KeyboardEvent) => {
          e.preventDefault(); // prevent page scrolling
          if (isPlaying) pause();
          else play();
        },
      },

      // Left Arrow → previous track
      {
        keys: ["ArrowLeft"],
        description: "Previous track",
        handler: (e: KeyboardEvent) => {
          e.preventDefault();
          prev();
        },
      },

      // Right Arrow → next track
      {
        keys: ["ArrowRight"],
        description: "Next track",
        handler: (e: KeyboardEvent) => {
          e.preventDefault();
          next();
        },
      },

      // ---------------------------------------------------------------------
      // NOTE:
      // The following examples are commented-out stubs for future expansion
      // (kept here for developer convenience). Uncomment to enable when
      // product decisions allow:
      //
      // // Up Arrow → volume up (small step)
      // {
      //   keys: ["ArrowUp"],
      //   description: "Volume up",
      //   handler: (e: KeyboardEvent) => {
      //     e.preventDefault();
      //     const step = 0.05;
      //     setVolume(clamp((usePlayerStore.getState().volume ?? 1) + step));
      //   },
      // },
      //
      // // Down Arrow → volume down (small step)
      // {
      //   keys: ["ArrowDown"],
      //   description: "Volume down",
      //   handler: (e: KeyboardEvent) => {
      //     e.preventDefault();
      //     const step = 0.05;
      //     setVolume(clamp((usePlayerStore.getState().volume ?? 1) - step));
      //   },
      // },
      // ---------------------------------------------------------------------
    ],
  });

  return null;
};

export default GlobalHotkeys;
</file>

<file path="src/components/streaming/StreamTestWizard.tsx">
```tsx
// src/components/streaming/StreamTestWizard.tsx
/**
 * StreamTestWizard
 * -----------------------------------------------------------------------------
 * Phase 2 utility to validate streaming URLs (HLS or direct audio) before
 * handing them to the player. Runs a few light checks:
 *  - URL shape and scheme validation (UrlGuard-lite).
 *  - CORS reachability (HEAD; falls back to small GET range).
 *  - Content-Type sniff (e.g., application/vnd.apple.mpegurl, audio/*).
 *  - HLS viability (m3u8 + MediaSource support; optional HlsController probe).
 *
 * If everything looks good, you can "Send to Player" which calls a store
 * method if available: loadFromUrl/loadUrl/load(url).
 *
 * Notes:
 *  - No external deps; safe to mount anywhere in Phase 2.
 *  - Uses glass tokens via `eh-glass` classes; minimal inline styles.
 */

import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { usePlayerStore } from "@/lib/state/usePlayerStore";

// ---- Types ------------------------------------------------------------------

type TestResult = {
  url: string;
  normalizedUrl: string;
  isHttps: boolean;
  isLikelyHls: boolean;
  mediaSourceSupported: boolean;
  corsOk: boolean | null;
  status?: number;
  contentType?: string;
  bytesSampled?: number;
  hlsControllerOk: boolean | null; // null = not attempted
  errors: string[];
};

// ---- Helpers ----------------------------------------------------------------

const DEFAULTS: TestResult = {
  url: "",
  normalizedUrl: "",
  isHttps: true,
  isLikelyHls: false,
  mediaSourceSupported: typeof window !== "undefined" && "MediaSource" in window,
  corsOk: null,
  status: undefined,
  contentType: undefined,
  bytesSampled: 0,
  hlsControllerOk: null,
  errors: [],
};

const SAMPLE_RANGE = "bytes=0-1023"; // 1KB sniff

function isLikelyHlsUrl(u: string): boolean {
  try {
    const url = new URL(u);
    return /\.m3u8(\?.*)?$/i.test(url.pathname);
  } catch {
    return /\.m3u8(\?.*)?$/i.test(u);
  }
}

function normalizeUrl(input: string): string {
  const s = input.trim();
  if (!s) return s;
  // Allow protocol-relative and common schemeless inputs
  if (/^\/\//.test(s)) return `https:${s}`;
  if (/^https?:\/\//i.test(s)) return s;
  // If schemeless but looks like domain, assume https
  if (/^[a-z0-9.-]+\.[a-z]{2,}([/:?#].*)?$/i.test(s)) return `https://${s}`;
  return s;
}

async function probeCors(url: string): Promise<{ ok: boolean; status?: number; contentType?: string; bytes?: number }> {
  try {
    // HEAD first
    const head = await fetch(url, { method: "HEAD", mode: "cors" });
    const ct = head.headers.get("content-type") || undefined;
    if (head.ok) {
      return { ok: true, status: head.status, contentType: ct, bytes: 0 };
    }
    // Fallback: small range GET (some CDNs block HEAD)
    const get = await fetch(url, {
      method: "GET",
      mode: "cors",
      headers: { Range: SAMPLE_RANGE },
    });
    const buf = await get.arrayBuffer();
    const ct2 = get.headers.get("content-type") || ct || undefined;
    return { ok: get.ok, status: get.status, contentType: ct2, bytes: buf.byteLength || 0 };
  } catch {
    return { ok: false };
  }
}

async function tryHlsController(url: string): Promise<boolean | null> {
  // Optional: only probe if file exists and looks like m3u8
  if (!isLikelyHlsUrl(url)) return null;
  try {
    // Dynamically import to avoid hard dependency at build time.
    const mod = await import("@/lib/streaming/HlsController").catch(() => null);
    if (!mod || typeof mod.probe !== "function") return null;
    // Expect a `probe(url)` that resolves boolean
    const result: boolean = await mod.probe(url);
    return !!result;
  } catch {
    return null;
  }
}

// ---- Component --------------------------------------------------------------

const fieldStyle: React.CSSProperties = {
  width: "100%",
  background: "rgba(255,255,255,0.12)",
  border: "1px solid rgba(255,255,255,0.25)",
  backdropFilter: "blur(16px)",
  borderRadius: 12,
  color: "#fff",
  padding: "10px 12px",
  outline: "none",
};

const btnStyle: React.CSSProperties = {
  background: "rgba(255,255,255,0.12)",
  border: "1px solid rgba(255,255,255,0.25)",
  backdropFilter: "blur(16px)",
  borderRadius: 12,
  color: "#fff",
  padding: "8px 12px",
  cursor: "pointer",
};

const labelStyle: React.CSSProperties = {
  fontSize: 12,
  opacity: 0.9,
  marginBottom: 6,
};

const gridRowStyle: React.CSSProperties = {
  display: "grid",
  gridTemplateColumns: "180px 1fr",
  gap: 12,
  alignItems: "center",
};

const pill = (ok?: boolean | null) =>
  ({
    display: "inline-block",
    padding: "2px 8px",
    borderRadius: 999,
    fontSize: 12,
    lineHeight: 1.6,
    border: "1px solid rgba(255,255,255,0.25)",
    background:
      ok === true
        ? "rgba(0,240,255,0.18)"
        : ok === false
        ? "rgba(255,107,107,0.18)"
        : "rgba(255,255,255,0.12)",
  } as React.CSSProperties);

const StreamTestWizard: React.FC = () => {
  const loadFromUrl = usePlayerStore((s: any) => s.loadFromUrl ?? s.loadUrl ?? s.load);
  const [input, setInput] = useState("");
  const [running, setRunning] = useState(false);
  const [result, setResult] = useState<TestResult>(DEFAULTS);
  const [log, setLog] = useState<string[]>([]);
  const audioRef = useRef<HTMLAudioElement>(null);

  const canSendToPlayer = useMemo(() => {
    if (!result.normalizedUrl) return false;
    if (result.isLikelyHls) {
      // For HLS, require CORS OK and MSE support; HlsController probe if available
      return !!result.mediaSourceSupported && result.corsOk === true && (result.hlsControllerOk !== false);
    }
    // For direct audio, require CORS OK and an audio/* content type
    return result.corsOk === true && !!result.contentType && /^audio\//i.test(result.contentType);
  }, [result]);

  const appendLog = (line: string) => setLog((l) => [...l, line]);

  const runTests = useCallback(async () => {
    const url = normalizeUrl(input);
    setRunning(true);
    setLog([]);
    setResult(DEFAULTS);

    if (!url) {
      setRunning(false);
      setResult((r) => ({ ...r, errors: ["No URL provided"] }));
      return;
    }

    appendLog(`URL: ${url}`);

    let working: TestResult = {
      ...DEFAULTS,
      url: input,
      normalizedUrl: url,
      isHttps: (() => {
        try {
          return new URL(url).protocol === "https:";
        } catch {
          return true;
        }
      })(),
      isLikelyHls: isLikelyHlsUrl(url),
    };

    // Check CORS / Content-Type
    appendLog("Probing CORS and content-type…");
    const cors = await probeCors(url);
    working = {
      ...working,
      corsOk: cors.ok,
      status: cors.status,
      contentType: cors.contentType,
      bytesSampled: cors.bytes,
    };
    appendLog(
      `CORS: ${cors.ok ? "OK" : "Blocked"}${cors.status ? ` (HTTP ${cors.status})` : ""}${
        cors.contentType ? `, Content-Type: ${cors.contentType}` : ""
      }${cors.bytes ? `, Sampled: ${cors.bytes}B` : ""}`
    );

    // MediaSource (HLS) support
    working.mediaSourceSupported = typeof window !== "undefined" && "MediaSource" in window;
    if (working.isLikelyHls) {
      appendLog(`Detected HLS URL (.m3u8). MediaSource: ${working.mediaSourceSupported ? "supported" : "not supported"}`);
    }

    // Optional HlsController probe
    if (working.isLikelyHls) {
      const ok = await tryHlsController(url);
      working.hlsControllerOk = ok;
      if (ok === true) appendLog("HlsController probe: OK");
      else if (ok === false) appendLog("HlsController probe: FAILED");
      else appendLog("HlsController probe: skipped");
    }

    // Error aggregation
    const errs: string[] = [];
    if (!working.corsOk) errs.push("CORS check failed (resource unreachable from this origin).");
    if (working.isLikelyHls) {
      if (!working.mediaSourceSupported) errs.push("MediaSource API not available (HLS needs MSE).");
    } else {
      // Direct file should advertise audio/*
      if (working.contentType && !/^audio\//i.test(working.contentType)) {
        errs.push(`Unexpected content-type (${working.contentType}) for a direct audio stream.`);
      }
    }
    working.errors = errs;

    setResult(working);
    setRunning(false);
  }, [input]);

  const onSendToPlayer = () => {
    if (!canSendToPlayer || !result.normalizedUrl) return;
    try {
      loadFromUrl?.(result.normalizedUrl);
    } catch {
      // no-op; UI remains as a helper
    }
  };

  // Small preview audio element (muted by default). Only for non-HLS direct audio.
  useEffect(() => {
    const el = audioRef.current;
    if (!el) return;
    if (result.isLikelyHls) {
      el.src = "";
      return;
    }
    if (result.corsOk && result.contentType && /^audio\//i.test(result.contentType)) {
      el.src = result.normalizedUrl;
    } else {
      el.src = "";
    }
  }, [result]);

  return (
    <section
      className="eh-glass"
      aria-label="Stream test wizard"
      style={{
        padding: 12,
        borderRadius: 16,
        display: "grid",
        gap: 12,
      }}
    >
      {/* URL field */}
      <div style={{ display: "grid", gap: 6 }}>
        <label htmlFor="stream-url" style={labelStyle}>
          Stream URL (HLS .m3u8 or direct audio)
        </label>
        <input
          id="stream-url"
          type="url"
          inputMode="url"
          autoCapitalize="off"
          autoCorrect="off"
          spellCheck={false}
          placeholder="https://example.com/stream.m3u8"
          value={input}
          onChange={(e) => setInput(e.currentTarget.value)}
          style={fieldStyle}
        />
      </div>

      {/* Actions */}
      <div className="eh-hstack" style={{ gap: 8, justifyContent: "flex-end" }}>
        <button
          type="button"
          onClick={runTests}
          disabled={running || input.trim().length === 0}
          className="eh-btn eh-btn--glass"
          style={btnStyle}
          aria-busy={running}
        >
          {running ? "Testing…" : "Run Tests"}
        </button>
        <button
          type="button"
          onClick={onSendToPlayer}
          disabled={!canSendToPlayer}
          className="eh-btn eh-btn--glass"
          style={{ ...btnStyle, borderColor: "rgba(0,240,255,0.6)" }}
          title={canSendToPlayer ? "Send to player" : "Run tests and ensure they pass first"}
        >
          Send to Player
        </button>
      </div>

      {/* Results */}
      <div
        className="eh-grid"
        role="status"
        aria-live="polite"
        style={{ display: "grid", gap: 8 }}
      >
        <div style={gridRowStyle}>
          <div>Normalized URL</div>
          <div style={{ wordBreak: "break-all", opacity: 0.95 }}>{result.normalizedUrl || "—"}</div>
        </div>
        <div style={gridRowStyle}>
          <div>Scheme</div>
          <div><span style={pill(result.isHttps)}>{result.isHttps ? "HTTPS" : "HTTP"}</span></div>
        </div>
        <div style={gridRowStyle}>
          <div>Type detection</div>
          <div>
            {result.isLikelyHls ? (
              <span style={pill(true)}>HLS (.m3u8)</span>
            ) : (
              <span style={pill(result.contentType ? /^audio\//i.test(result.contentType) : null)}>
                {result.contentType || "unknown"}
              </span>
            )}
          </div>
        </div>
        <div style={gridRowStyle}>
          <div>CORS reachability</div>
          <div>
            <span style={pill(result.corsOk)}>{result.corsOk === true ? "OK" : result.corsOk === false ? "Blocked" : "Unknown"}</span>
            {typeof result.status === "number" && (
              <span style={{ marginLeft: 8, opacity: 0.9 }}>HTTP {result.status}</span>
            )}
            {result.bytesSampled ? (
              <span style={{ marginLeft: 8, opacity: 0.9 }}>{result.bytesSampled} B</span>
            ) : null}
          </div>
        </div>
        {result.isLikelyHls && (
          <>
            <div style={gridRowStyle}>
              <div>MediaSource (MSE)</div>
              <div><span style={pill(result.mediaSourceSupported)}>{result.mediaSourceSupported ? "Supported" : "Not supported"}</span></div>
            </div>
            <div style={gridRowStyle}>
              <div>HlsController probe</div>
              <div><span style={pill(result.hlsControllerOk)}>{result.hlsControllerOk === null ? "Skipped" : result.hlsControllerOk ? "OK" : "Failed"}</span></div>
            </div>
          </>
        )}
        {result.errors.length > 0 && (
          <div
            className="eh-error-list"
            role="alert"
            style={{
              background: "rgba(255,107,107,0.12)",
              border: "1px solid rgba(255,107,107,0.4)",
              borderRadius: 12,
              padding: 10,
            }}
          >
            <ul style={{ margin: 0, paddingInlineStart: 18 }}>
              {result.errors.map((e, i) => (
                <li key={i}>{e}</li>
              ))}
            </ul>
          </div>
        )}
      </div>

      {/* Minimal preview for direct audio (muted by default) */}
      <div aria-hidden={result.isLikelyHls || !result.corsOk} style={{ marginTop: 4 }}>
        <audio ref={audioRef} controls muted style={{ width: "100%", opacity: result.isLikelyHls ? 0.4 : 1 }} />
      </div>

      {/* Debug log */}
      {log.length > 0 && (
        <details style={{ marginTop: 6 }}>
          <summary>Log</summary>
          <pre style={{ whiteSpace: "pre-wrap", wordBreak: "break-word", opacity: 0.9, marginTop: 6 }}>
            {log.join("\n")}
          </pre>
        </details>
      )}
    </section>
  );
};

export default StreamTestWizard;
```
</file>

<file path="src/components/visualizer/DimmerToggle.tsx">
// src/components/visualizer/DimmerToggle.tsx
/**
 * DimmerToggle (Phase 2 hotfix)
 * ------------------------------------------------------------
 * Mirrors the HdrToggle fix:
 *  - Uses primitive Zustand selectors (no object creation in selector).
 *  - No state writes during render; event handler only.
 *  - Provides accessible toggle semantics with role="switch".
 *
 * The "dimmer" flag is used by the scene to reduce intensity/brightness
 * without fully disabling the visualizer — helpful for reading UI.
 */

import React from "react";
import { useVizStore } from "@/lib/state/useVizStore";

const DimmerToggle: React.FC = () => {
  // ✅ Stable primitive selectors
  const dimmer = useVizStore((s) => s.dimmer);
  const toggleDimmer = useVizStore((s) => s.toggleDimmer);

  const onToggle = () => toggleDimmer();

  return (
    <button
      type="button"
      onClick={onToggle}
      role="switch"
      aria-checked={dimmer}
      aria-label={dimmer ? "Disable dimmer" : "Enable dimmer"}
      className={[
        "inline-flex items-center rounded-[16px] border border-[rgba(255,255,255,0.25)]",
        "bg-[rgba(255,255,255,0.12)] backdrop-blur-[16px] px-3 py-2",
        "transition-transform active:scale-[0.98]",
        "focus:outline-none focus-visible:ring-2 focus-visible:ring-[#00F0FF]",
        dimmer ? "opacity-100" : "opacity-80",
      ].join(" ")}
    >
      {dimmer ? "Dimmer On" : "Dimmer Off"}
    </button>
  );
};

export default DimmerToggle;
</file>

<file path="src/components/visualizer/HdrToggle.tsx">
// src/components/visualizer/HdrToggle.tsx
/**
 * HdrToggle (Phase 2 hotfix)
 * ------------------------------------------------------------
 * Fixes the React 18 "getSnapshot should be cached" warning and
 * max-update-depth loop by:
 *  - Selecting *primitive slices* from Zustand (no object selector).
 *  - Avoiding any state writes during render (writes only in handlers).
 *  - Guarding all formatted values (no `.toFixed` on undefined).
 *
 * A11y:
 *  - Uses a native <button> with role="switch" and aria-checked.
 *  - Focus ring meets our tokens (Radiant Aqua).
 *
 * Design tokens (glass):
 *  - radius: 16px, backdrop-blur: 16px, background: rgba(255,255,255,0.12)
 *  - border: 1px solid rgba(255,255,255,0.25)
 */

import React from "react";
import { useVizStore } from "@/lib/state/useVizStore";

const HdrToggle: React.FC = () => {
  // ✅ Primitive selectors — these snapshots are stable between renders
  const hdr = useVizStore((s) => s.hdr);
  const toggleHDR = useVizStore((s) => s.toggleHDR);

  // Optional: show a small numeric hint without risk of NaN
  // (we use bloom as a proxy here only for display — safe formatting)
  const bloom = useVizStore((s) => s.params.bloom);
  const bloomText = Number.isFinite(bloom) ? (bloom as number).toFixed(2) : "—";

  // ✅ No state writes in render; changes occur *only* in event handlers
  const onToggle = () => toggleHDR();

  return (
    <button
      type="button"
      onClick={onToggle}
      role="switch"
      aria-checked={hdr}
      aria-label={hdr ? "Disable HDR effects" : "Enable HDR effects"}
      className={[
        // Glassmorphism surface
        "inline-flex items-center rounded-[16px] border border-[rgba(255,255,255,0.25)]",
        "bg-[rgba(255,255,255,0.12)] backdrop-blur-[16px] px-3 py-2",
        // Interaction + focus visibility per tokens
        "transition-transform active:scale-[0.98]",
        "focus:outline-none focus-visible:ring-2 focus-visible:ring-[#00F0FF]",
        // Subtle state cue
        hdr ? "opacity-100" : "opacity-80",
      ].join(" ")}
    >
      {hdr ? `HDR On (${bloomText})` : "HDR Off"}
    </button>
  );
};

export default HdrToggle;
</file>

<file path="src/components/visualizer/index.ts">
// src/components/visualizer/index.ts
/**
 * Visualizer Barrel
 * -----------------------------------------------------------------------------
 * PUBLIC CANVAS ENTRY (single source of truth):
 *   - SceneCanvas
 *
 * We intentionally do NOT export `WebGLCanvas` from the barrel to deprecate it.
 * Any legacy code importing `@/components/visualizer/WebGLCanvas` will still work
 * because that file shims to SceneCanvas, but new code should only import SceneCanvas
 * from here.
 */

// Canvas
export { default as SceneCanvas } from "./SceneCanvas";

// (Other visualizer-adjacent controls/components can live here or under settings)
// If you previously exported controls from this barrel, keep them here to avoid churn.
export { default as PresetSelector } from "./PresetSelector";
export { default as HdrToggle } from "./HdrToggle";
export { default as DimmerToggle } from "./DimmerToggle";

// NOTE: WebGLCanvas is intentionally NOT exported from this barrel.
// Please migrate to:
//   import { SceneCanvas } from "@/components/visualizer";
// or
//   import SceneCanvas from "@/components/visualizer/SceneCanvas";
</file>

<file path="src/components/visualizer/ParticlesCanvas.tsx">
// src/components/visualizer/ParticlesCanvas.tsx
import { useEffect, useRef } from 'react'
import { ParticlesField } from '@/lib/three/components/ParticlesField'

export const ParticlesCanvas = () => {
  const containerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (!containerRef.current) return

    const field = new ParticlesField(containerRef.current)
    const dispose = field.init()

    return () => {
      dispose?.()
    }
  }, [])

  return (
    <div
      ref={containerRef}
      aria-label="Audio-reactive visualizer"
      role="presentation"
      style={{
        position: 'absolute',
        inset: 0,
        zIndex: 0,
        pointerEvents: 'none',
        overflow: 'hidden'
      }}
    />
  )
}
</file>

<file path="src/components/visualizer/PresetSelector.tsx">
/**
 * Visualizer preset selector
 * - Keyboard friendly segmented control with roving behavior via left/right arrows
 * - Uses Zustand store for reading active preset and setting next preset
 * - Exports a default component, which the barrel re-exports as a named symbol
 */

import React, { useMemo, useCallback } from "react";
import { motion } from "framer-motion";
import { useVizStore } from "@/lib/state/useVizStore";
import type { VizPresetName } from "@/lib/three/VisualizerParams";

const PresetSelector: React.FC = () => {
  // Read active preset and setter from store
  const preset = useVizStore((s) => s.preset);
  const setPreset = useVizStore((s) => s.setPreset);

  // Get list once via getState to avoid unnecessary renders
  const presets = useMemo(() => {
    try {
      const list = useVizStore.getState().getPresetList?.() ?? [];
      return Array.isArray(list) ? list : [];
    } catch {
      return [];
    }
  }, []);

  // If list is empty, do not render a broken control
  if (!presets.length) return null;

  // Arrow left/right to move selection
  const onKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLDivElement>) => {
      if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;
      e.preventDefault();
      const idx = presets.indexOf(preset);
      const dir = e.key === "ArrowRight" ? 1 : -1;
      const next = presets[(idx + dir + presets.length) % presets.length];
      setPreset(next as VizPresetName);
    },
    [presets, preset, setPreset]
  );

  return (
    <div
      role="radiogroup"
      aria-label="Visualizer preset"
      className="eh-segment"
      onKeyDown={onKeyDown}
    >
      {presets.map((name) => {
        const selected = name === preset;
        return (
          <motion.button
            key={name}
            role="radio"
            aria-checked={selected}
            aria-label={name}
            className={`eh-segment__item ${selected ? "is-selected" : ""}`}
            onClick={() => setPreset(name as VizPresetName)}
            whileTap={{ scale: 0.98 }}
          >
            {name}
            <span className="sr-only">{selected ? "selected" : ""}</span>
          </motion.button>
        );
      })}
    </div>
  );
};

export default PresetSelector;
</file>

<file path="src/components/visualizer/SceneCanvas.tsx">
// src/components/visualizer/SceneCanvas.tsx
import React, { useCallback, useEffect, useRef, useState } from "react";
import * as THREE from "three";
import { useVizStore } from "@/lib/state/useVizStore";
import {
  type QualityTier,
  getPresetForTier,
} from "@/lib/visualizer/QualityPresets";

/**
 * SceneCanvas
 * -----------------------------------------------------------------------------
 * React wrapper for Three.js renderer/canvas lifecycle.
 *
 * Responsibilities:
 *  - Create and own a single THREE.WebGLRenderer instance (alpha, no MSAA).
 *  - Handle responsive sizing (ResizeObserver) and DPR capping.
 *  - Apply resolutionScale derived from QualityPresets/useVizStore.
 *  - Pause the animation loop when the tab is hidden (battery/perf).
 *  - Expose `onRendererReady` and `onFrame` hooks for Scene/Controller code.
 *
 * Notes:
 *  - Antialiasing: We keep `antialias: false` here; FXAA/TAA is expected to be
 *    handled by a post-processing pipeline (renderer layer) for consistency.
 *  - HDR: The renderer toggles will be applied in Scene/Controller; here we only
 *    expose the renderer and manage the core loop + sizing + DPR.
 *  - Accessibility: The canvas is marked aria-hidden and contained in a region
 *    with an aria-label for SR users. UI controls live outside this surface.
 *
 * Consumers:
 *  - Typically mounted by a `WebGLCanvas`/`VisualizerRoot` component that creates
 *    a SceneController which receives the renderer via `onRendererReady`.
 */

// --------------------------------- Types -------------------------------------

export interface SceneCanvasProps {
  className?: string;
  style?: React.CSSProperties;

  /**
   * Called once after the renderer is created and attached to the canvas.
   * Use this to construct your Scene/Camera/Controller and keep references.
   */
  onRendererReady?: (renderer: THREE.WebGLRenderer, canvas: HTMLCanvasElement) => void;

  /**
   * Called on every animation frame with delta time (seconds) and renderer.
   * Renderers with their own internal tick can ignore this.
   */
  onFrame?: (dt: number, renderer: THREE.WebGLRenderer) => void;

  /**
   * Force-pause the animation loop (debug/testing). Visibility changes also pause it.
   */
  paused?: boolean;
}

// --------------------------- DPR / Scale Helpers -----------------------------

/**
 * Map a quality tier to a maximum device pixel ratio cap.
 * These values are conservative to protect fill rate on lower tiers.
 */
const DPR_CAP_BY_TIER: Record<QualityTier, number> = {
  ultra: 2.0,
  high: 1.8,
  medium: 1.5,
  low: 1.25,
  fallback: 1.0,
};

/** Clamp helper. */
const clamp = (v: number, lo: number, hi: number) => (v < lo ? lo : v > hi ? hi : v);

/**
 * Compute the effective pixel ratio to apply to the renderer:
 *   effective = clamp(devicePixelRatio, 1, cap) * resolutionScale
 *
 * where cap is derived from the current quality tier and can be overridden by the store.
 */
function computeEffectivePixelRatio(opts: {
  devicePixelRatio: number;
  tier: QualityTier;
  resolutionScale: number;
  storeCap?: number; // optional user/store override
}): number {
  const baseCap = DPR_CAP_BY_TIER[opts.tier] ?? 1.5;
  const cap = Math.max(1, Math.min(4, opts.storeCap ?? baseCap));
  const dpr = clamp(opts.devicePixelRatio, 1, cap);
  const ratio = dpr * clamp(opts.resolutionScale, 0.5, 1.0);
  return Number.isFinite(ratio) ? ratio : 1;
}

// ------------------------------- Component -----------------------------------

const SceneCanvas: React.FC<SceneCanvasProps> = ({
  className,
  style,
  onRendererReady,
  onFrame,
  paused = false,
}) => {
  // DOM refs
  const rootRef = useRef<HTMLDivElement | null>(null);
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  // Renderer ref (lifetime of the component)
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);

  // RAF bookkeeping
  const rafRef = useRef<number | null>(null);
  const lastTRef = useRef<number | null>(null);
  const [webglSupported, setWebglSupported] = useState<boolean>(true);

  // ---------------------------- Store bindings -----------------------------

  // Quality/preset inputs (defensive: fall back to preset defaults if store fields missing)
  const qualityTier = useVizStore(
    (s) => ((s as any).qualityTier as QualityTier) ?? ("high" as QualityTier)
  );
  const pixelRatioMax = useVizStore((s) => (s as any).pixelRatioMax as number | undefined);
  const storeResolutionScale = useVizStore(
    (s) => (s as any).resolutionScale as number | undefined
  );

  // Prefer explicit value from store, otherwise compute from tier.
  const resolutionScale =
    typeof storeResolutionScale === "number"
      ? storeResolutionScale
      : getPresetForTier(qualityTier).resolutionScale;

  // ------------------------------ Lifecycle -------------------------------

  /**
   * Initialize Three.js renderer once on mount.
   */
  useEffect(() => {
    if (typeof window === "undefined") return; // SSR guard
    const canvas = canvasRef.current;
    if (!canvas) return;

    // Detect WebGL support
    try {
      const test = canvas.getContext("webgl2") || canvas.getContext("webgl");
      if (!test) {
        setWebglSupported(false);
        return;
      }
    } catch {
      setWebglSupported(false);
      return;
    }

    // Create renderer (alpha for glass; no MSAA here — use post for AA)
    const renderer = new THREE.WebGLRenderer({
      canvas,
      alpha: true,
      antialias: false,
      depth: true,
      stencil: false,
      powerPreference: "high-performance",
      preserveDrawingBuffer: false,
      // failIfMajorPerformanceCaveat can block on some GPUs; omit for broader support
    });

    // Color space and clear
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setClearColor(0x000000, 0); // transparent
    renderer.autoClear = true;

    rendererRef.current = renderer;

    // Announce to any diagnostics/scene code listening for the renderer
    try {
      window.dispatchEvent(
        new CustomEvent("eh:viz:renderer:ready", { detail: { renderer, canvas } })
      );
    } catch {
      /* no-op */
    }

    // Notify consumer
    onRendererReady?.(renderer, canvas);

    return () => {
      // Cleanup on unmount
      try {
        if (rafRef.current !== null) {
          cancelAnimationFrame(rafRef.current);
          rafRef.current = null;
        }
        renderer.dispose();
      } catch {
        /* ignore */
      } finally {
        rendererRef.current = null;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  /**
   * ResizeObserver to fit renderer to container size.
   */
  useEffect(() => {
    if (!rendererRef.current) return;
    const root = rootRef.current;
    if (!root) return;

    const ro = new ResizeObserver(() => {
      const { clientWidth: w, clientHeight: h } = root;
      if (!rendererRef.current) return;
      const dpr = computeEffectivePixelRatio({
        devicePixelRatio: window.devicePixelRatio || 1,
        tier: qualityTier,
        resolutionScale,
        storeCap: pixelRatioMax,
      });
      rendererRef.current.setPixelRatio(dpr);
      rendererRef.current.setSize(Math.max(1, w), Math.max(1, h), false);
    });

    ro.observe(root);

    // Initial size
    const { clientWidth: w, clientHeight: h } = root;
    const dpr = computeEffectivePixelRatio({
      devicePixelRatio: window.devicePixelRatio || 1,
      tier: qualityTier,
      resolutionScale,
      storeCap: pixelRatioMax,
    });
    rendererRef.current.setPixelRatio(dpr);
    rendererRef.current.setSize(Math.max(1, w), Math.max(1, h), false);

    return () => ro.disconnect();
  }, [qualityTier, resolutionScale, pixelRatioMax]);

  /**
   * Also respond to window DPR changes (zoom/monitor switch).
   */
  useEffect(() => {
    if (!rendererRef.current) return;

    const handleResize = () => {
      const root = rootRef.current;
      if (!root || !rendererRef.current) return;
      const dpr = computeEffectivePixelRatio({
        devicePixelRatio: window.devicePixelRatio || 1,
        tier: qualityTier,
        resolutionScale,
        storeCap: pixelRatioMax,
      });
      rendererRef.current.setPixelRatio(dpr);
      rendererRef.current.setSize(root.clientWidth || 1, root.clientHeight || 1, false);
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, [qualityTier, resolutionScale, pixelRatioMax]);

  /**
   * Visibility handling: pause when hidden, resume when visible.
   */
  const shouldRun = useRef<boolean>(true);
  useEffect(() => {
    const onVis = () => {
      shouldRun.current = document.visibilityState === "visible" && !paused;
      // Reset delta timer to avoid a huge frame after tab returns
      if (shouldRun.current) lastTRef.current = null;
      // Kick the loop if resuming
      if (shouldRun.current && rafRef.current === null) {
        rafRef.current = requestAnimationFrame(loop);
      }
    };
    document.addEventListener("visibilitychange", onVis);
    onVis(); // initialize
    return () => document.removeEventListener("visibilitychange", onVis);
  }, [paused]);

  /**
   * Animation loop: forwards delta to consumer; can be a no-op if consumer renders elsewhere.
   */
  const loop = useCallback(
    (t: number) => {
      rafRef.current = null;
      if (!rendererRef.current) return;

      if (!shouldRun.current || paused) {
        // Stay idle, but keep scheduling a low-frequency check to resume quickly when state flips.
        // (We do not use setTimeout to avoid throttling while hidden.)
        rafRef.current = requestAnimationFrame(loop);
        return;
      }

      const last = lastTRef.current ?? t;
      const dt = Math.min(0.1, Math.max(0, (t - last) / 1000)); // clamp dt to avoid spikes
      lastTRef.current = t;

      try {
        onFrame?.(dt, rendererRef.current);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.warn("[Ethereal Harmony] onFrame error:", err);
      }

      rafRef.current = requestAnimationFrame(loop);
    },
    [onFrame, paused]
  );

  /**
   * Start the RAF loop once the renderer exists.
   */
  useEffect(() => {
    if (!rendererRef.current) return;
    if (rafRef.current !== null) return;
    rafRef.current = requestAnimationFrame(loop);
    return () => {
      if (rafRef.current !== null) {
        cancelAnimationFrame(rafRef.current);
        rafRef.current = null;
      }
    };
  }, [loop]);

  // ------------------------------- Render ---------------------------------

  // If no WebGL, render a minimal placeholder (kept invisible by default).
  const fallback = !webglSupported ? (
    <div
      role="note"
      aria-live="polite"
      style={{
        position: "absolute",
        inset: 0,
        display: "grid",
        placeItems: "center",
        color: "rgba(255,255,255,0.85)",
        fontFamily: 'Lato, ui-sans-serif, system-ui, "Segoe UI", Roboto',
        fontSize: 14,
        background:
          "linear-gradient(135deg, rgba(26,43,69,0.92), rgba(127,106,159,0.85))",
      }}
    >
      WebGL is not supported on this device/browser.
    </div>
  ) : null;

  return (
    <section
      ref={rootRef}
      aria-label="Audio-reactive visualizer"
      className={className}
      style={{
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        // Allow UI on top to be interactive by default.
        ...style,
      }}
      data-testid="eh-scene-canvas"
    >
      {/* Three.js draws into this canvas */}
      <canvas
        ref={canvasRef}
        aria-hidden="true"
        style={{
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          display: "block",
          // Keep pointer events passthrough unless a scene needs interaction.
          pointerEvents: "none",
          // Perf hint
          willChange: "transform",
        }}
      />
      {fallback}
    </section>
  );
};

export default SceneCanvas;
</file>

<file path="src/lib/audio/AnalyserBus.ts">
// src/lib/audio/AnalyserBus.ts
/**
 * AnalyserBus (Phase 2)
 * -----------------------------------------------------------------------------
 * A tiny, allocation-conscious wrapper around the shared Web Audio AnalyserNode.
 *
 * Why this exists
 * - We want a single, stable surface that EVERY consumer (SceneController,
 *   meters, visual widgets) uses to sample audio data. That keeps our Web Audio
 *   graph simple and avoids each consumer touching the analyser directly.
 *
 * What it provides
 * - A lazily acquired AnalyserNode from the PlaybackController/AudioEngine.
 * - Stable, re-usable internal buffers to minimize per-frame allocations.
 * - A strict façade API that SceneController should use exclusively:
 *     • getFrequencyData(out: Uint8Array)
 *     • getTimeDomainData(out: Uint8Array | Float32Array)
 *   …plus convenience helpers for band energies and configuration:
 *     • sample(): { low, mid, high, rms }
 *     • sampleBands(bands: Array<[lowHz, highHz]>): number[]
 *     • setFFTSize(size), setSmoothing(value)
 *
 * Defaults (per build plan)
 * - FFT size: 2048 (=> 1024 frequency bins)
 * - Smoothing: 0.8
 *
 * Notes
 * - This module is framework-agnostic and safe to import anywhere (no React).
 * - The underlying AudioContext is created lazily by the engine when we ask
 *   for the analyser node for the first time.
 */

import { playbackController } from "@/lib/audio/PlaybackController";

export type BandEnergies = { low: number; mid: number; high: number; rms: number };

/** Clamp to [0,1]. */
const clamp01 = (n: number) => (n < 0 ? 0 : n > 1 ? 1 : n);
/** Coerce to a reasonable power-of-two FFT in [32..32768]. */
const toNearestPow2 = (n: number) => {
  const x = Math.max(32, Math.min(32768, Math.floor(n || 2048)));
  return 1 << Math.round(Math.log2(x));
};

class AnalyserBus {
  // ---- Node & buffers -------------------------------------------------------
  private analyser: AnalyserNode;

  /** Cached buffers to avoid allocations in animation frames. */
  private freqU8: Uint8Array;     // frequency domain [0..255]
  private timeU8: Uint8Array;     // time domain [0..255], optional path
  private timeF32: Float32Array;  // time domain [-1..1], preferred path

  // ---- Config (defaults per plan) ------------------------------------------
  private _fftSize = 2048;
  private _smoothing = 0.8;

  constructor() {
    // Acquire (and thereby lazily create) the engine/analyser.
    this.analyser = playbackController.getAnalyser();

    // Apply defaults
    this.analyser.fftSize = this._fftSize;
    this.analyser.smoothingTimeConstant = this._smoothing;

    // Allocate buffers sized to the node
    this.freqU8 = new Uint8Array(this.analyser.frequencyBinCount);
    this.timeU8 = new Uint8Array(this.analyser.fftSize);
    this.timeF32 = new Float32Array(this.analyser.fftSize);
  }

  // ==========================================================================
  // Public façade — SceneController should ONLY use these two methods
  // ==========================================================================

  /**
   * Write frequency-domain data into `out` (0..255). Length must be
   * >= analyser.frequencyBinCount. Extra capacity is ignored.
   */
  getFrequencyData(out: Uint8Array): void {
    // Fast-path: if caller provided correct length, write into it directly.
    if (out.length >= this.analyser.frequencyBinCount) {
      this.analyser.getByteFrequencyData(out);
      return;
    }
    // Otherwise, fill our cached buffer then copy what fits.
    this._readFreq();
    out.set(this.freqU8.subarray(0, out.length));
  }

  /**
   * Write time-domain data into `out`.
   * - If `out` is Float32Array, we use getFloatTimeDomainData (range ~[-1..1]).
   * - If `out` is Uint8Array, we use getByteTimeDomainData (range [0..255]).
   * Length must be >= analyser.fftSize. Extra capacity is ignored.
   */
  getTimeDomainData(out: Uint8Array | Float32Array): void {
    if (out instanceof Float32Array) {
      if (out.length >= this.analyser.fftSize) {
        this.analyser.getFloatTimeDomainData(out);
      } else {
        this._readTimeF32();
        out.set(this.timeF32.subarray(0, out.length));
      }
    } else {
      if (out.length >= this.analyser.fftSize) {
        this.analyser.getByteTimeDomainData(out);
      } else {
        this._readTimeU8();
        out.set(this.timeU8.subarray(0, out.length));
      }
    }
  }

  // ==========================================================================
  // Convenience: band energies + RMS
  // ==========================================================================

  /**
   * Returns low/mid/high band averages and RMS (all normalized to 0..1).
   * Bins:
   *   low: 20..250 Hz
   *   mid: 250..2000 Hz
   *   high: 2000..16000 Hz
   */
  sample(): BandEnergies {
    this._readFreq();
    this._readTimeF32();

    const sampleRate = this.analyser.context.sampleRate || 48000;
    const nyquist = sampleRate / 2;
    const bins = this.analyser.frequencyBinCount;

    const binForHz = (hz: number) =>
      Math.max(0, Math.min(bins - 1, Math.round((hz / nyquist) * (bins - 1))));

    const avgRange = (arr: Uint8Array, startHz: number, endHz: number) => {
      const a = binForHz(Math.min(startHz, endHz));
      const b = binForHz(Math.max(startHz, endHz));
      let sum = 0;
      const n = b - a + 1;
      for (let i = a; i <= b; i++) sum += arr[i];
      return n > 0 ? (sum / n) / 255 : 0;
    };

    const low = avgRange(this.freqU8, 20, 250);
    const mid = avgRange(this.freqU8, 250, 2000);
    const high = avgRange(this.freqU8, 2000, 16000);

    // RMS over float time data (already ~[-1..1])
    let sq = 0;
    const L = this.timeF32.length || 1;
    for (let i = 0; i < L; i++) {
      const v = this.timeF32[i];
      sq += v * v;
    }
    const rms = clamp01(Math.sqrt(sq / L));

    return { low, mid, high, rms };
  }

  /**
   * Return averages for a custom list of bands, each defined as [lowHz, highHz].
   * The returned values are normalized to 0..1 (byte scale).
   */
  sampleBands(bands: Array<[number, number]>): number[] {
    this._readFreq();

    const sampleRate = this.analyser.context.sampleRate || 48000;
    const nyquist = sampleRate / 2;
    const bins = this.analyser.frequencyBinCount;

    const binForHz = (hz: number) =>
      Math.max(0, Math.min(bins - 1, Math.round((hz / nyquist) * (bins - 1))));

    const out: number[] = new Array(bands.length);
    for (let j = 0; j < bands.length; j++) {
      const [lo, hi] = bands[j];
      const a = binForHz(Math.min(lo, hi));
      const b = binForHz(Math.max(lo, hi));
      let sum = 0;
      const n = b - a + 1;
      for (let i = a; i <= b; i++) sum += this.freqU8[i];
      out[j] = n > 0 ? (sum / n) / 255 : 0;
    }
    return out;
  }

  // ==========================================================================
  // Configuration
  // ==========================================================================

  /** Update FFT size (power of two). Buffers are reallocated accordingly. */
  setFFTSize(size: number) {
    const pow2 = toNearestPow2(size);
    if (pow2 === this._fftSize) return;
    this._fftSize = pow2;
    this.analyser.fftSize = pow2;
    this._reallocate();
  }

  /** Alias to match varied call sites. */
  setFftSize(size: number) {
    this.setFFTSize(size);
  }

  /** Update smoothing (0..1). */
  setSmoothing(value: number) {
    const v = clamp01(value);
    if (v === this._smoothing) return;
    this._smoothing = v;
    this.analyser.smoothingTimeConstant = v;
  }

  get fftSize() {
    return this._fftSize;
  }
  get smoothing() {
    return this._smoothing;
  }
  get frequencyBinCount() {
    return this.analyser.frequencyBinCount;
  }

  /** Escape hatch for advanced consumers (prefer using the façade). */
  getNode(): AnalyserNode {
    return this.analyser;
  }

  // ==========================================================================
  // Internal reads & buffer management
  // ==========================================================================

  /** Ensure freqU8 matches analyser.frequencyBinCount and fill it. */
  private _readFreq() {
    if (this.freqU8.length !== this.analyser.frequencyBinCount) {
      this.freqU8 = new Uint8Array(this.analyser.frequencyBinCount);
    }
    this.analyser.getByteFrequencyData(this.freqU8);
  }

  /** Ensure timeU8 matches analyser.fftSize and fill it. */
  private _readTimeU8() {
    if (this.timeU8.length !== this.analyser.fftSize) {
      this.timeU8 = new Uint8Array(this.analyser.fftSize);
    }
    this.analyser.getByteTimeDomainData(this.timeU8);
  }

  /** Ensure timeF32 matches analyser.fftSize and fill it. */
  private _readTimeF32() {
    if (this.timeF32.length !== this.analyser.fftSize) {
      this.timeF32 = new Float32Array(this.analyser.fftSize);
    }
    this.analyser.getFloatTimeDomainData(this.timeF32);
  }

  /** Reallocate all internal buffers after FFT size changes. */
  private _reallocate() {
    this.freqU8 = new Uint8Array(this.analyser.frequencyBinCount);
    this.timeU8 = new Uint8Array(this.analyser.fftSize);
    this.timeF32 = new Float32Array(this.analyser.fftSize);
  }
}

// Singleton export for app-wide use (one analyser bus for the entire app).
export const analyserBus = new AnalyserBus();
export default analyserBus;
</file>

<file path="src/lib/audio/AudioEngine.ts">
// src/lib/audio/AudioEngine.ts
/**
 * AudioEngine (Phase 2)
 * -----------------------------------------------------------------------------
 * Ownership:
 * - A single <audio> element (not necessarily in the DOM)
 * - A lazily-initialized AudioContext (to satisfy autoplay policies)
 *
 * Processing graph (stable, minimal latency):
 *   MediaElementSource -> [EQ?] -> [Limiter?] -> Gain (master) -> Destination
 *                                         \--> Analyser (post-fader tap)
 *
 * Responsibilities:
 * - Load and play local files and HTTPS URLs (with optional HLS handling)
 * - Provide transport controls: play/pause/toggle/seek/rate
 * - Provide volume/mute and (best-effort) output device switching (sinkId)
 * - Expose an AnalyserNode for visualizers/meters (AnalyserBus consumer)
 * - Offer optional EQ and Limiter integration (dynamic import, no hard dep)
 * - Emit lightweight events for stores/components to react to
 * - Be safe to import from anywhere (no React), with minimal side-effects
 *
 * Performance & UX:
 * - Lazy node creation (context, nodes) on first use
 * - Visibility-aware AudioContext power saving:
 *      • If tab becomes hidden and audio is NOT playing: suspend ctx
 *      • If tab becomes visible again: resume ctx
 *   (We do NOT auto-suspend while playing to avoid audible glitches.)
 *
 * Accessibility & Platform quirks:
 * - iOS/Safari user-gesture requirement: `play()` attempts to resume ctx first
 * - CrossOrigin='anonymous' is set to allow analyser and CORS-friendly streams
 *
 * Non-goals:
 * - This module intentionally does not manage queueing or Media Session metadata.
 *   That belongs in PlaybackController/MediaSession utility per the build plan.
 */

type Listener = (ev?: any) => void;

type EventMap = {
  play: void;
  pause: void;
  ended: void;
  error: { error?: unknown };
  timeupdate: { currentTime: number };
  durationchange: { duration: number };
  ratechange: { rate: number };
  volumechange: { volume: number; muted: boolean };
  loadedmetadata: { duration: number };
  loaded: { url: string };
  contextstate: { state: AudioContextState };
};

type OptionalEqGraph = {
  readonly bands: { freq: number; gain: number }[];
  setGain: (index: number, gain: number) => void;
  setBypassed: (b: boolean) => void;
  /** Output node of the EQ graph. Input is connected to it by AudioEngine. */
  node: AudioNode;
};

type OptionalLimiter = {
  node: AudioNode;
  setCeiling?: (db: number) => void;
};

type OptionalHlsController = {
  attach: (audio: HTMLMediaElement, url: string) => Promise<void> | void;
  destroy: () => void;
};

const clamp01 = (n: number) => (n < 0 ? 0 : n > 1 ? 1 : n);
const isHlsUrl = (u: string) => /\.m3u8(\?.*)?$/i.test(u);

/** Tiny event emitter (no deps). */
class Emitter<T extends Record<string, any>> {
  private map = new Map<keyof T, Set<Listener>>();
  on<K extends keyof T>(type: K, fn: (arg: T[K]) => void) {
    if (!this.map.has(type)) this.map.set(type, new Set());
    const set = this.map.get(type)!;
    set.add(fn as Listener);
    return () => set.delete(fn as Listener);
  }
  emit<K extends keyof T>(type: K, payload: T[K]) {
    const set = this.map.get(type);
    if (!set || set.size === 0) return;
    for (const fn of set) fn(payload);
  }
}

/**
 * AudioEngine
 * Singleton, framework-agnostic.
 */
export class AudioEngine {
  // ---- Singleton ------------------------------------------------------------
  private static _instance: AudioEngine | null = null;
  static get instance(): AudioEngine {
    if (!AudioEngine._instance) AudioEngine._instance = new AudioEngine();
    return AudioEngine._instance;
  }

  // ---- DOM/Media/AudioContext ----------------------------------------------
  private readonly audio: HTMLAudioElement;
  private ctx: AudioContext | null = null;
  private source: MediaElementAudioSourceNode | null = null;

  // ---- Nodes (lazy) ---------------------------------------------------------
  private gain: GainNode | null = null; // master volume (post limiter)
  private limiter: OptionalLimiter | null = null; // optional dynamics
  private limiterEnabled = true;
  private eq: OptionalEqGraph | null = null; // optional EQ
  private analyser: AnalyserNode | null = null;

  // ---- Playback / Device state ---------------------------------------------
  private _volume = 1;
  private _muted = false;
  private _rate = 1;
  private currentUrl: string | null = null;

  // ---- Optional integrations ------------------------------------------------
  private hls: OptionalHlsController | null = null; // only when using .m3u8

  // ---- Lifecycle helpers ----------------------------------------------------
  private visibilityHandlersAttached = false;
  private suspendedByVisibility = false;

  // ---- Emitter --------------------------------------------------------------
  private readonly events = new Emitter<EventMap>();

  // ---- Construction ---------------------------------------------------------
  private constructor() {
    // NOTE: we create the <audio> element immediately, but DO NOT create
    // the AudioContext until it's needed to satisfy autoplay policies.
    this.audio = document.createElement("audio");
    this.audio.preload = "metadata";
    this.audio.crossOrigin = "anonymous";
    this.audio.playsInline = true; // iOS

    // Proxy DOM media events to our emitter
    this.audio.addEventListener("play", () => this.events.emit("play", undefined));
    this.audio.addEventListener("pause", () => this.events.emit("pause", undefined));
    this.audio.addEventListener("ended", () => this.events.emit("ended", undefined));
    this.audio.addEventListener("error", () =>
      this.events.emit("error", { error: this.audio.error ?? new Error("Media error") })
    );
    this.audio.addEventListener("timeupdate", () =>
      this.events.emit("timeupdate", { currentTime: this.audio.currentTime || 0 })
    );
    this.audio.addEventListener("durationchange", () =>
      this.events.emit("durationchange", { duration: this.duration })
    );
    this.audio.addEventListener("loadedmetadata", () =>
      this.events.emit("loadedmetadata", { duration: this.duration })
    );
    this.audio.addEventListener("ratechange", () =>
      this.events.emit("ratechange", { rate: this.audio.playbackRate || 1 })
    );
    this.audio.addEventListener("volumechange", () =>
      this.events.emit("volumechange", { volume: this.audio.volume, muted: this.audio.muted })
    );
  }

  // ---- Public subscription API ---------------------------------------------
  on<K extends keyof EventMap>(type: K, fn: (ev: EventMap[K]) => void) {
    return this.events.on(type, fn);
  }

  // ---- Element accessors ----------------------------------------------------
  /** Returns the internal <audio> element (you may append it to the DOM). */
  get media(): HTMLAudioElement {
    return this.audio;
  }

  // ---- Core state accessors -------------------------------------------------
  get isPlaying() {
    return !this.audio.paused && !this.audio.ended;
  }
  get currentTime() {
    return this.audio.currentTime || 0;
  }
  get duration() {
    return Number.isFinite(this.audio.duration) ? this.audio.duration : 0;
  }
  get volume() {
    return this._volume;
  }
  get muted() {
    return this._muted;
  }
  get playbackRate() {
    return this._rate;
  }
  /** Exposes the AudioContext (created on demand). */
  get context(): AudioContext {
    if (!this.ctx) this.ensureContext();
    return this.ctx!;
  }

  // ---- Lazy context creation / graph wiring --------------------------------
  private ensureContext() {
    if (this.ctx) return this.ctx;

    const Ctor: typeof AudioContext = (window as any).AudioContext || (window as any).webkitAudioContext;
    if (!Ctor) throw new Error("Web Audio API not supported in this browser.");

    const ctx = new Ctor();
    this.ctx = ctx;

    // Master gain
    const gain = ctx.createGain();
    gain.gain.value = this._muted ? 0 : this._volume;
    this.gain = gain;

    // Limiter (gentle safety net)
    this.limiter = this.createLimiter(ctx);
    this.limiterEnabled = true;

    // Analyser (post-fader for consistent metering)
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.8;
    this.analyser = analyser;

    // Build tail of chain now (head will be connected when we create source)
    this.connectChain(null, analyser, this.limiterEnabled ? this.limiter?.node ?? null : null, gain, ctx.destination);

    // Visibility-aware power saving (attach once)
    this.attachVisibilityHandlers();

    // Bubble context state to consumers (useful for diagnostics overlay)
    ctx.onstatechange = () => this.events.emit("contextstate", { state: ctx.state });

    return ctx;
  }

  private connectChain(
    head: AudioNode | null,
    analyser: AudioNode | null,
    limiter: AudioNode | null,
    gain: AudioNode,
    destination: AudioNode
  ) {
    // Defensive disconnects (ignore failures)
    try {
      gain.disconnect();
    } catch {}
    try {
      limiter?.disconnect();
    } catch {}
    try {
      analyser?.disconnect();
    } catch {}

    // NOTE: We construct a linear path head -> [EQ?] -> [Limiter?] -> Gain -> Destination
    // and also tap Analyser from the Gain (post-fader).
    let last: AudioNode | null = head;

    const eqNode = this.eq?.node ?? null;

    const link = (from: AudioNode | null, to: AudioNode) => {
      if (from) from.connect(to);
      last = to;
    };

    if (last && eqNode) {
      link(last, eqNode);
      last = eqNode;
    }

    if (last && limiter) {
      link(last, limiter);
      last = limiter;
    }

    if (last) {
      link(last, gain);
    }

    // Gain -> Destination
    gain.connect(destination);

    // Gain -> Analyser (parallel)
    if (analyser) {
      gain.connect(analyser);
    }
  }

  private createSource() {
    if (!this.ctx) this.ensureContext();
    if (!this.ctx || this.source) return;

    this.source = this.ctx.createMediaElementSource(this.audio);
    // Rebuild the chain using new head
    this.connectChain(
      this.source,
      this.analyser!,
      this.limiterEnabled ? this.limiter?.node ?? null : null,
      this.gain!,
      this.ctx.destination
    );
  }

  private createLimiter(ctx: AudioContext): OptionalLimiter {
    // DynamicsCompressor configured as a transparent limiter-ish safety
    const node = ctx.createDynamicsCompressor();
    node.threshold.value = -1.0; // close to 0 dBFS
    node.knee.value = 30.0;
    node.ratio.value = 12.0;
    node.attack.value = 0.003;
    node.release.value = 0.250;
    return { node, setCeiling: (db: number) => (node.threshold.value = db) };
  }

  private async ensureEq(): Promise<void> {
    if (this.eq || !this.ctx) return;
    try {
      // Dynamic import keeps core slim if EQ isn’t needed/ready yet.
      const mod = (await import("./EQGraph").catch(() => null)) as any;
      if (mod && typeof mod.createEqGraph === "function") {
        this.eq = mod.createEqGraph(this.ctx);
        // Rewire chain to include EQ before limiter
        this.connectChain(
          this.source,
          this.analyser!,
          this.limiterEnabled ? this.limiter?.node ?? null : null,
          this.gain!,
          this.ctx.destination
        );
      }
    } catch {
      // EQ is optional; ignore failures
    }
  }

  // ---- Visibility-aware suspend/resume -------------------------------------
  private attachVisibilityHandlers() {
    if (this.visibilityHandlersAttached) return;
    this.visibilityHandlersAttached = true;

    const onVis = async () => {
      if (!this.ctx) return;
      if (document.hidden) {
        // Only suspend if NOT actively playing (saves power while idle)
        if (!this.isPlaying && this.ctx.state === "running") {
          try {
            await this.ctx.suspend();
            this.suspendedByVisibility = true;
            this.events.emit("contextstate", { state: this.ctx.state });
          } catch {}
        }
      } else {
        // Resume if we suspended due to visibility (or if someone wants analyser back)
        if (this.suspendedByVisibility && this.ctx.state === "suspended") {
          try {
            await this.ctx.resume();
            this.suspendedByVisibility = false;
            this.events.emit("contextstate", { state: this.ctx.state });
          } catch {}
        }
      }
    };

    document.addEventListener("visibilitychange", onVis);
  }

  // ---- Public controls ------------------------------------------------------
  /**
   * Load a URL (file or stream). If it's HLS (.m3u8), we try HlsController first
   * and fall back to native playback if supported by the browser.
   */
  async load(url: string): Promise<void> {
    const normalized = String(url || "").trim();
    if (!normalized) throw new Error("AudioEngine.load: invalid URL");
    this.currentUrl = normalized;

    // Destroy previous HLS session, if any
    if (this.hls) {
      try {
        this.hls.destroy();
      } catch {}
      this.hls = null;
    }

    // Ensure context & nodes are ready; create source node once
    this.ensureContext();
    this.createSource();

    if (isHlsUrl(normalized)) {
      // Try custom HLS controller (Chromium), fallback to native (Safari)
      try {
        const mod = (await import("@/lib/streaming/HlsController").catch(() => null)) as any;
        if (mod) {
          const hls: OptionalHlsController =
            typeof mod.default === "function" ? new mod.default() : (mod as OptionalHlsController);
          await Promise.resolve(hls.attach(this.audio, normalized));
          this.hls = hls;
        } else {
          // No controller available; attempt native (some browsers support HLS natively)
          this.audio.src = normalized;
        }
      } catch {
        this.audio.src = normalized;
      }
    } else {
      // Direct URL or blob
      this.audio.src = normalized;
    }

    this.events.emit("loaded", { url: normalized });
  }

  /**
   * Load a local File/Blob object (generates an object URL).
   * Callers are responsible for revoking the URL if they persist it externally.
   */
  async loadFile(file: File | Blob, fileName = "local"): Promise<void> {
    const url = URL.createObjectURL(file);
    await this.load(url);
    // Keep currentUrl marked as blob to help callers differentiate if needed
    this.currentUrl = `blob:${fileName}`;
  }

  /**
   * Resume the AudioContext if it exists and is suspended.
   * Useful to pre-unlock on a known user gesture (e.g., first click).
   */
  async resumeIfNeeded(): Promise<void> {
    if (!this.ctx) return;
    if (this.ctx.state === "suspended") {
      try {
        await this.ctx.resume();
        this.events.emit("contextstate", { state: this.ctx.state });
      } catch {}
    }
  }

  async play(): Promise<void> {
    // iOS/Safari unlock dance
    if (!this.ctx) this.ensureContext();
    if (this.ctx?.state === "suspended") {
      try {
        await this.ctx.resume();
        this.events.emit("contextstate", { state: this.ctx.state });
      } catch {}
    }
    this.createSource();
    await this.audio.play();
  }

  async pause(): Promise<void> {
    this.audio.pause();
  }

  async toggle(): Promise<void> {
    return this.isPlaying ? this.pause() : this.play();
  }

  seek(positionSec: number) {
    const d = this.duration || 0;
    if (d <= 0) return;
    this.audio.currentTime = Math.min(Math.max(0, positionSec), d);
  }

  setVolume(v: number) {
    const vol = clamp01(v);
    this._volume = vol;
    // Keep element volume in sync for HW keys & system UI
    this.audio.volume = vol;
    if (this.gain) this.gain.gain.value = this._muted ? 0 : vol;
    this.events.emit("volumechange", { volume: this.audio.volume, muted: this._muted });
  }

  setMuted(m: boolean) {
    this._muted = !!m;
    this.audio.muted = this._muted;
    if (this.gain) this.gain.gain.value = this._muted ? 0 : this._volume;
    this.events.emit("volumechange", { volume: this.audio.volume, muted: this._muted });
  }

  setRate(rate: number) {
    const r = Math.max(0.25, Math.min(4.0, rate || 1));
    this._rate = r;
    this.audio.playbackRate = r;
    this.events.emit("ratechange", { rate: r });
  }

  /**
   * Attempt to switch output device via sinkId (Chrome/Edge on secure origin).
   * No-op if unsupported.
   */
  async setOutputDevice(deviceId: string): Promise<void> {
    const el = this.audio as any;
    if (typeof el.setSinkId === "function") {
      try {
        await el.setSinkId(deviceId);
      } catch (err) {
        // Non-fatal; surface to console for diagnostics
        console.warn("[AudioEngine] setSinkId failed:", err);
      }
    }
  }

  // ---- Analyser access ------------------------------------------------------
  /** Returns the analyser node; creates the audio context on demand. */
  getAnalyser(): AnalyserNode {
    if (!this.ctx) this.ensureContext();
    return this.analyser!;
  }

  /** Convenience: fill frequency-domain data (0-255). */
  getFrequencyData(out: Uint8Array) {
    if (!this.analyser) this.getAnalyser();
    this.analyser!.getByteFrequencyData(out);
  }

  /** Convenience: fill time-domain (waveform) data (0-255). */
  getTimeDomainData(out: Uint8Array) {
    if (!this.analyser) this.getAnalyser();
    this.analyser!.getByteTimeDomainData(out);
  }

  // ---- EQ API (optional; no-ops if module not present) ---------------------
  async setEqGain(index: number, gainDb: number) {
    if (!this.ctx) this.ensureContext();
    if (!this.eq) await this.ensureEq();
    this.eq?.setGain(index, gainDb);
  }
  async setEqBypassed(b: boolean) {
    if (!this.ctx) this.ensureContext();
    if (!this.eq) await this.ensureEq();
    this.eq?.setBypassed(b);
  }
  getEqBands(): { freq: number; gain: number }[] {
    return this.eq?.bands ?? [];
  }

  // ---- Limiter control (optional enable/disable) ---------------------------
  setLimiterEnabled(enabled: boolean) {
    this.limiterEnabled = !!enabled;
    if (!this.ctx || !this.gain) return;
    // Rewire the chain with or without limiter
    this.connectChain(
      this.source,
      this.analyser!,
      this.limiterEnabled ? this.limiter?.node ?? null : null,
      this.gain,
      this.ctx.destination
    );
  }

  setLimiterCeiling(db: number) {
    this.limiter?.setCeiling?.(db);
  }

  // ---- Cleanup --------------------------------------------------------------
  async destroy() {
    // Stop playback & release media src
    try {
      this.audio.pause();
      this.audio.removeAttribute("src");
      this.audio.load();
    } catch {}

    // Tear down HLS if used
    try {
      this.hls?.destroy();
    } catch {}
    this.hls = null;

    // Disconnect head of the graph
    try {
      this.source?.disconnect();
    } catch {}
    this.source = null;

    // Close context (frees the hardware device)
    if (this.ctx) {
      try {
        this.ctx.onstatechange = null;
        await this.ctx.close();
        this.events.emit("contextstate", { state: "closed" as AudioContextState });
      } catch {}
      this.ctx = null;
    }

    // NOTE: We intentionally keep the <audio> element instance around. If you
    // really need to dispose it, do it at the app boundary after calling destroy().
  }
}

// Singleton export for convenience
export const audioEngine = AudioEngine.instance;
export default audioEngine;
</file>

<file path="src/lib/audio/DeviceManager.ts">
// src/lib/audio/DeviceManager.ts
/**
 * DEPRECATED SHIM
 * -----------------------------------------------------------------------------
 * Legacy import path kept temporarily to avoid breaking existing code.
 * Please migrate to:
 *   import outputDeviceManager from "@/lib/audio/OutputDeviceManager";
 *
 * This shim will be removed after all references are updated.
 */

export type { OutputDevice } from "./OutputDeviceManager";
export { OutputDeviceManager } from "./OutputDeviceManager";
export { outputDeviceManager as default } from "./OutputDeviceManager";
</file>

<file path="src/lib/audio/EQGraph.ts">
// src/lib/audio/EQGraph.ts
/**
 * EQGraph (Phase 2)
 * -----------------------------------------------------------------------------
 * A compact, dependency-free 10-band equalizer for the Web Audio API that
 * matches `AudioEngine.ensureEq()` expectations.
 *
 * Integration contract (must match AudioEngine.ensureEq):
 *   - Named export: `createEqGraph(ctx: AudioContext): EqGraph`
 *   - Returned object implements:
 *       • readonly bands: { freq: number; gain: number }[]
 *       • setGain(index: number, gainDb: number): void
 *       • setBypassed(b: boolean): void
 *       • node: AudioNode (the EQ chain as a single pluggable node)
 *
 * Usage in AudioEngine (already implemented):
 *   const mod = await import("./EQGraph");
 *   this.eq = mod.createEqGraph(this.ctx);
 *   // then the engine wires: source -> eq.node -> limiter -> gain -> dest
 *
 * Design
 * - Ten peaking filters at ISO-ish centers:
 *     [31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000] Hz
 * - Smooth gain transitions via `setTargetAtTime`.
 * - Bypass flips all filters to 0 dB without tearing down the chain.
 * - `bands` exposes live descriptors for UI (EqPanel) to render labels.
 *
 * Note on chaining
 * - The EQ is represented to the outside world as a single `node` so the
 *   engine can insert it into its fixed pipeline. Internally, we connect the
 *   10 filters in a chain and expose the “entry” that participates in the
 *   engine’s routing.
 */

export type EqBand = { freq: number; gain: number }; // gain in dB

export type EqGraph = {
  /** Live band descriptors (read-only references). */
  readonly bands: ReadonlyArray<EqBand>;
  /** Set gain (dB) for the band at `index` (clamped to [-12, +12]). */
  setGain: (index: number, gainDb: number) => void;
  /** Bypass on/off (true => neutral EQ). */
  setBypassed: (b: boolean) => void;
  /** Single node representing the entire EQ chain. */
  readonly node: AudioNode;
};

const CLAMP_DB_MIN = -12;
const CLAMP_DB_MAX = 12;
const clampDb = (v: number) => Math.max(CLAMP_DB_MIN, Math.min(CLAMP_DB_MAX, v));

/** Center frequencies for 10 bands (Hz). */
const DEFAULT_FREQS = [31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000];

/** Gentle Q mapping: narrower in mid bands, broader at extremes. */
const qForFreq = (f: number) => {
  if (f < 80) return 0.9;
  if (f < 160) return 1.0;
  if (f < 320) return 1.05;
  if (f < 640) return 1.1;
  if (f < 1280) return 1.15;
  if (f < 2560) return 1.1;
  if (f < 5120) return 1.05;
  if (f < 10240) return 1.0;
  return 0.9;
};

/**
 * Create a 10-band peaking EQ chain.
 * External chains should:
 *   source.connect(eq.node); eq.node.connect(next);
 */
export function createEqGraph(ctx: AudioContext, freqs: number[] = DEFAULT_FREQS): EqGraph {
  // Build peaking filters in natural order (low → high)
  const filters = freqs.map((f) => {
    const biquad = ctx.createBiquadFilter();
    biquad.type = "peaking";
    biquad.frequency.value = f;
    biquad.Q.value = qForFreq(f);
    biquad.gain.value = 0;
    return biquad;
  });

  // Wire filters in series (0 -> 1 -> 2 -> ... -> 9)
  for (let i = 0; i < filters.length - 1; i++) {
    filters[i].connect(filters[i + 1]);
  }

  // Public bands array (stable references for UI)
  const bands: EqBand[] = filters.map((f) => ({ freq: f.frequency.value, gain: 0 }));

  let bypassed = false;

  const setGain = (index: number, gainDb: number) => {
    const i = Math.max(0, Math.min(filters.length - 1, index | 0));
    const g = clampDb(gainDb);
    bands[i].gain = g;

    // If bypassed, keep internal biquad gains at 0 (neutral), but remember target gain.
    const target = bypassed ? 0 : g;
    const biquad = filters[i];
    const t = ctx.currentTime + 0.005; // tiny offset avoids zipper noise
    try {
      biquad.gain.cancelScheduledValues(0);
      biquad.gain.setTargetAtTime(target, t, 0.015);
    } catch {
      biquad.gain.value = target;
    }
  };

  const setBypassed = (b: boolean) => {
    if (b === bypassed) return;
    bypassed = b;
    const t = ctx.currentTime + 0.005;
    for (let i = 0; i < filters.length; i++) {
      const target = bypassed ? 0 : clampDb(bands[i].gain);
      try {
        filters[i].gain.cancelScheduledValues(0);
        filters[i].gain.setTargetAtTime(target, t, 0.02);
      } catch {
        filters[i].gain.value = target;
      }
    }
  };

  /**
   * Expose the EQ chain as a single node.
   * We use the *first* filter as the public node handle; it is wired to the rest
   * of the chain internally. The engine will treat this as a single inline node.
   */
  const node = filters[0];

  return { bands, setGain, setBypassed, node };
}

export default createEqGraph;
</file>

<file path="src/lib/audio/eqPresets.json">
{
  "version": 1,
  "centerFrequencies": [31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000],
  "presets": [
    { "name": "Flat", "gains": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] },
    { "name": "Rock", "gains": [4, 3, 2, 1, 0, 0, 1, 2, 3, 4] },
    { "name": "Pop", "gains": [0, 2, 3, 2, 0, -1, -1, 0, 2, 3] },
    { "name": "Electronic", "gains": [5, 4, 2, 0, -1, 0, 1, 3, 4, 5] },
    { "name": "Jazz", "gains": [-1, 0, 1, 2, 2, 2, 1, 0, -1, -2] },
    { "name": "Classical", "gains": [-2, -1, 0, 1, 2, 2, 1, 0, 1, 2] },
    { "name": "Acoustic", "gains": [0, 0, 1, 2, 2, 1, 1, 1, 0, 0] },
    { "name": "Bass Boost", "gains": [6, 5, 4, 2, 0, -1, -2, -3, -4, -5] },
    { "name": "Treble Boost", "gains": [-4, -3, -2, -1, 0, 1, 3, 4, 5, 6] },
    { "name": "Vocal Boost", "gains": [-4, -3, -1, 1, 3, 4, 3, 1, 0, -1] },
    { "name": "Lounge", "gains": [2, 1, 0, -1, 0, 0, 0, 1, 2, 3] }
  ]
}
</file>

<file path="src/lib/audio/Limiter.ts">
// src/lib/audio/Limiter.ts
/**
 * Limiter (Phase 2)
 * -----------------------------------------------------------------------------
 * Compact limiter built on Web Audio's DynamicsCompressorNode.
 *
 * Goals:
 *  - Provide a drop-in "node" that can sit in the engine chain:
 *        source -> [eq?] -> limiter.node -> gain -> destination
 *  - Ergonomic setters for common parameters with safe clamps.
 *  - Optional bypass that switches to a neutral transfer curve.
 *  - Zero external dependencies; framework-agnostic.
 *
 * Notes:
 *  - This module exposes ONLY a single node (DynamicsCompressorNode) so it can
 *    be inserted anywhere a normal AudioNode is expected.
 *  - If you need makeup gain, keep it in the engine's master gain stage to
 *    maintain a single-node limiter API (fits our chain and stores).
 */

export type Limiter = {
  /** The actual node to insert in your chain. */
  node: DynamicsCompressorNode;

  /** Set threshold/ceiling in dB (e.g., -1). */
  setCeiling: (db: number) => void;

  /** Set soft knee in dB (e.g., 30). */
  setKnee: (db: number) => void;

  /** Set compression ratio (e.g., 12 means 12:1). */
  setRatio: (ratio: number) => void;

  /** Set attack (seconds). Typical values: 0.002..0.01 */
  setAttack: (sec: number) => void;

  /** Set release (seconds). Typical values: 0.08..0.5 */
  setRelease: (sec: number) => void;

  /** Enable/disable processing (true => neutral curve). */
  setBypassed: (b: boolean) => void;

  /** Current gain reduction in dB (negative). */
  getReduction: () => number;
};

const clamp = (n: number, lo: number, hi: number) => Math.min(hi, Math.max(lo, n));

/** Create a limiter node with sensible defaults for music playback. */
export function createLimiter(ctx: AudioContext, opts?: Partial<{
  ceiling: number; // dB, default -1.0
  knee: number;    // dB, default 30
  ratio: number;   // unitless, default 12
  attack: number;  // seconds, default 0.003
  release: number; // seconds, default 0.250
  bypassed: boolean; // default false
}>): Limiter {
  const node = ctx.createDynamicsCompressor();

  // Defaults tuned for transparent peak limiting
  const ceiling = opts?.ceiling ?? -1.0;
  const knee = opts?.knee ?? 30.0;
  const ratio = opts?.ratio ?? 12.0;
  const attack = opts?.attack ?? 0.003;
  const release = opts?.release ?? 0.250;

  // Apply defaults (clamped to safe ranges of Web Audio)
  node.threshold.value = clamp(ceiling, -60, 0);
  node.knee.value = clamp(knee, 0, 40);
  node.ratio.value = clamp(ratio, 1, 20);
  node.attack.value = clamp(attack, 0.0005, 1);
  node.release.value = clamp(release, 0.02, 1);

  let bypassed = !!opts?.bypassed;

  // Neutral values cached so we can flip without losing user settings
  const live = {
    threshold: node.threshold.value,
    knee: node.knee.value,
    ratio: node.ratio.value,
    attack: node.attack.value,
    release: node.release.value,
  };

  // Neutral/"bypass" curve — effectively transparent
  const neutral = { threshold: 0, knee: 0, ratio: 1, attack: 0.001, release: 0.05 };

  const applyParams = (p: typeof live) => {
    const t = ctx.currentTime + 0.002; // tiny offset reduces zipper noise
    try {
      node.threshold.cancelScheduledValues(0);
      node.knee.cancelScheduledValues(0);
      node.ratio.cancelScheduledValues(0);
      node.attack.cancelScheduledValues(0);
      node.release.cancelScheduledValues(0);

      node.threshold.setTargetAtTime(p.threshold, t, 0.01);
      node.knee.setTargetAtTime(p.knee, t, 0.01);
      node.ratio.setTargetAtTime(p.ratio, t, 0.01);
      node.attack.setTargetAtTime(p.attack, t, 0.01);
      node.release.setTargetAtTime(p.release, t, 0.02);
    } catch {
      node.threshold.value = p.threshold;
      node.knee.value = p.knee;
      node.ratio.value = p.ratio;
      node.attack.value = p.attack;
      node.release.value = p.release;
    }
  };

  const api: Limiter = {
    node,

    setCeiling(db: number) {
      live.threshold = clamp(db, -60, 0);
      applyParams(bypassed ? neutral : live);
    },

    setKnee(db: number) {
      live.knee = clamp(db, 0, 40);
      applyParams(bypassed ? neutral : live);
    },

    setRatio(r: number) {
      live.ratio = clamp(r, 1, 20);
      applyParams(bypassed ? neutral : live);
    },

    setAttack(sec: number) {
      live.attack = clamp(sec, 0.0005, 1);
      applyParams(bypassed ? neutral : live);
    },

    setRelease(sec: number) {
      live.release = clamp(sec, 0.02, 1);
      applyParams(bypassed ? neutral : live);
    },

    setBypassed(b: boolean) {
      if (bypassed === b) return;
      bypassed = b;
      applyParams(bypassed ? neutral : live);
    },

    getReduction() {
      // Negative dB (e.g., -5.2). Some browsers expose reduction as AudioParam-like number.
      return typeof (node as any).reduction === "number" ? (node as any).reduction : 0;
    },
  };

  // Honor initial bypass
  if (bypassed) applyParams(neutral);

  return api;
}

export default createLimiter;
</file>

<file path="src/lib/audio/OutputDeviceManager.ts">
// src/lib/audio/OutputDeviceManager.ts
/**
 * OutputDeviceManager
 * -----------------------------------------------------------------------------
 * A small, framework-agnostic helper that manages audio **output devices**
 * (speakers / headphones) selection for Ethereal Harmony.
 *
 * Why this module?
 * - Browsers expose output routing for **HTMLMediaElement** via `setSinkId()`
 *   (Chromium, secure contexts). Our `AudioEngine` owns a single <audio> tag,
 *   so we can steer the app’s sound to any available output device *without*
 *   changing the Web Audio graph.
 *
 * What this does:
 * - Detects feature availability and secure-context constraints
 * - Enumerates `audiooutput` devices (with graceful permission prompting)
 * - Persists/re-applies the user’s preferred device across sessions
 * - Subscribes to device change events and validates the selected device
 * - Provides a clean API to set/get the current sink id (device id)
 *
 * What this does NOT do:
 * - It does not modify the Web Audio routing graph; all routing is through the
 *   <audio> element’s `setSinkId`. (AudioContext destination routing is not
 *   currently spec’d/implemented across browsers.)
 *
 * Permissions & privacy:
 * - Device labels are only revealed to the page once the user has granted a
 *   microphone permission at least once in the origin (browser rule). We do
 *   NOT store or stream any microphone audio; we can request a *silent* audio
 *   permission via `getUserMedia({ audio: true })` solely to unlock labels.
 *
 * SSR safety:
 * - All DOM and Web APIs are guarded. Calls that require the browser will no-op
 *   or resolve safely on the server.
 */

import audioEngine from "@/lib/audio/AudioEngine";

/* -------------------------------------------------------------------------------------------------
 * Types
 * ----------------------------------------------------------------------------------------------- */

export type OutputDevice = Pick<MediaDeviceInfo, "deviceId" | "kind" | "label" | "groupId"> & {
  /** Convenience: whether this entry represents the UA "default" output. */
  isDefault: boolean;
  /** Convenience: whether this entry represents the UA "communications" output. */
  isCommunications: boolean;
};

type Listener = (ev?: any) => void;

type EventMap = {
  /** Fired when the underlying device list changes (hotplug, permission, etc.). */
  deviceschanged: { devices: OutputDevice[] };
  /** Fired after a successful/failed attempt to change sink id. */
  sinkchange: { sinkId: string | null; ok: boolean; error?: unknown };
};

/* -------------------------------------------------------------------------------------------------
 * Tiny Emitter (dependency-free)
 * ----------------------------------------------------------------------------------------------- */

class Emitter<T extends Record<string, any>> {
  private map = new Map<keyof T, Set<Listener>>();
  on<K extends keyof T>(type: K, fn: (arg: T[K]) => void) {
    if (!this.map.has(type)) this.map.set(type, new Set());
    this.map.get(type)!.add(fn as Listener);
    return () => this.map.get(type)!.delete(fn as Listener);
  }
  emit<K extends keyof T>(type: K, payload: T[K]) {
    const set = this.map.get(type);
    if (!set) return;
    for (const fn of set) (fn as (p: T[K]) => void)(payload);
  }
}

/* -------------------------------------------------------------------------------------------------
 * Constants & helpers
 * ----------------------------------------------------------------------------------------------- */

const STORAGE_KEY = "eh.audio.sinkId.v1";

/** Narrow a MediaDeviceInfo to our OutputDevice shape with flags. */
function toOutputDevice(d: MediaDeviceInfo): OutputDevice {
  const id = d.deviceId || "";
  return {
    deviceId: id,
    kind: d.kind,
    label: d.label || "", // may be empty if permission not granted
    groupId: d.groupId || "",
    isDefault: id === "default",
    isCommunications: id === "communications",
  };
}

/** Check if we can call setSinkId on HTMLMediaElement in this runtime. */
function supportsSetSinkId(): boolean {
  if (typeof window === "undefined") return false;
  const proto = (HTMLMediaElement as any)?.prototype;
  return typeof proto?.setSinkId === "function";
}

/** Secure context is required for device enumeration and setSinkId in Chromium. */
function isSecureContextOk(): boolean {
  if (typeof window === "undefined") return false;
  // localhost is treated as secure in modern browsers; `window.isSecureContext` covers HTTPS.
  return Boolean((window as any).isSecureContext);
}

/** Persist/retrieve last chosen sink id. */
function readPersistedSinkId(): string | null {
  try {
    return localStorage.getItem(STORAGE_KEY);
  } catch {
    return null;
  }
}
function writePersistedSinkId(id: string | null) {
  try {
    if (!id) localStorage.removeItem(STORAGE_KEY);
    else localStorage.setItem(STORAGE_KEY, id);
  } catch {
    // ignore storage failures
  }
}

/* -------------------------------------------------------------------------------------------------
 * OutputDeviceManager
 * ----------------------------------------------------------------------------------------------- */

export class OutputDeviceManager {
  private static _instance: OutputDeviceManager | null = null;
  static get instance(): OutputDeviceManager {
    if (!OutputDeviceManager._instance) {
      OutputDeviceManager._instance = new OutputDeviceManager();
    }
    return OutputDeviceManager._instance;
  }

  private emitter = new Emitter<EventMap>();
  private devices: OutputDevice[] = [];
  private deviceChangeBound = false;

  /** Cached sink id applied to the audio element (best-effort reflection). */
  private currentSinkId: string | null = null;

  private constructor() {
    // Try to remember last chosen sink id (will be validated against device list).
    this.currentSinkId = readPersistedSinkId();

    // Attach devicechange listener when possible.
    this.attachDeviceChangeListener();
  }

  /* ----------------------------------------------------------------------------
   * Events
   * -------------------------------------------------------------------------- */

  on<K extends keyof EventMap>(type: K, fn: (arg: EventMap[K]) => void) {
    return this.emitter.on(type, fn);
  }

  /* ----------------------------------------------------------------------------
   * Capabilities
   * -------------------------------------------------------------------------- */

  /**
   * Returns true if the runtime supports `HTMLMediaElement.setSinkId`.
   * NOTE: Safari currently does not; Chromium-based browsers do (HTTPS only).
   */
  isAvailable(): boolean {
    return supportsSetSinkId() && isSecureContextOk();
  }

  /**
   * Return true if the UA can enumerate devices (labels may still be empty until
   * the user grants microphone permission at least once).
   */
  canEnumerate(): boolean {
    if (typeof navigator === "undefined") return false;
    return !!navigator.mediaDevices?.enumerateDevices;
  }

  /* ----------------------------------------------------------------------------
   * Permissions
   * -------------------------------------------------------------------------- */

  /**
   * Attempt to unlock device *labels* by requesting a transient audio permission.
   * We **do not** use the stream; it is immediately stopped. This is optional,
   * but improves the UX for naming output devices in a picker.
   */
  async ensurePermissionForLabels(): Promise<boolean> {
    if (typeof navigator === "undefined") return false;
    const md = navigator.mediaDevices as MediaDevices | undefined;
    if (!md?.getUserMedia) return false;

    try {
      const stream = await md.getUserMedia({ audio: true, video: false });
      // Immediately stop tracks; we only needed the permission grant signal.
      stream.getTracks().forEach((t) => t.stop());
      return true;
    } catch {
      // User denied or device unavailable — we can still enumerate (labels hidden).
      return false;
    }
  }

  /* ----------------------------------------------------------------------------
   * Enumeration
   * -------------------------------------------------------------------------- */

  /**
   * Enumerate `audiooutput` devices. If permission hasn’t been granted,
   * labels may be empty strings. The returned list is **sorted** to keep
   * the "default" device first, followed by "communications", then others
   * alphabetically by label.
   */
  async listOutputs(): Promise<OutputDevice[]> {
    if (!this.canEnumerate()) return [];

    const list = await navigator.mediaDevices!.enumerateDevices();
    const outs = list.filter((d) => d.kind === "audiooutput").map(toOutputDevice);

    // Stable, helpful ordering.
    outs.sort((a, b) => {
      // default first
      if (a.isDefault !== b.isDefault) return a.isDefault ? -1 : 1;
      // communications second
      if (a.isCommunications !== b.isCommunications) return a.isCommunications ? -1 : 1;
      // then alphabetically by label (empty labels sink to the bottom)
      const la = a.label || "~";
      const lb = b.label || "~";
      return la.localeCompare(lb);
    });

    // Cache and notify if changed meaningfully
    const changed =
      outs.length !== this.devices.length ||
      outs.some((d, i) => d.deviceId !== this.devices[i]?.deviceId || d.label !== this.devices[i]?.label);

    this.devices = outs;
    if (changed) this.emitter.emit("deviceschanged", { devices: this.devices });

    return outs;
  }

  /** Return the last known device list without triggering a re-enumeration. */
  getCachedOutputs(): OutputDevice[] {
    return this.devices.slice();
  }

  /* ----------------------------------------------------------------------------
   * Selection (sink id)
   * -------------------------------------------------------------------------- */

  /**
   * Apply a specific output device (by `deviceId`) to the app’s media element.
   * - `deviceId` can be "default" or "communications", or a concrete id returned
   *   by `enumerateDevices`.
   * - On success, the selection is persisted and a `sinkchange` event fires.
   * - On failure, we keep the old selection and also emit `sinkchange` (ok:false).
   */
  async setSinkId(deviceId: string): Promise<void> {
    if (!this.isAvailable()) {
      this.emitter.emit("sinkchange", { sinkId: null, ok: false, error: new Error("setSinkId not available") });
      return;
    }

    const el = audioEngine.media as any;
    if (typeof el.setSinkId !== "function") {
      this.emitter.emit("sinkchange", { sinkId: null, ok: false, error: new Error("element has no setSinkId") });
      return;
    }

    try {
      await el.setSinkId(deviceId);
      this.currentSinkId = deviceId || null;
      writePersistedSinkId(this.currentSinkId);
      this.emitter.emit("sinkchange", { sinkId: this.currentSinkId, ok: true });
    } catch (err) {
      // Surface failure but do not modify persisted value
      this.emitter.emit("sinkchange", { sinkId: this.currentSinkId, ok: false, error: err });
    }
  }

  /**
   * Return the currently applied sink id if known. Note that there is no
   * standard `audio.sinkId` getter; we reflect the last *applied* value.
   */
  getSinkId(): string | null {
    return this.currentSinkId;
  }

  /**
   * Re-apply the persisted sink id (if any) against the current device set.
   * Call this on startup (after the audio engine has created its element) or
   * after device permission changes.
   */
  async reapplyPersistedSink(): Promise<void> {
    const persisted = readPersistedSinkId();
    if (!persisted) return;

    // Validate against current devices if we have them, otherwise attempt anyway.
    const outs = this.devices.length ? this.devices : await this.listOutputs();
    const exists = outs.some((d) => d.deviceId === persisted);

    if (!exists) {
      // Device disappeared; fall back to default and clear stored value.
      try {
        await this.setSinkId("default");
      } finally {
        // If default route applied successfully, we can clear persisted custom id.
        writePersistedSinkId(null);
      }
      return;
    }

    await this.setSinkId(persisted);
  }

  /* ----------------------------------------------------------------------------
   * Device change handling
   * -------------------------------------------------------------------------- */

  private attachDeviceChangeListener() {
    if (this.deviceChangeBound) return;
    if (typeof navigator === "undefined" || !navigator.mediaDevices?.addEventListener) return;

    const handler = async () => {
      await this.listOutputs();

      // If our persisted sink id vanished, try to fall back to "default".
      const persisted = readPersistedSinkId();
      if (persisted) {
        const exists = this.devices.some((d) => d.deviceId === persisted);
        if (!exists) {
          try {
            await this.setSinkId("default");
          } finally {
            writePersistedSinkId(null);
          }
        }
      }
    };

    navigator.mediaDevices.addEventListener("devicechange", handler);
    this.deviceChangeBound = true;
  }

  /* ----------------------------------------------------------------------------
   * Convenience: build simple UI options list for a picker
   * -------------------------------------------------------------------------- */

  /**
   * Returns a slim array for binding to a <select> or custom list:
   *   [{ value: deviceId, label: "Speakers (High Definition...)" }, ...]
   *
   * If labels are empty (no permission), we provide generic names.
   */
  async getOutputOptions(): Promise<Array<{ value: string; label: string }>> {
    const list = await this.listOutputs();
    return list.map((d) => {
      let label = d.label;
      if (!label) {
        // Provide a stable placeholder when labels are hidden
        if (d.isDefault) label = "System Default";
        else if (d.isCommunications) label = "Communications";
        else label = "Audio Output";
      }
      return { value: d.deviceId, label };
    });
  }
}

/* -------------------------------------------------------------------------------------------------
 * Singleton export for convenience
 * ----------------------------------------------------------------------------------------------- */

export const outputDeviceManager = OutputDeviceManager.instance;
export default outputDeviceManager;

/* -------------------------------------------------------------------------------------------------
 * Example usage (reference only; do not ship in production bundles):
 *
 *   // At startup:
 *   await outputDeviceManager.listOutputs();         // prime the cache
 *   await outputDeviceManager.reapplyPersistedSink(); // re-apply last selection
 *
 *   // Build a picker:
 *   const opts = await outputDeviceManager.getOutputOptions();
 *   // <select onChange={(e) => outputDeviceManager.setSinkId(e.target.value)}>
 *   //   {opts.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
 *   // </select>
 *
 *   // Subscribe to changes:
 *   const off = outputDeviceManager.on("deviceschanged", ({ devices }) => { ... });
 *   const off2 = outputDeviceManager.on("sinkchange", ({ sinkId, ok }) => { ... });
 *
 * Notes:
 * - For best UX, call `ensurePermissionForLabels()` once behind a user gesture
 *   (e.g., "Enable device names") so device labels become readable.
 * - `setSinkId` requires HTTPS (or localhost) and Chromium-based browsers.
 * - If `setSinkId` is not available, hide the output-switching UI gracefully.
 * ------------------------------------------------------------------------------------------------ */
</file>

<file path="src/lib/audio/PlaybackController.ts">
// src/lib/audio/PlaybackController.ts
/**
 * PlaybackController (Phase 2)
 * -----------------------------------------------------------------------------
 * High-level transport + queue orchestration layer for Ethereal Harmony.
 *
 * Goals
 * - Provide a small, framework-agnostic API to control playback and manage a queue.
 * - Glue `AudioEngine` to UI (stores, hotkeys) without leaking Web Audio details.
 * - Forward engine events + raise queue/track lifecycle events for subscribers.
 * - Optionally reflect Media Session metadata/actions (dynamic import).
 *
 * Design
 * - Pure TypeScript module, safe to import anywhere (no React).
 * - Minimal state: queue (Track[]), index, repeat/shuffle/autoplay flags.
 * - Defensive around async media operations; never throw on user actions.
 *
 * Integrations
 * - GlobalHotkeys should invoke the public controller methods (play/pause/prev/next/seek).
 * - UI components subscribe via `on('trackchange'|'queuechange'|...)` for updates.
 * - Settings or diagnostics can read engine time/duration via getters.
 */

import audioEngine, { AudioEngine } from "./AudioEngine";
import {
  Track,
  loadTrackFromFile,
  loadTrackFromUrl,
  revokeTrackResources,
} from "./TrackLoader";

/* =============================================================================
 * Types
 * ========================================================================== */

/** Events emitted by the controller. */
type PlaybackEventMap = {
  /** Fired when a new track is loaded into the engine (or cleared). */
  trackchange: { track: Track | null; index: number; queueLength: number };

  /** Queue was replaced/reordered/modified. */
  queuechange: { queueLength: number };

  /** Forwarded events from AudioEngine. */
  play: void;
  pause: void;
  ended: void;
  error: { error?: unknown };
  timeupdate: { currentTime: number };
  durationchange: { duration: number };
  ratechange: { rate: number };
  volumechange: { volume: number; muted: boolean };
  loadedmetadata: { duration: number };
};

type Listener<T> = (ev: T) => void;

export type RepeatMode = "off" | "one" | "all";

/* =============================================================================
 * Tiny Emitter (no deps)
 * ========================================================================== */

class Emitter<M extends Record<string, any>> {
  private map = new Map<keyof M, Set<Listener<any>>>();
  on<K extends keyof M>(type: K, fn: Listener<M[K]>) {
    if (!this.map.has(type)) this.map.set(type, new Set());
    this.map.get(type)!.add(fn as any);
    return () => this.off(type, fn);
  }
  off<K extends keyof M>(type: K, fn: Listener<M[K]>) {
    this.map.get(type)?.delete(fn as any);
  }
  emit<K extends keyof M>(type: K, payload: M[K]) {
    const set = this.map.get(type);
    if (!set || set.size === 0) return;
    for (const fn of set) (fn as Listener<M[K]>)(payload);
  }
}

/* =============================================================================
 * Helpers
 * ========================================================================== */

const clamp01 = (n: number) => (n < 0 ? 0 : n > 1 ? 1 : n);

/** Fisher–Yates in-place shuffle (returns new array). */
function shuffled<T>(arr: T[]): T[] {
  const out = arr.slice();
  for (let i = out.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [out[i], out[j]] = [out[j], out[i]];
  }
  return out;
}

/* =============================================================================
 * PlaybackController
 * ========================================================================== */

export class PlaybackController {
  private engine: AudioEngine;
  private events = new Emitter<PlaybackEventMap>();

  // Queue state
  private queue: Track[] = [];
  private index = -1; // -1 => empty queue

  // Behavior flags
  private autoplayNext = true;
  private repeat: RepeatMode = "off";
  private shuffle = false;

  // When shuffle is enabled we keep a derived play order to navigate deterministically.
  private playOrder: number[] = []; // array of queue indices in play order
  private orderPos = -1; // position within playOrder that corresponds to `index`

  constructor(engine: AudioEngine = audioEngine) {
    this.engine = engine;

    // Bridge engine events forward; apply controller behavior when ended.
    this.engine.on("play", () => this.events.emit("play", undefined));
    this.engine.on("pause", () => this.events.emit("pause", undefined));
    this.engine.on("ended", () => {
      this.events.emit("ended", undefined);
      void this.handleNaturalEnd();
    });
    this.engine.on("error", (e) => this.events.emit("error", e));
    this.engine.on("timeupdate", (e) => this.events.emit("timeupdate", e));
    this.engine.on("durationchange", (e) => this.events.emit("durationchange", e));
    this.engine.on("ratechange", (e) => this.events.emit("ratechange", e));
    this.engine.on("volumechange", (e) => this.events.emit("volumechange", e));
    this.engine.on("loadedmetadata", (e) => this.events.emit("loadedmetadata", e));
  }

  /* ----------------------------------------------------------------------------
   * Subscription API
   * -------------------------------------------------------------------------- */

  on<K extends keyof PlaybackEventMap>(type: K, fn: Listener<PlaybackEventMap[K]>) {
    return this.events.on(type, fn);
  }

  /* ----------------------------------------------------------------------------
   * Queue management
   * -------------------------------------------------------------------------- */

  /**
   * Replace the whole queue and optionally select the starting item.
   * Frees blob/object URLs of the old queue to avoid leaks.
   */
  setQueue(tracks: Track[], startIndex = 0) {
    // Cleanup previous queue resources
    this.queue.forEach((t) => revokeTrackResources(t));

    this.queue = tracks.slice();
    this.index = Math.min(Math.max(0, startIndex), this.queue.length - 1);

    // Rebuild play order
    this.rebuildPlayOrder();
    this.events.emit("queuechange", { queueLength: this.queue.length });

    return this.loadCurrent(true);
  }

  /** Append or insert a track. */
  addToQueue(track: Track, atEnd = true) {
    if (atEnd) this.queue.push(track);
    else this.queue.splice(Math.max(0, this.index), 0, track);

    this.rebuildPlayOrder(); // track indices changed
    this.events.emit("queuechange", { queueLength: this.queue.length });
  }

  /** Remove a track by index (with resource cleanup). */
  removeFromQueue(removeIndex: number) {
    if (removeIndex < 0 || removeIndex >= this.queue.length) return;
    const [removed] = this.queue.splice(removeIndex, 1);
    revokeTrackResources(removed);

    // Adjust current index & order position
    if (this.queue.length === 0) {
      this.index = -1;
      this.orderPos = -1;
      this.playOrder = [];
      this.events.emit("queuechange", { queueLength: 0 });
      this.emitTrackchange();
      return;
    }

    if (removeIndex < this.index) this.index -= 1;
    if (this.index >= this.queue.length) this.index = this.queue.length - 1;

    this.rebuildPlayOrder();
    this.events.emit("queuechange", { queueLength: this.queue.length });
    this.emitTrackchange();
  }

  /** Clear queue entirely. */
  clearQueue() {
    this.queue.forEach((t) => revokeTrackResources(t));
    this.queue = [];
    this.index = -1;
    this.playOrder = [];
    this.orderPos = -1;

    this.events.emit("queuechange", { queueLength: 0 });
    this.emitTrackchange();
  }

  /** Reorder a track from one position to another. */
  moveInQueue(from: number, to: number) {
    if (from === to) return;
    const len = this.queue.length;
    if (from < 0 || from >= len || to < 0 || to >= len) return;

    const [item] = this.queue.splice(from, 1);
    this.queue.splice(to, 0, item);

    // Update index depending on movement
    if (this.index === from) this.index = to;
    else if (from < this.index && to >= this.index) this.index -= 1;
    else if (from > this.index && to <= this.index) this.index += 1;

    this.rebuildPlayOrder();
    this.events.emit("queuechange", { queueLength: this.queue.length });
    this.emitTrackchange();
  }

  /** Return a copy of the queue. */
  getQueue() {
    return this.queue.slice();
  }

  get currentIndex() {
    return this.index;
  }

  getCurrentTrack(): Track | null {
    if (this.index < 0 || this.index >= this.queue.length) return null;
    return this.queue[this.index] || null;
  }

  hasNext() {
    if (this.queue.length === 0) return false;
    if (this.repeat === "one") return true; // will repeat same index
    if (this.shuffle) {
      return this.orderPos >= 0 && this.orderPos < this.playOrder.length - 1;
    }
    return this.index < this.queue.length - 1;
  }

  hasPrev() {
    if (this.queue.length === 0) return false;
    if (this.repeat === "one") return true;
    if (this.shuffle) {
      return this.orderPos > 0;
    }
    return this.index > 0;
  }

  /* ----------------------------------------------------------------------------
   * Navigation
   * -------------------------------------------------------------------------- */

  async nextTrack(autoplay = true) {
    if (this.queue.length === 0) return;

    if (this.repeat === "one") {
      // Same index
      await this.loadCurrent(autoplay);
      return;
    }

    if (this.shuffle) {
      if (this.orderPos < this.playOrder.length - 1) {
        this.orderPos += 1;
        this.index = this.playOrder[this.orderPos];
        await this.loadCurrent(autoplay);
      } else if (this.repeat === "all") {
        // Regenerate play order to avoid repeating the same sequence back-to-back
        this.rebuildPlayOrder(/* keepIndex */ true);
        this.orderPos = 0;
        this.index = this.playOrder[this.orderPos];
        await this.loadCurrent(autoplay);
      }
      return;
    }

    // Linear
    if (this.index < this.queue.length - 1) {
      this.index += 1;
      await this.loadCurrent(autoplay);
    } else if (this.repeat === "all") {
      this.index = 0;
      await this.loadCurrent(autoplay);
    }
  }

  async prevTrack(autoplay = true) {
    if (this.queue.length === 0) return;

    // If near the start of current track, restart it; else go to previous.
    if (this.engine.currentTime > 2) {
      this.seek(0);
      if (autoplay && !this.engine.isPlaying) await this.play();
      return;
    }

    if (this.repeat === "one") {
      await this.loadCurrent(autoplay);
      return;
    }

    if (this.shuffle) {
      if (this.orderPos > 0) {
        this.orderPos -= 1;
        this.index = this.playOrder[this.orderPos];
        await this.loadCurrent(autoplay);
      } else if (this.repeat === "all") {
        this.orderPos = this.playOrder.length - 1;
        this.index = this.playOrder[this.orderPos];
        await this.loadCurrent(autoplay);
      }
      return;
    }

    // Linear
    if (this.index > 0) {
      this.index -= 1;
      await this.loadCurrent(autoplay);
    } else if (this.repeat === "all") {
      this.index = this.queue.length - 1;
      await this.loadCurrent(autoplay);
    }
  }

  /** Jump to an arbitrary index in the queue. */
  async jumpTo(index: number, autoplay = true) {
    if (index < 0 || index >= this.queue.length) return;
    this.index = index;

    // Keep playOrder/orderPos consistent with the selected index.
    if (this.shuffle) {
      const pos = this.playOrder.indexOf(index);
      if (pos >= 0) this.orderPos = pos;
    } else {
      this.orderPos = this.index;
    }

    await this.loadCurrent(autoplay);
  }

  /* ----------------------------------------------------------------------------
   * Core loading
   * -------------------------------------------------------------------------- */

  private async loadCurrent(autoplay = true) {
    const track = this.getCurrentTrack();
    if (!track) {
      this.emitTrackchange();
      return;
    }

    try {
      await this.engine.load(track.url);
    } catch (err) {
      // Forward error and try to continue to next if autoplayNext is enabled
      this.events.emit("error", { error: err });
      if (this.autoplayNext) {
        await this.nextTrack(true);
        return;
      }
    }

    this.emitTrackchange();

    // Media Session (optional)
    this.updateMediaSession(track).catch(() => {});

    if (autoplay) {
      try {
        await this.engine.play();
      } catch {
        // Autoplay might be blocked; swallow
      }
    }
  }

  private emitTrackchange() {
    this.events.emit("trackchange", {
      track: this.getCurrentTrack(),
      index: this.index,
      queueLength: this.queue.length,
    });
  }

  /* ----------------------------------------------------------------------------
   * File/URL helpers
   * -------------------------------------------------------------------------- */

  /** Create a Track from a local File and replace the queue with it. */
  async loadFromFile(file: File, autoplay = true) {
    const track = await loadTrackFromFile(file);
    await this.setQueue([track], 0);
    if (!autoplay) await this.pause();
  }

  /** Create a Track from a URL and replace the queue with it. */
  async loadFromUrl(url: string, autoplay = true) {
    const track = await loadTrackFromUrl(url);
    await this.setQueue([track], 0);
    if (!autoplay) await this.pause();
  }

  /** Replace the current track with a new one (keeps position in queue). */
  async replaceCurrent(track: Track, autoplay = true) {
    if (this.index < 0) {
      this.queue = [track];
      this.index = 0;
      this.rebuildPlayOrder();
    } else {
      revokeTrackResources(this.queue[this.index]);
      this.queue[this.index] = track;
    }
    this.events.emit("queuechange", { queueLength: this.queue.length });
    await this.loadCurrent(autoplay);
  }

  /* ----------------------------------------------------------------------------
   * Transport passthrough
   * -------------------------------------------------------------------------- */

  play() {
    return this.engine.play();
  }
  pause() {
    return this.engine.pause();
  }
  toggle() {
    return this.engine.toggle();
  }

  /** Seek to an absolute time (seconds). */
  seek(seconds: number) {
    this.engine.seek(seconds);
  }

  /** Seek relative by delta seconds (negative for backwards). */
  seekBy(deltaSec: number) {
    const next = clamp01((this.engine.currentTime + deltaSec) / Math.max(this.engine.duration || 1, 1));
    this.engine.seek(next * (this.engine.duration || 0));
  }

  setRate(rate: number) {
    this.engine.setRate(rate);
  }
  setVolume(vol: number) {
    this.engine.setVolume(vol);
  }
  setMuted(m: boolean) {
    this.engine.setMuted(m);
  }

  get currentTime() {
    return this.engine.currentTime;
  }
  get duration() {
    return this.engine.duration;
  }
  get isPlaying() {
    return this.engine.isPlaying;
  }

  /** Progress in [0..1], guarded for NaN/Infinity. */
  get progress(): number {
    const d = this.duration || 0;
    if (d <= 0) return 0;
    const p = this.currentTime / d;
    return p < 0 ? 0 : p > 1 ? 1 : p;
  }

  /* ----------------------------------------------------------------------------
   * Devices / Analyser
   * -------------------------------------------------------------------------- */

  /** Best-effort output device switch via sinkId (Chromium/secure origin). */
  setOutputDevice(deviceId: string) {
    return this.engine.setOutputDevice(deviceId);
  }

  /** Expose analyser for visualizers/meters (AnalyserBus consumer). */
  getAnalyser() {
    return this.engine.getAnalyser();
  }

  /* ----------------------------------------------------------------------------
   * Behavior flags
   * -------------------------------------------------------------------------- */

  setAutoplayNext(enabled: boolean) {
    this.autoplayNext = !!enabled;
  }

  setRepeatMode(mode: RepeatMode) {
    this.repeat = mode === "one" || mode === "all" ? mode : "off";
  }

  setShuffle(enabled: boolean) {
    const next = !!enabled;
    if (next === this.shuffle) return;
    this.shuffle = next;
    this.rebuildPlayOrder(/* keepIndex */ true);
  }

  getRepeatMode(): RepeatMode {
    return this.repeat;
  }
  getShuffle(): boolean {
    return this.shuffle;
  }
  getAutoplayNext(): boolean {
    return this.autoplayNext;
  }

  /* ----------------------------------------------------------------------------
   * Media Session (optional)
   * -------------------------------------------------------------------------- */

  private async updateMediaSession(track: Track | null) {
    // Optional/soft dependency; avoid hard import for Phase 2
    try {
      const mod = await import("@/lib/utils/MediaSession").catch(() => null);
      if (!mod) return;

      const update =
        (mod as any).updateMediaSession ||
        (mod as any).default ||
        null;

      if (typeof update === "function") {
        update({
          title: track?.title ?? "Unknown title",
          artist: track?.artist ?? "",
          album: track?.album ?? "",
          artwork: track?.artworkUrl ? [{ src: track.artworkUrl, sizes: "512x512", type: "image/png" }] : [],
          actions: {
            play: () => this.play(),
            pause: () => this.pause(),
            nexttrack: () => this.nextTrack(true),
            previoustrack: () => this.prevTrack(true),
            seekto: (pos: number) => this.seek(pos),
            seekforward: (delta = 10) => this.seekBy(delta),
            seekbackward: (delta = 10) => this.seekBy(-delta),
          },
        });
      }
    } catch {
      // ignore
    }
  }

  /* ----------------------------------------------------------------------------
   * Natural end handling
   * -------------------------------------------------------------------------- */

  private async handleNaturalEnd() {
    if (!this.autoplayNext) return;

    // Repeat one → restart same track
    if (this.repeat === "one") {
      await this.seek(0);
      try {
        await this.play();
      } catch {}
      return;
    }

    // Advance to next based on shuffle/repeat rules
    if (this.hasNext()) {
      await this.nextTrack(true);
      return;
    }

    // At end of queue
    if (this.repeat === "all" && this.queue.length > 0) {
      if (this.shuffle) {
        this.rebuildPlayOrder(/* keepIndex */ false);
        this.orderPos = 0;
        this.index = this.playOrder[this.orderPos];
      } else {
        this.index = 0;
      }
      await this.loadCurrent(true);
    }
  }

  /* ----------------------------------------------------------------------------
   * Play order (shuffle support)
   * -------------------------------------------------------------------------- */

  /**
   * Build or rebuild the `playOrder` array according to shuffle setting.
   * - When shuffle is ON, we generate a shuffled list of queue indices.
   * - When shuffle is OFF, playOrder is linear [0..n-1].
   * - `keepIndex` keeps the current `index` and aligns `orderPos` to it.
   */
  private rebuildPlayOrder(keepIndex = true) {
    const n = this.queue.length;
    if (n === 0) {
      this.playOrder = [];
      this.orderPos = -1;
      return;
    }

    if (this.shuffle) {
      const indices = Array.from({ length: n }, (_, i) => i);
      const order = shuffled(indices);

      // Ensure current index appears at the current order position if we are keeping it.
      if (keepIndex && this.index >= 0) {
        const pos = order.indexOf(this.index);
        if (pos > 0) {
          // Swap so that current index is at position `orderPos` (or compute new orderPos)
          this.playOrder = order;
          this.orderPos = pos;
          return;
        }
      }

      this.playOrder = order;
      this.orderPos = Math.max(0, this.playOrder.indexOf(this.index));
    } else {
      this.playOrder = Array.from({ length: n }, (_, i) => i);
      this.orderPos = Math.min(Math.max(0, this.index), n - 1);
    }
  }

  /* ----------------------------------------------------------------------------
   * Cleanup
   * -------------------------------------------------------------------------- */

  async destroy() {
    this.clearQueue();
    await this.engine.destroy();
  }
}

/* =============================================================================
 * Singleton export (app-wide controller)
 * ========================================================================== */

export const playbackController = new PlaybackController();
export default playbackController;
</file>

<file path="src/lib/audio/TrackLoader.ts">
// src/lib/audio/TrackLoader.ts
/**
 * TrackLoader (Phase 2)
 * -----------------------------------------------------------------------------
 * Single-purpose helpers to create a playable Track object from:
 *  - a local File (File System / file input)
 *  - a remote URL (HLS or direct audio)
 *
 * Design:
 *  - No framework/runtime coupling; safe to import anywhere.
 *  - Produces a normalized `Track` record your store/UI can consume.
 *  - For local files, creates an object URL and exposes a `revokeTrackResources`
 *    helper to free it when no longer needed.
 *  - For remote URLs, normalizes scheme and optionally resolves duration by
 *    loading metadata off-DOM (best-effort with timeout).
 */

export type Track = {
  /** Stable identifier for UI lists and store */
  id: string;
  /** Display title (guessed from filename/URL if tags not parsed) */
  title: string;
  /** Optional artist/album/artwork (Phase 2: placeholders unless provided) */
  artist?: string;
  album?: string;
  artworkUrl?: string;

  /** Playable URL (file: object URL, remote: normalized URL) */
  url: string;

  /** Hints for UI / engine */
  duration?: number; // seconds, best-effort
  mime?: string;
  isStream?: boolean; // true for .m3u8 or content without fixed duration
  source: "local" | "remote";

  /** Internal resource bookkeeping */
  _objectUrl?: string; // for local files; use revokeTrackResources to cleanup
};

const ALLOWED_FILE_EXTS = [
  "mp3",
  "m4a",
  "aac",
  "flac",
  "wav",
  "ogg",
  "oga",
  "opus",
  "webm",
];

/** Guards ------------------------------------------------------------------ */

const isHls = (u: string) => /\.m3u8(\?.*)?$/i.test(u);

const normalizeUrl = (input: string): string => {
  const s = (input || "").trim();
  if (!s) return s;
  if (/^\/\//.test(s)) return `https:${s}`;
  if (/^https?:\/\//i.test(s)) return s;
  // If looks like a domain/path but missing scheme, assume https
  if (/^[a-z0-9.-]+\.[a-z]{2,}([/:?#].*)?$/i.test(s)) return `https://${s}`;
  return s;
};

const extOf = (name: string) => {
  const m = /\.([a-z0-9]+)$/i.exec(name);
  return m ? m[1].toLowerCase() : "";
};

const sanitizeTitle = (s: string) =>
  s
    .replace(/[?#].*$/, "") // strip query/hash
    .replace(/\/+$/, "") // drop trailing slash
    .split("/")
    .pop()
    ?.replace(/\.[a-z0-9]+$/i, "") // remove extension
    .replace(/[_-]+/g, " ")
    .trim() || "Unknown Title";

/** Duration probe using an off-DOM <audio> element (best-effort). */
async function probeDuration(url: string, timeoutMs = 7000): Promise<number | undefined> {
  return new Promise<number | undefined>((resolve) => {
    try {
      const audio = document.createElement("audio");
      audio.preload = "metadata";
      audio.crossOrigin = "anonymous";
      const onLoaded = () => {
        const d = Number.isFinite(audio.duration) ? audio.duration : undefined;
        cleanup();
        resolve(d);
      };
      const onError = () => {
        cleanup();
        resolve(undefined);
      };
      const cleanup = () => {
        audio.removeEventListener("loadedmetadata", onLoaded);
        audio.removeEventListener("error", onError);
        try {
          // release any network activity
          audio.removeAttribute("src");
          audio.load();
        } catch {}
      };
      const to = window.setTimeout(() => {
        cleanup();
        resolve(undefined);
      }, timeoutMs);
      audio.addEventListener("loadedmetadata", () => {
        window.clearTimeout(to);
        onLoaded();
      });
      audio.addEventListener("error", () => {
        window.clearTimeout(to);
        onError();
      });
      audio.src = url;
    } catch {
      resolve(undefined);
    }
  });
}

/** Public API --------------------------------------------------------------- */

/**
 * Load a Track from a local File.
 * - Creates an object URL (remember to call revokeTrackResources later).
 * - Guesses a display title from the filename.
 * - Sets `mime` from File.type when present.
 */
export async function loadTrackFromFile(file: File): Promise<Track> {
  if (!(file instanceof File)) {
    throw new Error("loadTrackFromFile: invalid File");
  }

  const ext = extOf(file.name);
  const okByExt = ALLOWED_FILE_EXTS.includes(ext);
  const okByMime = file.type ? file.type.startsWith("audio/") : false;

  if (!okByExt && !okByMime) {
    throw new Error(`Unsupported audio file type: "${file.name}"`);
  }

  const objectUrl = URL.createObjectURL(file);
  // Try best-effort duration for local files too (usually quick)
  const duration = await probeDuration(objectUrl, 4000);

  const track: Track = {
    id: makeId(),
    title: sanitizeTitle(file.name),
    artist: undefined,
    album: undefined,
    artworkUrl: undefined, // Phase 2: we don't parse embedded art yet
    url: objectUrl,
    duration,
    mime: file.type || mimeFromExt(ext),
    isStream: false,
    source: "local",
    _objectUrl: objectUrl,
  };

  return track;
}

/**
 * Load a Track from a remote URL (HLS or direct audio).
 * - Normalizes scheme (adds https:// when omitted).
 * - Detects HLS by file extension.
 * - Optionally probes duration for direct audio; HLS is flagged as stream.
 */
export async function loadTrackFromUrl(inputUrl: string): Promise<Track> {
  const url = normalizeUrl(inputUrl);
  if (!url) throw new Error("loadTrackFromUrl: empty URL");

  const hls = isHls(url);
  const duration = hls ? undefined : await probeDuration(url, 6500);

  const track: Track = {
    id: makeId(),
    title: sanitizeTitle(url),
    artist: undefined,
    album: undefined,
    artworkUrl: undefined,
    url,
    duration,
    mime: hls ? "application/vnd.apple.mpegurl" : undefined,
    isStream: hls || !Number.isFinite(duration as number),
    source: "remote",
  };

  return track;
}

/**
 * Release any resources held by a Track (e.g., object URL for local files).
 */
export function revokeTrackResources(track: Track): void {
  if (track._objectUrl) {
    try {
      URL.revokeObjectURL(track._objectUrl);
    } catch {
      // ignore
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (track as any)._objectUrl = undefined;
  }
}

/** Internal helpers --------------------------------------------------------- */

const mimeFromExt = (ext: string): string | undefined => {
  switch (ext) {
    case "mp3":
      return "audio/mpeg";
    case "m4a":
    case "aac":
      return "audio/aac";
    case "flac":
      return "audio/flac";
    case "wav":
      return "audio/wav";
    case "ogg":
    case "oga":
      return "audio/ogg";
    case "opus":
      return "audio/opus";
    case "webm":
      return "audio/webm";
    default:
      return undefined;
  }
};

let _seq = 0;
const makeId = () => `trk_${Date.now().toString(36)}_${(++_seq).toString(36)}`;

/** Default export for convenience */
const TrackLoader = {
  loadTrackFromFile,
  loadTrackFromUrl,
  revokeTrackResources,
};

export default TrackLoader;
</file>

<file path="src/lib/diagnostics/AdaptiveGuard.ts">
/**
 * src/lib/diagnostics/AdaptiveGuard.ts
 * Ethereal Harmony — Adaptive Performance Guard (Phase 1 aligned, Phase 2-ready)
 *
 * Purpose within the project:
 *  - Keep the app consistently smooth (55–60 FPS target on mid-range hardware)
 *    by *suggesting and applying* safe visualizer degradations/upgrades based
 *    on live performance signals — without touching audio behavior.
 *  - Centralize heuristics so Player UI, Visualizer, and Dev tooling do not
 *    duplicate logic. Everything routes through this guard.
 *
 * How it integrates (no tight coupling, privacy-safe):
 *  - Listens to PerfEvents.onTick() for rolling FPS + busy-percent signals.
 *  - Applies *visualizer* quality presets through useVizStore **if** the store
 *    exposes compatible actions. Otherwise, it broadcasts a CustomEvent
 *    "eh:viz:quality" with `{ preset: QualityTier }` for other modules to handle.
 *  - Never persists telemetry remotely; only localStorage for the feature toggle
 *    and the last chosen tier (so a reload stays consistent).
 *
 * Design choices:
 *  - Hysteresis control with sustained thresholds to avoid preset "flapping".
 *  - Conservative, one-way by default: degrade quickly on sustained jank, upgrade
 *    slowly after sustained headroom.
 *  - Defensive optional wiring: feature-detect store actions so this file remains
 *    compatible even if the visualizer store evolves (Phase 1 → Phase 2).
 *
 * Quality tiers (ordered best→least): "ultra" → "high" → "balanced" → "low" → "minimal".
 *  - We only *propose/apply* tier changes; exact shader/material parameters are
 *    owned by the visualizer layer (Three.js + post-FX). This guard passes a
 *    single preset key to avoid leaking renderer details into diagnostics.
 *
 * Events (documented contract):
 *  - Emits:  "eh:adaptive:state"  detail: { enabled: boolean, tier: QualityTier }
 *  - Emits:  "eh:adaptive:apply"  detail: { from: QualityTier, to: QualityTier, reason: string }
 *  - Emits:  "eh:viz:quality"     detail: { preset: QualityTier, reason?: string }   // fallback route
 *  - Listens: "eh:viz:stats"      detail: { enabled: boolean } (not required, but present for symmetry)
 *
 * SSR/rehydration safety:
 *  - Guards window/document/performance access.
 *  - No React dependencies; pure TS module with a singleton API.
 *
 * Accessibility:
 *  - N/A (non-visual service). Dev UI components (e.g., DevToggle) drive this guard.
 */

import PerfEvents from "@/lib/diagnostics/PerfEvents";
import { useVizStore } from "@/lib/state/useVizStore";
import { useUIStore } from "@/lib/state/useUIStore";

/* ---------------------------------- Types --------------------------------- */

export type QualityTier = "ultra" | "high" | "balanced" | "low" | "minimal";

type ApplyReason =
  | "boot"
  | "restored"
  | "degrade_fps_low"
  | "degrade_longframe"
  | "degrade_busy"
  | "upgrade_fps_headroom"
  | "manual";

/**
 * Snapshot of recent perf for decision making (derived from PerfEvents).
 */
type PerfSnapshot = {
  fpsAvg: number;
  longFrameRatio: number; // 0–1
  busyPct: number; // 0–100
};

/* --------------------------------- Config --------------------------------- */

/**
 * Targets and thresholds derived from product pillar:
 * "Performance First: maintain 55–60 FPS on mid-range hardware."
 */
const TARGET_FPS = 58; // "good" steady-state
const DOWNGRADE_FPS = 50; // sustained below => degrade one tier
const LONG_RATIO_BAD = 0.20; // >20% frames >50ms indicates jank
const BUSY_BAD = 30; // >30% long task time over last second

/**
 * Hysteresis windows:
 *  - Degrade fast on sustained issues (2s).
 *  - Upgrade slow after sustained headroom (5s).
 */
const DEGRADE_SUSTAIN_MS = 2000;
const UPGRADE_SUSTAIN_MS = 5000;

/** Dispatch preset to visualizer at most once per 250ms to avoid bursts. */
const APPLY_THROTTLE_MS = 250;

/** LocalStorage keys (local only; never remote). */
const LS_KEY_ENABLED = "eh.adaptive.enabled";
const LS_KEY_TIER = "eh.adaptive.tier";

/* --------------------------------- Helpers -------------------------------- */

const IS_BROWSER = typeof window !== "undefined" && typeof document !== "undefined";

const readLS = (k: string): string | null => (IS_BROWSER ? window.localStorage.getItem(k) : null);
const writeLS = (k: string, v: string) => {
  if (!IS_BROWSER) return;
  try {
    window.localStorage.setItem(k, v);
  } catch {
    // ignore quota
  }
};

const TIERS: QualityTier[] = ["ultra", "high", "balanced", "low", "minimal"];

const clampTier = (tier: QualityTier): QualityTier =>
  (TIERS.includes(tier) ? tier : "balanced") as QualityTier;

const tierDown = (tier: QualityTier): QualityTier => {
  const i = TIERS.indexOf(tier);
  return TIERS[Math.min(i + 1, TIERS.length - 1)];
};

const tierUp = (tier: QualityTier): QualityTier => {
  const i = TIERS.indexOf(tier);
  return TIERS[Math.max(i - 1, 0)];
};

/** Cheap dev flag (no dependency on Settings): mirrors DevToggle "eh.dev.mode". */
const isDevMode = (): boolean => (readLS("eh.dev.mode") === "true") || !!useUIStore.getState()?.devMode;

/* --------------------------- Store/Events bridging ------------------------ */

/**
 * Attempt to apply a preset via useVizStore if actions exist;
 * otherwise broadcast a "eh:viz:quality" CustomEvent for listeners.
 */
let lastAppliedAt = 0;
const applyPreset = (to: QualityTier, reason: ApplyReason) => {
  if (!IS_BROWSER) return;
  const now = performance.now ? performance.now() : Date.now();
  if (now - lastAppliedAt < APPLY_THROTTLE_MS) return;
  lastAppliedAt = now;

  const viz = useVizStore.getState() as any;

  // Preferred single action in the visualizer domain:
  const apply = typeof viz?.applyQualityPreset === "function" ? viz.applyQualityPreset : undefined;
  const setTier = typeof viz?.setQualityTier === "function" ? viz.setQualityTier : undefined;

  if (apply) {
    try {
      apply(to);
    } catch {}
  } else if (setTier) {
    try {
      setTier(to);
    } catch {}
  } else {
    // Fallback: broadcast event for any subscriber (SceneController, etc.)
    const evt = new CustomEvent("eh:viz:quality", {
      detail: { preset: to, reason },
      bubbles: false,
      cancelable: false,
      composed: false,
    });
    window.dispatchEvent(evt);
  }

  // Notify diagnostics listeners
  const appliedEvt = new CustomEvent("eh:adaptive:apply", {
    detail: { from: AdaptiveGuard.tier(), to, reason },
    bubbles: false,
  });
  window.dispatchEvent(appliedEvt);
};

/* ------------------------------- Decision core ---------------------------- */

let _enabled = false;
let _tier: QualityTier = clampTier((readLS(LS_KEY_TIER) as QualityTier) || "balanced");

// Hysteresis state
let degradeSince = 0;
let upgradeSince = 0;

const snapshotFromPerf = (detail: any): PerfSnapshot => {
  const fpsAvg = Number(detail?.rolling?.fpsAvg ?? detail?.fps ?? 0);
  const longFrameRatio = Number(detail?.rolling?.longFrameRatio ?? 0);
  const busyPct = Number(detail?.longTasks?.busyPct ?? 0);
  return { fpsAvg, longFrameRatio, busyPct };
};

const shouldDegrade = (snap: PerfSnapshot): boolean => {
  if (snap.fpsAvg <= DOWNGRADE_FPS) return true;
  if (snap.longFrameRatio >= LONG_RATIO_BAD) return true;
  if (snap.busyPct >= BUSY_BAD) return true;
  return false;
};

const shouldUpgrade = (snap: PerfSnapshot): boolean => {
  // Headroom: consistently meeting target with low long-task pressure
  if (snap.fpsAvg >= TARGET_FPS && snap.longFrameRatio < LONG_RATIO_BAD * 0.5 && snap.busyPct < BUSY_BAD * 0.5) {
    return true;
  }
  return false;
};

let unsubTick: (() => void) | null = null;

const onTick = (detail: any) => {
  if (!_enabled) return;

  const snap = snapshotFromPerf(detail);
  const now = performance.now ? performance.now() : Date.now();

  // Update hysteresis timers
  if (shouldDegrade(snap)) {
    if (degradeSince === 0) degradeSince = now;
    // reset upgrade path
    upgradeSince = 0;
  } else if (shouldUpgrade(snap)) {
    if (upgradeSince === 0) upgradeSince = now;
    // reset degrade path
    degradeSince = 0;
  } else {
    // neither path accumulates — decay both
    degradeSince = 0;
    upgradeSince = 0;
  }

  // Apply if timers sustained
  if (degradeSince && now - degradeSince >= DEGRADE_SUSTAIN_MS) {
    const next = tierDown(_tier);
    if (next !== _tier) {
      if (isDevMode()) console.info(`[AdaptiveGuard] Degrade ${_tier} → ${next}`, snap);
      _tier = next;
      writeLS(LS_KEY_TIER, _tier);
      applyPreset(_tier, "degrade_fps_low");
    }
    degradeSince = 0; // avoid multiple steps in one burst
    upgradeSince = 0;
    return;
  }

  if (upgradeSince && now - upgradeSince >= UPGRADE_SUSTAIN_MS) {
    const next = tierUp(_tier);
    if (next !== _tier) {
      if (isDevMode()) console.info(`[AdaptiveGuard] Upgrade ${_tier} → ${next}`, snap);
      _tier = next;
      writeLS(LS_KEY_TIER, _tier);
      applyPreset(_tier, "upgrade_fps_headroom");
    }
    upgradeSince = 0;
    degradeSince = 0;
  }
};

/* ------------------------------ Public API -------------------------------- */

export const AdaptiveGuard = {
  /**
   * Initialize without enabling adaptation. This binds listeners needed for
   * future toggles and may apply a restored preset to keep UX consistent.
   */
  init(): void {
    if (!IS_BROWSER) return;

    // Bind once: when PerfEvents emits, we might enable later.
    if (!unsubTick) {
      unsubTick = PerfEvents.onTick(onTick);
    }

    // Restore last tier immediately (non-destructive; visualizer can ignore)
    const restored = clampTier(((readLS(LS_KEY_TIER) as QualityTier) || _tier) as QualityTier);
    _tier = restored;

    // Try to apply the restored tier once at boot so visualizer starts right.
    // This is safe even if visualizer has not mounted yet: it falls back to event.
    applyPreset(_tier, "restored");

    if (isDevMode()) {
      console.info(`[AdaptiveGuard] Initialized. Restored tier: ${_tier}`);
    }
  },

  /** Enable adaptive decisions (persisted locally). */
  enable(): void {
    if (!IS_BROWSER) return;
    if (_enabled) return;
    _enabled = true;
    writeLS(LS_KEY_ENABLED, "true");
    // Emit state
    const evt = new CustomEvent("eh:adaptive:state", { detail: { enabled: true, tier: _tier } });
    window.dispatchEvent(evt);
    if (isDevMode()) console.info("[AdaptiveGuard] Enabled.");
  },

  /** Disable adaptive decisions (persisted locally). Keeps current tier. */
  disable(): void {
    if (!IS_BROWSER) return;
    if (!_enabled) return;
    _enabled = false;
    writeLS(LS_KEY_ENABLED, "false");
    degradeSince = 0;
    upgradeSince = 0;
    const evt = new CustomEvent("eh:adaptive:state", { detail: { enabled: false, tier: _tier } });
    window.dispatchEvent(evt);
    if (isDevMode()) console.info("[AdaptiveGuard] Disabled.");
  },

  /** Toggle with explicit boolean. */
  setEnabled(enabled: boolean): void {
    enabled ? this.enable() : this.disable();
  },

  /** Returns whether adaptation is active. */
  isEnabled(): boolean {
    return _enabled;
  },

  /** Current working tier (not necessarily applied if visualizer ignores it). */
  tier(): QualityTier {
    return _tier;
  },

  /**
   * Manually set a tier (e.g., from a settings panel). This overrides the
   * current value and applies immediately. Adaptation remains ON/OFF as is.
   */
  setTier(tier: QualityTier, reason: ApplyReason = "manual"): void {
    const clamped = clampTier(tier);
    if (clamped === _tier) return;
    _tier = clamped;
    writeLS(LS_KEY_TIER, _tier);
    applyPreset(_tier, reason);
    if (isDevMode()) console.info(`[AdaptiveGuard] Manual tier → ${_tier}`);
  },

  /**
   * Convenience: returns a static recommendation from a perf snapshot without
   * changing state — useful for dev overlays.
   */
  recommend(detail: any): { action: "degrade" | "upgrade" | "hold"; to: QualityTier } {
    const snap = snapshotFromPerf(detail);
    if (shouldDegrade(snap)) return { action: "degrade", to: tierDown(_tier) };
    if (shouldUpgrade(snap)) return { action: "upgrade", to: tierUp(_tier) };
    return { action: "hold", to: _tier };
  },

  /**
   * Expose to window.__EH_ADAPTIVE for console debugging.
   */
  installGlobal(): void {
    if (!IS_BROWSER) return;
    (window as any).__EH_ADAPTIVE = this;
  },
};

export default AdaptiveGuard;

/* ------------------------------ Auto-bootstrap ---------------------------- */
/**
 * The module self-initializes in the browser so that dev tooling and the
 * visualizer can rely on a consistent tier at startup. We respect a persisted
 * enabled flag but do not force it on.
 */
if (IS_BROWSER) {
  try {
    AdaptiveGuard.init();

    // Respect persisted ON/OFF
    const persistedEnabled = readLS(LS_KEY_ENABLED) === "true";
    if (persistedEnabled) AdaptiveGuard.enable();

    // Optional: listen to DevToggle's viz stats toggle (not required). If the
    // developer enables stats, we do NOT auto-enable adaptation — diagnostics
    // and adaptation are orthogonal. This is left for future wiring if desired.
    window.addEventListener(
      "eh:viz:stats",
      ((e: CustomEvent<{ enabled: boolean }>) => {
        // no-op for now; could auto-enable AdaptiveGuard in future if needed
        if (isDevMode()) {
          console.debug("[AdaptiveGuard] Received viz:stats", e.detail);
        }
      }) as EventListener as any
    );

    AdaptiveGuard.installGlobal();
  } catch (err) {
    // Non-fatal: diagnostics must never crash the app.
    if (isDevMode()) console.warn("[AdaptiveGuard] bootstrap error", err);
  }
}
</file>

<file path="src/lib/diagnostics/FpsGuard.ts">
// src/lib/diagnostics/FpsGuard.ts
// Purpose: Maintain 55–60 FPS by applying a conservative quality ladder.
// Order: disable bloom -> disable AA -> reduce particles -> reduce buffer scale.
// Includes hysteresis to avoid thrash. All mutations are pushed via callbacks,
// so this module stays decoupled from React and the Three scene controller.

type LadderControls = {
  /** Bloom on/off and strength setter */
  setBloomEnabled: (on: boolean) => void;
  /** Toggle anti‑aliasing (FXAA/SMAA) */
  setAaEnabled: (on: boolean) => void;
  /** Mutate particle count target (the visualizer should rebuild geometry off this) */
  setParticleBudget: (count: number) => void;
  /** Adjust offscreen buffer scale (e.g., renderer.setPixelRatio or composer ratio) */
  setBufferScale: (scale: number) => void;
  /** Read current budgets to compute next step */
  getState: () => {
    bloomEnabled: boolean;
    aaEnabled: boolean;
    particleBudget: number; // current target
    bufferScale: number; // 0.5..1
  };
};

export type FpsGuardOptions = {
  targetFps?: number; // default 58
  lowerHysteresis?: number; // default 55 (apply)
  upperHysteresis?: number; // default 59 (recover)
  windowSize?: number; // samples in rolling window; default 60 (approx 1s @60Hz)
  checkIntervalMs?: number; // throttle decisions; default 800ms
  minParticles?: number; // absolute floor
  maxParticles?: number; // optional for recovery
  minBufferScale?: number; // 0.5
  maxBufferScale?: number; // 1
};

export class FpsGuard {
  private rafId: number | null = null;
  private lastTs = 0;
  private fpsSamples: number[] = [];
  private lastDecision = 0;

  private opts: Required<FpsGuardOptions>;
  private ctl: LadderControls;
  private paused = false;
  private recovering = false;

  constructor(controls: LadderControls, opts: FpsGuardOptions = {}) {
    this.ctl = controls;
    this.opts = {
      targetFps: opts.targetFps ?? 58,
      lowerHysteresis: opts.lowerHysteresis ?? 55,
      upperHysteresis: opts.upperHysteresis ?? 59,
      windowSize: opts.windowSize ?? 60,
      checkIntervalMs: opts.checkIntervalMs ?? 800,
      minParticles: opts.minParticles ?? 8_000,
      maxParticles: opts.maxParticles ?? 120_000,
      minBufferScale: opts.minBufferScale ?? 0.5,
      maxBufferScale: opts.maxBufferScale ?? 1.0,
    };
  }

  start() {
    if (this.rafId !== null) return;
    this.lastTs = performance.now();
    const loop = (t: number) => {
      const dt = t - this.lastTs;
      this.lastTs = t;
      if (dt > 0) {
        const fps = 1000 / dt;
        this.recordFps(fps);
      }
      this.rafId = requestAnimationFrame(loop);
    };
    this.rafId = requestAnimationFrame(loop);
  }

  stop() {
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }

  pause(p: boolean) {
    this.paused = p;
  }

  private recordFps(fps: number) {
    const w = this.opts.windowSize;
    this.fpsSamples.push(Math.min(120, Math.max(1, fps)));
    if (this.fpsSamples.length > w) this.fpsSamples.shift();

    const now = performance.now();
    if (now - this.lastDecision < this.opts.checkIntervalMs) return;
    this.lastDecision = now;

    if (this.paused || this.fpsSamples.length < w * 0.5) return;

    const avg = this.fpsSamples.reduce((a, b) => a + b, 0) / this.fpsSamples.length;

    if (avg < this.opts.lowerHysteresis) {
      this.applyLadderDown();
      this.recovering = false;
      return;
    }

    if (avg > this.opts.upperHysteresis) {
      // Consider stepping back up cautiously
      this.applyLadderUp();
      this.recovering = true;
    }
  }

  private applyLadderDown() {
    const s = this.ctl.getState();

    // 1) Disable bloom
    if (s.bloomEnabled) {
      this.ctl.setBloomEnabled(false);
      return;
    }

    // 2) Disable AA
    if (s.aaEnabled) {
      this.ctl.setAaEnabled(false);
      return;
    }

    // 3) Reduce particles by ~12.5%
    if (s.particleBudget > this.opts.minParticles) {
      const next = Math.max(this.opts.minParticles, Math.floor(s.particleBudget * 0.875));
      this.ctl.setParticleBudget(next);
      return;
    }

    // 4) Reduce buffer scale by 0.05 steps
    if (s.bufferScale > this.opts.minBufferScale) {
      const next = Math.max(this.opts.minBufferScale, parseFloat((s.bufferScale - 0.05).toFixed(2)));
      this.ctl.setBufferScale(next);
      return;
    }
  }

  private applyLadderUp() {
    const s = this.ctl.getState();

    // Recover in reverse order, one step at a time
    // 4) Increase buffer scale
    if (s.bufferScale < this.opts.maxBufferScale) {
      const next = Math.min(this.opts.maxBufferScale, parseFloat((s.bufferScale + 0.05).toFixed(2)));
      this.ctl.setBufferScale(next);
      return;
    }

    // 3) Increase particles by ~12.5%
    if (s.particleBudget < this.opts.maxParticles) {
      const next = Math.min(this.opts.maxParticles, Math.floor(s.particleBudget * 1.125));
      this.ctl.setParticleBudget(next);
      return;
    }

    // 2) Re-enable AA
    if (!s.aaEnabled) {
      this.ctl.setAaEnabled(true);
      return;
    }

    // 1) Re-enable bloom
    if (!s.bloomEnabled) {
      // Let guard opt back in; UI can cap strength elsewhere.
      this.ctl.setBloomEnabled(true);
      return;
    }
  }

  getAverages() {
    const avg =
      this.fpsSamples.length === 0
        ? 0
        : this.fpsSamples.reduce((a, b) => a + b, 0) / this.fpsSamples.length;
    return { avg, samples: this.fpsSamples.length };
  }
}
</file>

<file path="src/lib/diagnostics/PerfEvents.ts">
/**
 * src/lib/diagnostics/PerfEvents.ts
 * Ethereal Harmony — Perf / Diagnostics Event Hub
 *
 * Purpose in the project:
 *  - Centralize light-weight, browser-native performance sampling (FPS, frame time,
 *    long tasks, JS heap) and broadcast it as CustomEvents so any part of the app
 *    (Visualizer overlay, Dev tools, player UI) can opt-in without tight coupling.
 *  - Zero external deps; SSR-safe; local-only; minimal CPU when disabled.
 *
 * How it fits with Phase 1 ↔ Phase 2:
 *  - Phase 1: Provides a safe diagnostics baseline the UI can subscribe to for
 *    development toggles. Works even if the visualizer is not mounted yet.
 *  - Phase 2: Visualizer can subscribe to `eh:perf:tick` to draw an FPS label or
 *    to show jank/heap hints. DevToggle uses `eh:viz:stats` to enable/disable
 *    sampling; this module listens to that event and starts/stops accordingly.
 *
 * Design choices:
 *  - EventTarget-based pub/sub (fire-and-forget; prevents render loops).
 *  - RAF loop sampling; throttled dispatch to avoid over-rendering diagnostics.
 *  - Rolling window stats (avg/min/max FPS; long-frame ratio).
 *  - Long Tasks API (if available) to approximate main thread busy %.
 *  - JS heap sampling (Chromium `performance.memory`) guarded by feature checks.
 *  - LocalStorage shadow values for persistence of developer toggles only.
 *
 * Events emitted (documented contract):
 *  - "eh:perf:tick"     detail: PerfTickPayload  (every 1/dispatchHz seconds)
 *  - "eh:perf:measure"  detail: PerfMeasureEvent (manual measures via helpers)
 *  - "eh:perf:state"    detail: { running: boolean }
 *
 * Events listened to:
 *  - "eh:viz:stats"     detail: { enabled: boolean }  // DevToggle/Settings
 *  - "visibilitychange"                                 // pause when hidden
 *
 * LocalStorage keys:
 *  - "eh.dev.showStats" : "true" | "false"  → auto-start on page load when true
 *
 * Security/Privacy:
 *  - No network calls, no telemetry. Everything stays on-device.
 */

type PerfTickPayload = {
  t: number;          // High-res timestamp (ms, same origin as performance.now)
  dt: number;         // Delta between frames (ms)
  fps: number;        // Instantaneous FPS from dt
  rolling: {
    fpsAvg: number;
    fpsMin: number;
    fpsMax: number;
    longFrameRatio: number; // % of frames in the window exceeding LONG_FRAME_MS
  };
  longTasks: {
    last1sMs: number;   // total long-task time in the last second
    busyPct: number;    // rough main-thread busy % over last second
  };
  memory?: {
    jsHeapUsed: number;
    jsHeapTotal: number;
    jsHeapLimit: number;
  };
};

type PerfMeasureEvent = {
  name: string;
  duration: number; // ms
  startTime: number; // ms
  endTime: number; // ms
};

const IS_BROWSER = typeof window !== "undefined" && typeof document !== "undefined";
const HAS_PERF = typeof performance !== "undefined";
const HAS_PO = typeof PerformanceObserver !== "undefined";

/** A "long" frame threshold. >50ms implies visible jank on 60Hz displays. */
const LONG_FRAME_MS = 50;

/** How often to dispatch a tick event (Hz). We still sample every frame. */
const DEFAULT_DISPATCH_HZ = 4;

/** Rolling FPS window size in frames (approx 2 seconds @ 60fps). */
const FPS_WINDOW_FRAMES = 120;

/* -------------------------------------------------------------------------- */
/*                              EventTarget setup                              */
/* -------------------------------------------------------------------------- */

/** Minimal EventTarget polyfill for SSR or legacy contexts. */
class SimpleTarget {
  private map = new Map<string, Set<EventListener>>();
  addEventListener(type: string, listener: EventListener) {
    if (!this.map.has(type)) this.map.set(type, new Set());
    this.map.get(type)!.add(listener);
  }
  removeEventListener(type: string, listener: EventListener) {
    this.map.get(type)?.delete(listener);
  }
  dispatchEvent(event: Event) {
    this.map.get(event.type)?.forEach((l) => {
      try {
        l.call(undefined, event);
      } catch {
        // swallow to keep diagnostics resilient
      }
    });
    return true;
  }
}

const _target: EventTarget =
  IS_BROWSER && "EventTarget" in window ? new EventTarget() : (new SimpleTarget() as unknown as EventTarget);

/** Helper to emit CustomEvent safely. */
const emit = <T>(type: string, detail: T) => {
  if (!IS_BROWSER) return;
  const evt = new CustomEvent<T>(type, { detail, bubbles: false, cancelable: false, composed: false });
  _target.dispatchEvent(evt);
  // Also dispatch on window so non-module listeners can subscribe if desired.
  window.dispatchEvent(evt);
};

/* -------------------------------------------------------------------------- */
/*                           Long Tasks (busy percent)                         */
/* -------------------------------------------------------------------------- */

type LTEntry = { t: number; d: number };
const longTaskWindow: LTEntry[] = [];
let po: PerformanceObserver | null = null;

/** Initialize Long Task observation (Chromium only). */
const initLongTasks = () => {
  if (!IS_BROWSER || !HAS_PO) return;
  try {
    po = new PerformanceObserver((list) => {
      // "longtask" has spec'd name; Chromium populates entries as PerformanceEntry with duration
      // @ts-expect-error – TS doesn't know "longtask" by default
      const entries: PerformanceEntry[] = list.getEntries();
      const now = performance.now();
      for (const e of entries) {
        const d = typeof e.duration === "number" ? e.duration : 0;
        longTaskWindow.push({ t: now, d });
      }
      // Trim to last 1 second
      const cutoff = now - 1000;
      while (longTaskWindow.length && longTaskWindow[0].t < cutoff) longTaskWindow.shift();
    });
    // @ts-expect-error – "longtask" is not in lib.dom.d.ts yet in some TS targets
    po.observe({ entryTypes: ["longtask"] });
  } catch {
    po = null;
  }
};

const getBusyLast1s = (): { last1sMs: number; busyPct: number } => {
  if (!HAS_PERF) return { last1sMs: 0, busyPct: 0 };
  const now = performance.now();
  const cutoff = now - 1000;
  // prune and sum
  let sum = 0;
  for (let i = longTaskWindow.length - 1; i >= 0; i--) {
    const it = longTaskWindow[i];
    if (it.t < cutoff) break;
    sum += it.d;
  }
  const busyPct = Math.max(0, Math.min(100, (sum / 1000) * 100));
  return { last1sMs: sum, busyPct };
};

/* -------------------------------------------------------------------------- */
/*                              FPS / RAF sampling                             */
/* -------------------------------------------------------------------------- */

let running = false;
let rafId = 0;
let lastTs = 0;
let lastDispatchTs = 0;
let dispatchIntervalMs = 1000 / DEFAULT_DISPATCH_HZ;

// Rolling FPS stats
const fpsBuf = new Float32Array(FPS_WINDOW_FRAMES);
let fpsIndex = 0;
let fpsFilled = 0;
let longFrameCount = 0;

/** Reset rolling stats. */
const resetStats = () => {
  fpsBuf.fill(0);
  fpsIndex = 0;
  fpsFilled = 0;
  longFrameCount = 0;
};

const sampleMemory = () => {
  // Non-standard (Chromium). Guarded by feature checks.
  const p: any = performance as any;
  const mem = p?.memory;
  if (!mem) return undefined;
  const { usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit } = mem;
  if (typeof usedJSHeapSize !== "number") return undefined;
  return {
    jsHeapUsed: usedJSHeapSize,
    jsHeapTotal: typeof totalJSHeapSize === "number" ? totalJSHeapSize : usedJSHeapSize,
    jsHeapLimit: typeof jsHeapSizeLimit === "number" ? jsHeapSizeLimit : usedJSHeapSize,
  };
};

const tick = (ts: number) => {
  if (!running) return;

  // First frame bootstrap
  if (lastTs === 0) lastTs = ts;
  const dt = Math.max(0, ts - lastTs);
  lastTs = ts;

  // Instant FPS (avoid div-by-zero)
  const fps = dt > 0 ? 1000 / dt : 0;

  // Long frame accounting (for rolling ratio)
  const isLong = dt > LONG_FRAME_MS;
  if (isLong) longFrameCount++;

  // Update rolling buffer
  fpsBuf[fpsIndex] = fps;
  fpsIndex = (fpsIndex + 1) % FPS_WINDOW_FRAMES;
  if (fpsFilled < FPS_WINDOW_FRAMES) fpsFilled++;

  const now = ts;
  const due = now - lastDispatchTs >= dispatchIntervalMs;

  if (due) {
    lastDispatchTs = now;

    // Aggregate rolling stats
    let sum = 0;
    let min = Number.POSITIVE_INFINITY;
    let max = 0;

    for (let i = 0; i < fpsFilled; i++) {
      const v = fpsBuf[i];
      sum += v;
      if (v < min) min = v;
      if (v > max) max = v;
    }
    const avg = fpsFilled > 0 ? sum / fpsFilled : 0;
    const longRatio = fpsFilled > 0 ? longFrameCount / fpsFilled : 0;

    const busy = getBusyLast1s();

    const payload: PerfTickPayload = {
      t: ts,
      dt,
      fps,
      rolling: {
        fpsAvg: avg,
        fpsMin: min === Number.POSITIVE_INFINITY ? 0 : min,
        fpsMax: max,
        longFrameRatio: longRatio,
      },
      longTasks: busy,
      memory: sampleMemory(),
    };

    emit<PerfTickPayload>("eh:perf:tick", payload);
  }

  rafId = requestAnimationFrame(tick);
};

/* -------------------------------------------------------------------------- */
/*                            Public API (singleton)                           */
/* -------------------------------------------------------------------------- */

const start = (opts?: { dispatchHz?: number }) => {
  if (!IS_BROWSER || !HAS_PERF) return;
  if (running) return;

  // Update throttle
  const hz = Math.max(1, Math.min(30, opts?.dispatchHz ?? DEFAULT_DISPATCH_HZ));
  dispatchIntervalMs = 1000 / hz;

  // Reset
  resetStats();
  lastTs = 0;
  lastDispatchTs = 0;

  // Init LT observer on first start
  if (!po) initLongTasks();

  running = true;
  emit("eh:perf:state", { running: true });
  rafId = requestAnimationFrame(tick);
};

const stop = () => {
  if (!IS_BROWSER) return;
  if (!running) return;
  running = false;
  if (rafId) cancelAnimationFrame(rafId);
  rafId = 0;
  emit("eh:perf:state", { running: false });
};

const isRunning = () => running;

/** Subscribe to a perf event on the internal target. Returns an unsubscribe fn. */
const on = <T = any>(type: string, handler: (ev: CustomEvent<T>) => void) => {
  const h = handler as EventListener;
  _target.addEventListener(type, h);
  return () => _target.removeEventListener(type, h);
};

/** Subscribe to ticks specifically (typed helper). */
const onTick = (handler: (detail: PerfTickPayload) => void) =>
  on<PerfTickPayload>("eh:perf:tick", (e) => handler(e.detail));

/** Emit a custom perf event with typed payload. */
const emitEvent = <T = any>(type: string, detail: T) => emit<T>(type, detail);

/* -------------------------- Measures / Marks API -------------------------- */

const safeMark = (name: string) => {
  if (!HAS_PERF || typeof performance.mark !== "function") return;
  try {
    performance.mark(name);
  } catch {
    // ignore malformed names
  }
};

const safeMeasure = (name: string, startMark?: string, endMark?: string) => {
  if (!HAS_PERF || typeof performance.measure !== "function") return;
  try {
    performance.measure(name, startMark, endMark);
  } catch {
    // ignore
  }
};

/**
 * Time a synchronous or async function and emit an "eh:perf:measure".
 */
const withMeasure = async <T>(
  name: string,
  fn: () => T | Promise<T>
): Promise<T> => {
  const t0 = HAS_PERF ? performance.now() : Date.now();
  try {
    const result = await fn();
    const t1 = HAS_PERF ? performance.now() : Date.now();
    const detail: PerfMeasureEvent = { name, duration: t1 - t0, startTime: t0, endTime: t1 };
    emit<PerfMeasureEvent>("eh:perf:measure", detail);
    return result;
  } catch (err) {
    const t1 = HAS_PERF ? performance.now() : Date.now();
    const detail: PerfMeasureEvent = { name: `${name}:error`, duration: t1 - t0, startTime: t0, endTime: t1 };
    emit<PerfMeasureEvent>("eh:perf:measure", detail);
    throw err;
  }
};

/* -------------------------- DevToggle / Visibility ------------------------ */

/**
 * Bind listeners so external toggles control sampling.
 * - "eh:viz:stats" { enabled } starts/stops the loop.
 * - page hidden → pause; visible → resume if it was enabled by user.
 */
let desiredEnabled = false; // user's intent (via toggle)
const bindToDevToggles = () => {
  if (!IS_BROWSER) return;

  // Respect persisted state
  desiredEnabled = window.localStorage.getItem("eh.dev.showStats") === "true";
  if (desiredEnabled) start();

  // DevToggle or Settings will dispatch this
  window.addEventListener("eh:viz:stats", ((e: CustomEvent<{ enabled: boolean }>) => {
    desiredEnabled = !!e.detail?.enabled;
    if (desiredEnabled) {
      // persist
      try {
        window.localStorage.setItem("eh.dev.showStats", "true");
      } catch {}
      start();
    } else {
      try {
        window.localStorage.setItem("eh.dev.showStats", "false");
      } catch {}
      stop();
    }
  }) as EventListener as any);

  // Visibility: pause sampling while hidden to reduce CPU
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      stop();
    } else if (desiredEnabled) {
      start();
    }
  });
};

/* ------------------------------- Global hook ------------------------------ */

/**
 * Install a global handle so other modules can access the singleton without
 * importing this file (useful for debugging from console).
 */
const installGlobal = () => {
  if (!IS_BROWSER) return;
  (window as any).__EH_PERF = PerfEvents;
};

/* ------------------------------- Public shape ----------------------------- */

export const PerfEvents = {
  /** Start sampling (no-op on server). */
  start,
  /** Stop sampling (no-op if not running). */
  stop,
  /** Whether the sampler is running. */
  isRunning,
  /** Subscribe to any perf event. Returns unsubscribe. */
  on,
  /** Subscribe to perf ticks specifically. Returns unsubscribe. */
  onTick,
  /** Emit a custom perf event. */
  emit: emitEvent,
  /** performance.mark wrapper (safe). */
  mark: safeMark,
  /** performance.measure wrapper (safe). */
  measure: safeMeasure,
  /** Measure a function (sync/async) and emit duration. */
  withMeasure,
  /** Bind visibility + dev toggle listeners. Safe to call multiple times. */
  bindToDevToggles,
  /** Expose to window.__EH_PERF for ad-hoc debugging. */
  installGlobal,
} as const;

export default PerfEvents;

/* ------------------------------ Auto-bootstrap ---------------------------- */
/**
 * Light auto-wiring:
 *  - Bind to dev toggles so the DevToggle panel controls sampling.
 *  - Expose global util for console debugging.
 */
if (IS_BROWSER) {
  try {
    bindToDevToggles();
    installGlobal();
  } catch {
    // Keep diagnostics non-fatal
  }
}
</file>

<file path="src/lib/diagnostics/PerfOverlay.ts">
/**
 * src/lib/diagnostics/PerfOverlay.ts
 * Ethereal Harmony — Lightweight Performance Overlay (Phase 1 aligned, Phase 2-ready)
 *
 * What this is:
 *  - A zero-dependency DOM overlay (non-React) that subscribes to PerfEvents
 *    and renders a compact glassmorphism diagnostics panel: FPS (inst/avg/min/max),
 *    long-frame ratio, long-task busy %, memory (when available), and the current
 *    AdaptiveGuard tier (if present). It never touches audio behavior.
 *
 * Why non-React?
 *  - The overlay must be available even when React trees remount or error
 *    boundaries reset. A tiny DOM singleton avoids re-renders and keeps the
 *    diagnostics loop isolated from app state, honoring our Performance-First pillar.
 *
 * How it integrates with the project:
 *  - PerfEvents (src/lib/diagnostics/PerfEvents.ts): this module listens to
 *    "eh:perf:tick" to update metrics. It also emits no new events.
 *  - DevToggle (src/components/diagnostics/DevToggle.tsx): when the "Visualizer FPS / stats"
 *    switch is toggled, it dispatches "eh:viz:stats" { enabled }. This overlay listens
 *    and shows/hides itself accordingly (plus persists the preference locally).
 *  - AdaptiveGuard (src/lib/diagnostics/AdaptiveGuard.ts): we read its current tier
 *    if the global hook is present, and display it. We do not control the guard.
 *
 * Design system alignment:
 *  - Glass tokens: radius 16px, blur 16px, bg rgba(255,255,255,0.12), border rgba(255,255,255,0.25)
 *  - Palette: #1A2B45 (bg), #7F6A9F (accent), #00F0FF (highlight)
 *  - Fonts (assumed globally loaded): Montserrat 700 for headings, Lato 400 for body
 *  - WCAG AA: readable font sizes, adequate contrast on a deep indigo base.
 *
 * Accessibility:
 *  - Overlay region has aria-label and role=region.
 *  - Live metrics are exposed via aria-live="polite" to assistive tech without spamming.
 *  - Keyboard users can focus the panel (tabindex=0); outline is visible.
 *
 * Privacy:
 *  - Local only. Uses localStorage to remember visibility/position. No telemetry.
 *
 * SSR / safety:
 *  - Guards window/document access. In SSR environments this file is inert.
 */

import PerfEvents from "@/lib/diagnostics/PerfEvents";

export type OverlayCorner = "top-left" | "top-right" | "bottom-left" | "bottom-right";

export type OverlayOptions = {
  /** Parent element to attach to; defaults to document.body */
  attachTo?: HTMLElement;
  /** Initial corner position; persisted in LS if changed by setPosition */
  position?: OverlayCorner;
  /** Start visible or not; if omitted we read persisted preference */
  visible?: boolean;
  /** Minimal mode renders only big FPS + tier line */
  mini?: boolean;
  /** Update rate for UI painting (sec). Data still sampled by PerfEvents. */
  uiHz?: number;
};

/* --------------------------------- Constants -------------------------------- */

const IS_BROWSER = typeof window !== "undefined" && typeof document !== "undefined";

const TOKENS = {
  radius: 16,
  blur: 16,
  bg: "rgba(255,255,255,0.12)",
  border: "1px solid rgba(255,255,255,0.25)",
  base: "#1A2B45",
  accent: "#7F6A9F",
  highlight: "#00F0FF",
};

const LS_VISIBLE = "eh.overlay.visible";
const LS_POSITION = "eh.overlay.pos";
const LS_MINI = "eh.overlay.mini";

/* --------------------------------- State ----------------------------------- */

type LatestPerf = {
  fps: number;
  fpsAvg: number;
  fpsMin: number;
  fpsMax: number;
  longRatio: number; // 0..1
  busyPct: number;   // 0..100
  memUsed?: number;
  memTotal?: number;
  memLimit?: number;
  t: number;
};

let mounted = false;
let container: HTMLElement | null = null;
let textLines: {
  title?: HTMLElement;
  line1?: HTMLElement;
  line2?: HTMLElement;
  line3?: HTMLElement;
  tier?: HTMLElement;
} = {};
let unsubTick: (() => void) | null = null;
let uiRaf = 0;
let lastUiPaint = 0;
let uiIntervalMs = 1000 / 6; // default 6 Hz UI refresh (data event may be 4 Hz)

let latest: LatestPerf | null = null;
let corner: OverlayCorner = "top-right";
let visible = false;
let mini = false;

/* ------------------------------- Utilities --------------------------------- */

const readLS = (k: string): string | null => (IS_BROWSER ? window.localStorage.getItem(k) : null);
const writeLS = (k: string, v: string) => {
  if (!IS_BROWSER) return;
  try {
    window.localStorage.setItem(k, v);
  } catch { /* ignore */ }
};

const formatMem = (bytes?: number) => {
  if (!bytes || bytes <= 0) return "—";
  // prefer MB for readability
  const mb = bytes / (1024 * 1024);
  if (mb < 1024) return `${mb.toFixed(1)} MB`;
  const gb = mb / 1024;
  return `${gb.toFixed(2)} GB`;
};

const getAdaptiveTier = (): string => {
  // Optional global exposed by AdaptiveGuard.installGlobal()
  const g = (window as any);
  if (g?.__EH_ADAPTIVE && typeof g.__EH_ADAPTIVE.tier === "function") {
    try {
      return g.__EH_ADAPTIVE.tier();
    } catch { /* ignore */ }
  }
  return "—";
};

const applyCorner = (el: HTMLElement, pos: OverlayCorner) => {
  el.style.top = "";
  el.style.right = "";
  el.style.bottom = "";
  el.style.left = "";

  const inset = "12px";
  switch (pos) {
    case "top-left":
      el.style.top = inset;
      el.style.left = inset;
      break;
    case "top-right":
      el.style.top = inset;
      el.style.right = inset;
      break;
    case "bottom-left":
      el.style.bottom = inset;
      el.style.left = inset;
      break;
    case "bottom-right":
      el.style.bottom = inset;
      el.style.right = inset;
      break;
  }
};

/* ------------------------------ DOM creation ------------------------------- */

const createContainer = (): HTMLElement => {
  const el = document.createElement("div");
  el.setAttribute("role", "region");
  el.setAttribute("aria-label", "Performance diagnostics overlay");
  el.setAttribute("aria-live", "polite");
  el.tabIndex = 0;

  Object.assign(el.style, {
    position: "fixed",
    zIndex: "9998",
    display: "flex",
    flexDirection: "column",
    gap: "4px",
    padding: "10px 12px",
    color: "#FFFFFF",
    background: TOKENS.bg,
    border: TOKENS.border,
    borderRadius: `${TOKENS.radius}px`,
    backdropFilter: `blur(${TOKENS.blur}px)`,
    WebkitBackdropFilter: `blur(${TOKENS.blur}px)`,
    boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
    fontFamily: "Lato, system-ui, sans-serif",
    pointerEvents: "auto", // interactive (focusable)
    minWidth: "220px",
    userSelect: "none",
  } as CSSStyleDeclaration);

  // Title
  const title = document.createElement("div");
  Object.assign(title.style, {
    fontFamily: "Montserrat, system-ui, sans-serif",
    fontWeight: "700",
    fontSize: "12px",
    letterSpacing: "0.5px",
    textTransform: "uppercase",
    color: TOKENS.highlight,
    marginBottom: "2px",
  } as CSSStyleDeclaration);
  title.textContent = "Perf (EH)";

  // Big line (FPS + Tier)
  const line1 = document.createElement("div");
  Object.assign(line1.style, {
    fontSize: "18px",
    lineHeight: "20px",
    fontWeight: "700",
    fontFamily: "Montserrat, system-ui, sans-serif",
  } as CSSStyleDeclaration);
  line1.textContent = "FPS — / Tier —";

  // Secondary lines
  const line2 = document.createElement("div");
  Object.assign(line2.style, {
    fontSize: "12.5px",
    opacity: "0.95",
  } as CSSStyleDeclaration);

  const line3 = document.createElement("div");
  Object.assign(line3.style, {
    fontSize: "12.5px",
    opacity: "0.95",
  } as CSSStyleDeclaration);

  // Tier tag (right)
  const tier = document.createElement("div");
  Object.assign(tier.style, {
    alignSelf: "flex-end",
    fontSize: "11px",
    padding: "2px 6px",
    borderRadius: "10px",
    border: TOKENS.border,
    background: "rgba(0,0,0,0.25)",
    color: TOKENS.highlight,
  } as CSSStyleDeclaration);
  tier.textContent = "Tier —";

  el.appendChild(title);
  el.appendChild(line1);
  el.appendChild(line2);
  el.appendChild(line3);
  el.appendChild(tier);

  textLines = { title, line1, line2, line3, tier };
  return el;
};

/* ----------------------------- Render / Update ----------------------------- */

const paint = () => {
  if (!container || !latest) return;

  const fps = latest.fps;
  const avg = latest.fpsAvg;
  const min = latest.fpsMin;
  const max = latest.fpsMax;
  const ratio = latest.longRatio;
  const busy = latest.busyPct;

  const tier = getAdaptiveTier();

  // Big line: FPS (instant) • Tier
  if (textLines.line1) {
    textLines.line1.textContent = `FPS ${fps.toFixed(0)}  •  Tier ${tier}`;
  }

  // Line 2: avg/min/max
  if (textLines.line2) {
    textLines.line2.textContent = `avg ${avg.toFixed(1)} / min ${min.toFixed(0)} / max ${max.toFixed(0)}`;
  }

  // Line 3: long frames & busy% + memory when available
  const longPct = (ratio * 100).toFixed(0);
  const mem = latest.memUsed ? ` • mem ${formatMem(latest.memUsed)} / ${formatMem(latest.memTotal)}` : "";
  if (textLines.line3) {
    textLines.line3.textContent = `long ${longPct}% • busy ${busy.toFixed(0)}%${mem}`;
  }

  // Tier badge
  if (textLines.tier) {
    textLines.tier.textContent = `Tier ${tier}`;
  }

  // Color hint based on FPS
  const healthy = fps >= 58;
  const warning = fps < 58 && fps >= 48;
  const danger = fps < 48;

  const color = danger ? "#FF6B6B" : warning ? "#FFD166" : TOKENS.highlight;
  if (textLines.line1) (textLines.line1.style as any).color = color;
};

const scheduleUi = () => {
  if (uiRaf) cancelAnimationFrame(uiRaf);
  const loop = (ts: number) => {
    if (!mounted) return;
    if (!lastUiPaint) lastUiPaint = ts;
    const due = ts - lastUiPaint >= uiIntervalMs;
    if (due) {
      paint();
      lastUiPaint = ts;
    }
    uiRaf = requestAnimationFrame(loop);
  };
  uiRaf = requestAnimationFrame(loop);
};

/* ------------------------------- Event wiring ------------------------------ */

const onPerfTick = (detail: any) => {
  latest = {
    fps: Number(detail?.fps ?? 0),
    fpsAvg: Number(detail?.rolling?.fpsAvg ?? detail?.fps ?? 0),
    fpsMin: Number(detail?.rolling?.fpsMin ?? 0),
    fpsMax: Number(detail?.rolling?.fpsMax ?? 0),
    longRatio: Number(detail?.rolling?.longFrameRatio ?? 0),
    busyPct: Number(detail?.longTasks?.busyPct ?? 0),
    memUsed: detail?.memory?.jsHeapUsed,
    memTotal: detail?.memory?.jsHeapTotal,
    memLimit: detail?.memory?.jsHeapLimit,
    t: Number(detail?.t ?? performance.now()),
  };
};

/** Reflect external toggle events from DevToggle/Settings */
const bindExternalToggles = () => {
  if (!IS_BROWSER) return;
  window.addEventListener(
    "eh:viz:stats",
    ((e: CustomEvent<{ enabled: boolean }>) => {
      const enabled = !!e.detail?.enabled;
      PerfOverlay.setVisible(enabled);
      writeLS(LS_VISIBLE, enabled ? "true" : "false");
    }) as EventListener as any
  );
};

/* --------------------------------- API ------------------------------------ */

export const PerfOverlay = {
  /**
   * Mount the overlay (idempotent). It will attach to the specified container
   * or to document.body. Visibility and position honor persisted values unless
   * overridden via options.
   */
  mount(opts?: OverlayOptions): void {
    if (!IS_BROWSER) return;
    if (mounted) return;

    const parent = opts?.attachTo ?? document.body;

    // Persistence
    const persistedVisible = readLS(LS_VISIBLE);
    const persistedPos = readLS(LS_POSITION);
    const persistedMini = readLS(LS_MINI);

    visible = typeof opts?.visible === "boolean" ? opts.visible : persistedVisible === "true";
    corner = opts?.position ?? ((persistedPos as OverlayCorner) || "top-right");
    mini = typeof opts?.mini === "boolean" ? opts.mini : persistedMini === "true";
    uiIntervalMs = 1000 / Math.max(1, Math.min(30, opts?.uiHz ?? 6));

    container = createContainer();
    applyCorner(container, corner);

    // Minimal mode hides detailed lines
    if (mini) {
      if (textLines.line2) textLines.line2.style.display = "none";
      if (textLines.line3) textLines.line3.style.display = "none";
    }

    parent.appendChild(container);
    container.style.display = visible ? "flex" : "none";

    unsubTick = PerfEvents.on("eh:perf:tick", (ev: CustomEvent<any>) => onPerfTick(ev.detail));

    bindExternalToggles();
    scheduleUi();

    mounted = true;
  },

  /** Unmount and cleanup. Safe to call multiple times. */
  unmount(): void {
    if (!IS_BROWSER) return;
    if (!mounted) return;

    if (uiRaf) cancelAnimationFrame(uiRaf);
    uiRaf = 0;
    lastUiPaint = 0;

    unsubTick?.();
    unsubTick = null;

    container?.remove();
    container = null;
    textLines = {};
    mounted = false;
  },

  /** Show/hide the overlay and persist preference. */
  setVisible(next: boolean): void {
    if (!IS_BROWSER) return;
    visible = !!next;
    if (container) container.style.display = visible ? "flex" : "none";
    writeLS(LS_VISIBLE, visible ? "true" : "false");
  },

  /** Move the overlay to a different corner and persist preference. */
  setPosition(pos: OverlayCorner): void {
    if (!IS_BROWSER) return;
    corner = pos;
    if (container) applyCorner(container, corner);
    writeLS(LS_POSITION, corner);
  },

  /** Toggle minimal mode (only big FPS line + tier tag). */
  setMini(next: boolean): void {
    if (!IS_BROWSER) return;
    mini = !!next;
    if (textLines.line2) textLines.line2.style.display = mini ? "none" : "block";
    if (textLines.line3) textLines.line3.style.display = mini ? "none" : "block";
    writeLS(LS_MINI, mini ? "true" : "false");
  },

  /** Update UI refresh rate (1..30 Hz). */
  setUiHz(hz: number): void {
    uiIntervalMs = 1000 / Math.max(1, Math.min(30, hz));
  },

  /** Returns whether the overlay is currently mounted. */
  isMounted(): boolean {
    return mounted;
  },

  /** Returns current visibility. */
  isVisible(): boolean {
    return visible;
  },
};

export default PerfOverlay;

/* ------------------------------ Auto-bootstrap ----------------------------- */
/**
 * If the developer previously enabled stats (DevToggle persists `eh.dev.showStats`),
 * auto-mount the overlay on page load to keep the workflow smooth.
 */
if (IS_BROWSER) {
  try {
    const wantStats = window.localStorage.getItem("eh.dev.showStats") === "true";
    if (wantStats) {
      // Defer to next tick so the app shell can set up global styles first.
      queueMicrotask(() => {
        PerfOverlay.mount({ visible: true, position: (readLS(LS_POSITION) as OverlayCorner) || "top-right" });
      });
    }
  } catch {
    // non-fatal
  }
}
</file>

<file path="src/lib/diagnostics/Probe.ts">
/**
 * src/lib/diagnostics/Probe.ts
 * Ethereal Harmony — Ultra-light diagnostics probes (Phase 1 aligned, Phase 2-ready)
 *
 * Purpose in the project:
 *  - Give us a tiny, dependency-free way to time code paths (sync/async), count events,
 *    and optionally surface those measurements to the shared PerfEvents hub without
 *    coupling UI or the audio engine. Probes are safe to ship in production — they
 *    become near-no-ops when disabled.
 *
 * How it fits with the rest:
 *  - PerfEvents (src/lib/diagnostics/PerfEvents.ts) already broadcasts periodic ticks
 *    and accepts custom "eh:perf:measure" events. Probe uses that pathway to publish
 *    granular measurements (decode time, shader compile time, queue ops, etc).
 *  - DevToggle (src/components/diagnostics/DevToggle.tsx) and localStorage flags
 *    control whether we *log* to the console. Measurements are still emitted so
 *    overlays can visualize them without spamming logs.
 *  - AdaptiveGuard (src/lib/diagnostics/AdaptiveGuard.ts) is independent; however a
 *    higher-level component could correlate Probe measurements with Guard decisions.
 *
 * Product pillars honored:
 *  - Performance First: near-zero overhead; O(1) map lookups; no allocations during
 *    hot loops beyond a single Date/performance.now() per measurement.
 *  - Accessibility by Design: N/A (non-visual). Any UI consuming Probe data must meet AA.
 *  - Privacy and Trust: Everything is local; no network I/O; events stay in-page.
 *
 * SSR & safety:
 *  - All window/performance/localStorage access is guarded.
 *  - If performance.now() is unavailable (very rare), we fall back to Date.now().
 *
 * API overview:
 *  - Probe.start(name[, meta]) → id      // manual timing (call end with same id)
 *  - Probe.end(id[, meta]) → duration
 *  - Probe.run(name, fn[, meta])         // times sync function
 *  - Probe.runAsync(name, fn[, meta])    // times async function (Promise)
 *  - Probe.mark(name[, meta])            // instant mark (count event)
 *  - Probe.count(name, delta=1)          // accumulate a counter (no timing)
 *  - Probe.flushCounts()                 // emit & reset counters
 *  - Probe.enabled([boolean])            // get/set console logging toggle (emission unaffected)
 *  - Probe.onMeasure(handler)            // subscribe to emitted measure events (returns unsubscribe)
 *  - Probe.installGlobal()               // expose window.__EH_PROBE for quick debugging
 *
 * Emitted event shape (via PerfEvents.emit("eh:perf:measure", detail)):
 *  {
 *    name: string;            // measurement name, e.g. "audio:decode"
 *    duration: number;        // ms (0 for mark / count)
 *    startTime: number;       // ms (perf clock)
 *    endTime: number;         // ms
 *    meta?: Record<string, any>;
 *    type: "measure" | "mark" | "count";
 *    count?: number;          // present when type === "count"
 *    id?: string;             // probe id for manual start/end pairs
 *  }
 */

import PerfEvents from "@/lib/diagnostics/PerfEvents";

/* ---------------------------------- Utils --------------------------------- */

const IS_BROWSER = typeof window !== "undefined";
const HAS_PERF = typeof performance !== "undefined" && typeof performance.now === "function";

const now = (): number => (HAS_PERF ? performance.now() : Date.now());

const readLS = (k: string): string | null => (IS_BROWSER ? window.localStorage.getItem(k) : null);
const writeLS = (k: string, v: string) => {
  if (!IS_BROWSER) return;
  try {
    window.localStorage.setItem(k, v);
  } catch {
    // ignore
  }
};

/** Cheap unique id (no crypto dependency). Good enough for session-local probes. */
let _seed = Math.floor(Math.random() * 1e6);
const uid = (prefix = "p"): string => `${prefix}-${(++_seed).toString(36)}-${Math.floor(now()).toString(36)}`;

/** Whether console logging of probe results is enabled (measure emission is independent). */
let _logEnabled = readLS("eh.probe.log") === "true";

/** Dev helper – logs only if enabled. */
const devLog = (...args: any[]) => {
  if (_logEnabled && typeof console !== "undefined") {
    // eslint-disable-next-line no-console
    console.log(...args);
  }
};

/* ---------------------------- Internal state ------------------------------ */

/** Active timing sessions: id → { name, t0, meta? } */
const active = new Map<
  string,
  { name: string; t0: number; meta?: Record<string, any> }
>();

/** Aggregated counters flushed on demand to a single event per name. */
const counters = new Map<string, number>();

/* ---------------------------- Event bridge (Perf) ------------------------- */

type MeasureDetail = {
  name: string;
  duration: number;
  startTime: number;
  endTime: number;
  meta?: Record<string, any>;
  type: "measure" | "mark" | "count";
  count?: number;
  id?: string;
};

const emitMeasure = (detail: MeasureDetail) => {
  // Always emit through PerfEvents so dev overlays can subscribe.
  PerfEvents.emit<MeasureDetail>("eh:perf:measure", detail);
};

/* --------------------------------- API ------------------------------------ */

export const Probe = {
  /**
   * Manually start a probe.
   * Returns a session id you *must* pass to `end`. If a name/id pair is reused,
   * the previous session is overwritten (last write wins).
   */
  start(name: string, meta?: Record<string, any>): string {
    const id = uid("probe");
    active.set(id, { name, t0: now(), meta });
    return id;
  },

  /**
   * End a previously started probe. Returns the measured duration in ms or 0
   * if no matching start was found (safe no-op).
   */
  end(id: string, meta?: Record<string, any>): number {
    const item = active.get(id);
    if (!item) return 0;

    active.delete(id);
    const t1 = now();
    const duration = Math.max(0, t1 - item.t0);

    const detail: MeasureDetail = {
      name: item.name,
      duration,
      startTime: item.t0,
      endTime: t1,
      meta: { ...(item.meta || {}), ...(meta || {}) },
      type: "measure",
      id,
    };

    emitMeasure(detail);
    devLog(`[Probe] ${item.name}: ${duration.toFixed(2)}ms`, detail.meta || "");

    return duration;
  },

  /**
   * Time a synchronous function. Returns the function's return value.
   * If the function throws, we still emit a measure with ":error" suffix.
   */
  run<T>(name: string, fn: () => T, meta?: Record<string, any>): T {
    const t0 = now();
    try {
      const res = fn();
      const t1 = now();
      const detail: MeasureDetail = {
        name,
        duration: Math.max(0, t1 - t0),
        startTime: t0,
        endTime: t1,
        meta,
        type: "measure",
      };
      emitMeasure(detail);
      devLog(`[Probe] ${name}: ${detail.duration.toFixed(2)}ms`, meta || "");
      return res;
    } catch (err) {
      const t1 = now();
      const detail: MeasureDetail = {
        name: `${name}:error`,
        duration: Math.max(0, t1 - t0),
        startTime: t0,
        endTime: t1,
        meta: { ...(meta || {}), error: true },
        type: "measure",
      };
      emitMeasure(detail);
      devLog(`[Probe] ${name} (error): ${detail.duration.toFixed(2)}ms`, meta || "", err);
      throw err;
    }
  },

  /**
   * Time an async function (Promise). Resolves with the function's value.
   * Emits a ":error" measurement if the promise rejects.
   */
  async runAsync<T>(
    name: string,
    fn: () => Promise<T>,
    meta?: Record<string, any>
  ): Promise<T> {
    const t0 = now();
    try {
      const res = await fn();
      const t1 = now();
      const detail: MeasureDetail = {
        name,
        duration: Math.max(0, t1 - t0),
        startTime: t0,
        endTime: t1,
        meta,
        type: "measure",
      };
      emitMeasure(detail);
      devLog(`[Probe] ${name}: ${detail.duration.toFixed(2)}ms`, meta || "");
      return res;
    } catch (err) {
      const t1 = now();
      const detail: MeasureDetail = {
        name: `${name}:error`,
        duration: Math.max(0, t1 - t0),
        startTime: t0,
        endTime: t1,
        meta: { ...(meta || {}), error: true },
        type: "measure",
      };
      emitMeasure(detail);
      devLog(`[Probe] ${name} (error): ${detail.duration.toFixed(2)}ms`, meta || "", err);
      throw err;
    }
  },

  /**
   * Instant mark — records an occurrence without timing. Useful for counting
   * specific events (e.g., "queue:add", "shader:compiled").
   */
  mark(name: string, meta?: Record<string, any>): void {
    const t = now();
    const detail: MeasureDetail = {
      name,
      duration: 0,
      startTime: t,
      endTime: t,
      meta,
      type: "mark",
    };
    emitMeasure(detail);
    devLog(`[Probe] mark: ${name}`, meta || "");
  },

  /**
   * Add a delta to a named counter (defaults to +1). Counters are batched and
   * emitted only when `flushCounts()` is called to reduce event spam.
   */
  count(name: string, delta = 1): void {
    const prev = counters.get(name) || 0;
    counters.set(name, prev + delta);
  },

  /**
   * Emit and reset all accumulated counters. This should be called at a sensible
   * cadence (e.g., once per second by a diagnostics loop, or manually in Dev UI).
   */
  flushCounts(): void {
    const t = now();
    for (const [name, count] of counters.entries()) {
      const detail: MeasureDetail = {
        name,
        duration: 0,
        startTime: t,
        endTime: t,
        type: "count",
        count,
      };
      emitMeasure(detail);
      devLog(`[Probe] count: ${name} = ${count}`);
    }
    counters.clear();
  },

  /**
   * Enable/disable console logging for probes (measure emission is unaffected).
   * Persisted locally so a reload preserves the preference.
   */
  enabled(next?: boolean): boolean {
    if (typeof next === "boolean") {
      _logEnabled = next;
      writeLS("eh.probe.log", next ? "true" : "false");
    }
    return _logEnabled;
  },

  /**
   * Subscribe to PerfEvents "eh:perf:measure" stream (typed for MeasureDetail).
   * Returns an unsubscribe function.
   */
  onMeasure(handler: (detail: MeasureDetail) => void): () => void {
    return PerfEvents.on<MeasureDetail>("eh:perf:measure", (e) => handler(e.detail));
  },

  /**
   * Expose a convenient global for quick debugging (window.__EH_PROBE).
   */
  installGlobal(): void {
    if (!IS_BROWSER) return;
    (window as any).__EH_PROBE = this;
  },
} as const;

export default Probe;

/* ----------------------------- Suggested usage ---------------------------- */
/**
 * Examples (do not execute here):
 *
 * // Manual timing:
 * const id = Probe.start("audio:decode", { codec: "mp3" });
 * await decodeBuffer(...);
 * Probe.end(id);
 *
 * // Sync
 * const out = Probe.run("viz:scene:build", () => buildScene(meshes));
 *
 * // Async
 * const data = await Probe.runAsync("net:cover-art:fetch", () => fetch(url).then(r => r.blob()));
 *
 * // Count
 * Probe.count("queue:add");
 * Probe.flushCounts(); // e.g., on an interval
 */

/* -------------------------------- Bootstrap ------------------------------- */
/**
 * We auto-install the global alias in the browser for convenience. This has
 * no side effects beyond attaching a reference for console access.
 */
if (IS_BROWSER) {
  try {
    Probe.installGlobal();
  } catch {
    // non-fatal
  }
}
</file>

<file path="src/lib/state/types.ts">
// src/lib/state/types.ts
/**
 * Shared state types (Phase 1/2)
 * -----------------------------------------------------------------------------
 * This module centralizes the **canonical** shapes used across our Zustand
 * stores and UI. It also exposes compatibility helpers for legacy shapes from
 * early prototypes (so we can safely map old data into the new structures).
 *
 * Design notes:
 * - `Track` here matches the loader/engine contracts in Phase 2 (TrackLoader /
 *   AudioEngine / PlaybackController). It is the single source of truth for the
 *   player UI (PlayerCard, Timeline, etc.).
 * - We keep a `LegacyTrackV1` type that reflects the Phase 0/early-Phase 1
 *   prototype so persisted data (or tests) can be migrated in a predictable way.
 * - The player/viz/settings store interfaces are intentionally *minimal* and
 *   forward-compatible: actions are typed as function signatures but optional,
 *   because slices are composed gradually and tests sometimes stub them out.
 */

/* ----------------------------------------------------------------------------
 * Tracks
 * ------------------------------------------------------------------------- */

/** Where a track originates. */
export type TrackSource = "local" | "remote";

/**
 * Canonical Track (Phase 2+)
 * - Consumed by the player store & UI.
 * - Produced by TrackLoader (from File or URL).
 * - Understood by AudioEngine/PlaybackController.
 */
export type Track = {
  /** Stable identifier for lists/queue. */
  id: string;

  /** Display metadata (may be empty if unknown). */
  title: string;
  artist?: string;
  album?: string;

  /** Optional artwork URL (object URL or remote), if available. */
  artworkUrl?: string;

  /** Playable URL (object URL for local Files, normalized remote URL otherwise). */
  url: string;

  /** Duration in seconds (if known). Streams/HLS may leave this undefined. */
  duration?: number;

  /** Best-effort MIME hint (e.g., "audio/mpeg", "application/vnd.apple.mpegurl"). */
  mime?: string;

  /** True if this is a stream or has no fixed duration (e.g., HLS). */
  isStream?: boolean;

  /** Origin of the media (local File or remote). */
  source: TrackSource;

  /** Internal: object URL for local tracks (to revoke on cleanup). */
  _objectUrl?: string;
};

/**
 * Legacy Track shape from prototypes (Phase 0/early Phase 1).
 * Kept for migration of older persisted state.
 */
export type LegacyTrackV1 = {
  id: string;
  title: string;
  artist: string;
  album?: string;
  /** Duration in seconds (required in legacy). */
  durationSec: number;
  /** Source discriminated union. */
  src: { kind: "file" | "stream"; url: string };
  artworkUrl?: string;
};

/** Type guard: detect legacy track objects at runtime. */
export function isLegacyTrackV1(x: unknown): x is LegacyTrackV1 {
  const t = x as LegacyTrackV1;
  return !!t && typeof t === "object" && typeof t.id === "string" && typeof t.title === "string" && !!t.src && typeof t.src.url === "string";
}

/**
 * Migration helper: convert LegacyTrackV1 -> Track (Phase 2).
 * - Maps `src.kind` to `source`/`isStream`.
 * - Copies duration and metadata.
 * - Normalizes field names (`url`, `duration`).
 */
export function mapLegacyTrackToCurrent(t: LegacyTrackV1): Track {
  const source: TrackSource =
    t.src.kind === "file"
      ? (t.src.url.startsWith("blob:") || t.src.url.startsWith("file:") ? "local" : "remote")
      : "remote";

  const isStream = t.src.kind === "stream" || /\.m3u8(\?.*)?$/i.test(t.src.url);

  return {
    id: t.id,
    title: t.title,
    artist: t.artist,
    album: t.album,
    artworkUrl: t.artworkUrl,
    url: t.src.url,
    duration: Number.isFinite(t.durationSec) ? t.durationSec : undefined,
    mime: isStream ? "application/vnd.apple.mpegurl" : undefined,
    isStream,
    source,
  };
}

/* ----------------------------------------------------------------------------
 * Player store (shared subset)
 * ------------------------------------------------------------------------- */

/** Discrete playback states for UI/logic clarity. */
export type PlaybackState = "idle" | "loading" | "playing" | "paused" | "error";

/** Actions exposed by the player slice (intentionally optional for flexibility). */
export type PlayerActions = Partial<{
  /** Load a single track (replaces the queue). */
  loadFromUrl: (url: string, autoplay?: boolean) => Promise<void> | void;
  loadFromFile: (file: File, autoplay?: boolean) => Promise<void> | void;

  /** Queue management */
  setQueue: (tracks: Track[], startIndex?: number) => Promise<void> | void;
  addToQueue: (track: Track, atEnd?: boolean) => void;
  removeFromQueue: (index: number) => void;
  clearQueue: () => void;
  next: () => Promise<void> | void;
  prev: () => Promise<void> | void;

  /** Transport */
  play: () => Promise<void> | void;
  pause: () => Promise<void> | void;
  toggle: () => Promise<void> | void;
  seek: (seconds: number) => void;
  nudgeSeek: (deltaSeconds: number) => void;

  /** Volume / rate / mute */
  setVolume: (v: number) => void;
  nudgeVolume: (delta: number) => void;
  toggleMute: () => void;
  setRate: (r: number) => void;
}>;

/** Core state exposed by the player slice. */
export type PlayerCoreState = {
  /** Current, duration, and derived flags for UI. */
  current: Track | null;
  queue: Track[];
  index: number;

  playbackState: PlaybackState;
  isPlaying: boolean;

  /** Position and duration (seconds). */
  position: number;
  duration: number;

  /** Volume/mute/rate */
  volume: number; // 0..1
  muted: boolean;
  playbackRate: number; // 0.25..4
};

/** Full player store type (state + actions). */
export type PlayerStore = PlayerCoreState & PlayerActions;

/* ----------------------------------------------------------------------------
 * Visualizer store (subset mirror of useVizStore to avoid cross-import cycles)
 * ------------------------------------------------------------------------- */

/** Visualizer preset IDs we support in V1/V2. */
export type VizPresetId = "nebula" | "glass-waves" | "strobe-pulse";

/** Curated visualizer parameters sent to Three.js uniforms. */
export type VizParams = {
  intensity: number;     // 0..1
  bloom: number;         // 0..0.5
  motionScale: number;   // 0..1
  smooth: number;        // 0..1 analyser smoothing
  baseColor: string;     // CSS color
  reactiveHue: string;   // CSS color
  accent: string;        // CSS color
  particleCount: number; // target particles; scene clamps by tier/hardware
};

export type VizStore = {
  theme: "dark" | "system";
  hdr: boolean;
  dimmer: boolean;
  presetId: VizPresetId;
  params: VizParams;
};

/* ----------------------------------------------------------------------------
 * Settings/navigation (Phase 1 router)
 * ------------------------------------------------------------------------- */

/** App views (mirrors src/app/routes.tsx without importing to avoid cycles). */
export type AppView = "player" | "settings" | "stream";

export type ThemeMode = "dark" | "system";

export type SettingsStore = {
  theme: ThemeMode;
  view: AppView;
  reducedMotion?: boolean;
};

/* ----------------------------------------------------------------------------
 * Diagnostics / analyser types (small mirrors for consumers)
 * ------------------------------------------------------------------------- */

/** Compact band energy snapshot used by visualizer & meters. */
export type BandEnergies = { low: number; mid: number; high: number; rms: number };

/* ----------------------------------------------------------------------------
 * End of types
 * ------------------------------------------------------------------------- */
</file>

<file path="src/lib/state/usePlayerStore.ts">
/**
 * src/lib/state/usePlayerStore.ts
 * Ethereal Harmony — Player Store (Zustand, Phase 1 aligned with Phase 2)
 *
 * Responsibilities:
 *  - Source of truth for playback queue + current index only.
 *  - Delegates transport (play/pause/seek/load) to the audio engine's PlaybackController.
 *  - Persists queue and index locally with safe SSR/rehydration behavior.
 *  - Exposes selectors to minimize re-renders.
 *
 * IMPORTANT:
 *  - Do NOT persist transport state (playing, position, volume) — engine owns it.
 *  - Use primitive selectors from this file in components to avoid render loops.
 */

import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { persist, createJSONStorage } from "zustand/middleware";

/* ---------------------------------- Types --------------------------------- */

export type Track = {
  id: string;
  title: string;
  artist: string;
  album?: string;
  url: string;          // media URL or object URL
  artworkUrl?: string;  // data URL or https
  duration?: number;    // seconds (optional; engine may update)
};

type PlayerState = {
  queue: Track[];
  currentIndex: number; // -1 = none selected
  hasHydrated: boolean; // gate UI reads until rehydrate completes

  // Queue management
  setQueue: (tracks: Track[], startIndex?: number) => void;
  addToQueue: (track: Track) => void;
  addManyToQueue: (tracks: Track[]) => void;
  removeFromQueue: (trackId: string) => void;
  clearQueue: () => void;
  setCurrentIndex: (idx: number) => void;
  next: () => void;
  prev: () => void;

  // Transport delegates (engine-owned)
  play: () => void;
  pause: () => void;
  togglePlay: () => void;
  seek: (seconds: number) => void;
  playIndex: (idx: number) => void;
};

/* ------------------------- SSR-safe JSON storage -------------------------- */

const storage = createJSONStorage<Partial<PlayerState>>(() => {
  if (typeof window === "undefined") return undefined as unknown as Storage;
  return window.localStorage;
});

/* -------------------- PlaybackController (runtime link) ------------------- */
/**
 * We keep a loose runtime link to the engine. This avoids hard coupling and is
 * SSR-friendly. The engine can optionally expose a global handle:
 *   globalThis.__EH_PLAYBACK
 * or export one of the common names from "@/lib/audio/PlaybackController":
 *   - playback (preferred)
 *   - default
 *   - playbackController
 */
type MaybePlayback = {
  loadAndPlay?: (track: Track) => void | Promise<void>;
  replaceQueue?: (tracks: Track[], startIndex: number) => void | Promise<void>;
  play?: () => void;
  pause?: () => void;
  toggle?: () => void;
  seek?: (seconds: number) => void;
};

let cachedController: MaybePlayback | null = null;

const getPlaybackController = async (): Promise<MaybePlayback | null> => {
  if (cachedController) return cachedController;

  // 1) Global registration (engine may assign this during bootstrap)
  const g = globalThis as Record<string, unknown>;
  if (g && g.__EH_PLAYBACK) {
    cachedController = g.__EH_PLAYBACK as MaybePlayback;
    return cachedController;
  }

  // 2) Dynamic import (code-split friendly)
  try {
  const mod = (await import("@/lib/audio/PlaybackController")) as Record<string, unknown>;
    cachedController =
      (mod?.playback as MaybePlayback) ??
      (mod?.default as MaybePlayback) ??
      (mod?.playbackController as MaybePlayback) ??
      null;
  } catch {
    cachedController = null;
  }
  return cachedController;
};

/** Fire-and-forget helper to interact with the controller when available. */
const withController = (fn: (pc: MaybePlayback) => void) => {
  // Immediate path if already cached/global
  if (cachedController) {
    fn(cachedController);
    return;
  }
  const g = globalThis as Record<string, unknown>;
  if (g && g.__EH_PLAYBACK) {
    cachedController = g.__EH_PLAYBACK as MaybePlayback;
    fn(cachedController);
    return;
  }
  // Defer: load on microtask to keep UI responsive
  queueMicrotask(() => {
    void getPlaybackController().then((pc) => {
      if (pc) fn(pc);
    });
  });
};

/* --------------------------------- Store ---------------------------------- */

export const usePlayerStore = create<PlayerState>()(
  devtools(
    persist(
      (set, get) => ({
        queue: [],
        currentIndex: -1,
        hasHydrated: false,

        /* ------------------------- Queue management ------------------------ */

        setQueue: (tracks, startIndex = 0) => {
          const safeIndex =
            tracks.length === 0 ? -1 : Math.min(Math.max(startIndex, 0), tracks.length - 1);

          set({ queue: [...tracks], currentIndex: safeIndex });

          // Hint engine to adopt queue or load+play current track.
          withController((pc) => {
            if (pc.replaceQueue) {
              pc.replaceQueue(tracks, safeIndex);
              return;
            }
            if (safeIndex >= 0) {
              const t = tracks[safeIndex];
              pc.loadAndPlay?.(t);
            }
          });
        },

        addToQueue: (track) => {
          set((s) => ({ queue: [...s.queue, track] }));
        },

        addManyToQueue: (tracks) => {
          if (!tracks?.length) return;
          set((s) => ({ queue: [...s.queue, ...tracks] }));
        },

        removeFromQueue: (trackId) => {
          set((s) => {
            const idx = s.queue.findIndex((t) => t.id === trackId);
            if (idx === -1) return s;

            const newQueue = [...s.queue.slice(0, idx), ...s.queue.slice(idx + 1)];
            let newIndex = s.currentIndex;

            if (newQueue.length === 0) {
              newIndex = -1;
            } else if (idx < s.currentIndex) {
              newIndex = s.currentIndex - 1;
            } else if (idx === s.currentIndex) {
              newIndex = Math.min(s.currentIndex, newQueue.length - 1);
              // Optionally auto-load the next item
              const track = newQueue[newIndex];
              if (track) withController((pc) => pc.loadAndPlay?.(track));
            }

            return { queue: newQueue, currentIndex: newIndex };
          });
        },

        clearQueue: () => {
          set({ queue: [], currentIndex: -1 });
        },

        setCurrentIndex: (idx) => {
          const { queue } = get();
          if (queue.length === 0) {
            set({ currentIndex: -1 });
            return;
          }
          const clamped = Math.min(Math.max(idx, 0), queue.length - 1);
          set({ currentIndex: clamped });

          const track = queue[clamped];
          if (track) withController((pc) => pc.loadAndPlay?.(track));
        },

        next: () => {
          const s = get();
          if (s.queue.length === 0) {
            set({ currentIndex: -1 });
            return;
          }
          const nextIndex = Math.min(s.currentIndex + 1, s.queue.length - 1);
          set({ currentIndex: nextIndex });

          const track = s.queue[nextIndex];
          if (track) withController((pc) => pc.loadAndPlay?.(track));
        },

        prev: () => {
          const s = get();
          if (s.queue.length === 0) {
            set({ currentIndex: -1 });
            return;
          }
          const prevIndex = Math.max(s.currentIndex - 1, 0);
          set({ currentIndex: prevIndex });

          const track = s.queue[prevIndex];
          if (track) withController((pc) => pc.loadAndPlay?.(track));
        },

        /* ---------------------- Transport (delegated) ---------------------- */

        play: () => withController((pc) => pc.play?.()),
        pause: () => withController((pc) => pc.pause?.()),
        togglePlay: () => withController((pc) => pc.toggle?.()),
        seek: (seconds) => {
          if (typeof seconds !== "number" || !Number.isFinite(seconds)) return;
          withController((pc) => pc.seek?.(seconds));
        },
        playIndex: (idx) => {
          const { queue } = get();
          if (queue.length === 0) return;

          const clamped = Math.min(Math.max(idx, 0), queue.length - 1);
          set({ currentIndex: clamped });

          const track = queue[clamped];
          if (track) withController((pc) => pc.loadAndPlay?.(track));
        },
      }),
      {
        name: "player-v2",
        version: 2,
  storage: storage as unknown as import("zustand/middleware").PersistStorage<unknown>,

        // Persist only queue + index (transport is engine-owned)
        partialize: (s) => ({ queue: s.queue, currentIndex: s.currentIndex }),

        // Defensive migration to keep index valid if queue shape changed.
        migrate: (persisted: unknown, fromVersion: number) => {
          if (!persisted || typeof persisted !== "object") return persisted;
          const p = persisted as { queue?: unknown; currentIndex?: unknown };
          if (fromVersion <= 1) {
            const queue: Track[] = Array.isArray(p.queue) ? (p.queue as Track[]) : [];
            let currentIndex =
              typeof p.currentIndex === "number" ? (p.currentIndex as number) : -1;

            if (queue.length === 0) currentIndex = -1;
            else currentIndex = Math.min(Math.max(currentIndex, 0), queue.length - 1);

            return { ...persisted, queue, currentIndex };
          }
          return persisted;
        },

        // Hydration lifecycle: flip the flag after rehydrate completes.
        onRehydrateStorage: () => {
          // before hydration (no-op)
          return () => {
            // after hydration
            try {
              // `usePlayerStore` is defined by the time this runs
              usePlayerStore.setState({ hasHydrated: true });
            } catch {
              // ignore — store may be tearing down
            }
          };
        },
      }
    ),
    { name: "usePlayerStore" }
  )
);

/* -------------------------------- Selectors ------------------------------- */
/** Use these to avoid unnecessary re-renders */
export const selectQueue = (s: PlayerState) => s.queue;
export const selectCurrentIndex = (s: PlayerState) => s.currentIndex;
export const selectHasHydrated = (s: PlayerState) => s.hasHydrated;
export const selectCurrentTrack = (s: PlayerState) =>
  s.currentIndex >= 0 && s.currentIndex < s.queue.length
    ? s.queue[s.currentIndex]
    : undefined;
export const selectIsEmpty = (s: PlayerState) => s.queue.length === 0;
</file>

<file path="src/lib/state/useSettingsStore.ts">
// src/lib/state/useSettingsStore.ts
/**
 * useSettingsStore
 * -----------------------------------------------------------------------------
 * A tiny, domain-driven Zustand store for *user settings* and our simple,
 * store-driven view switching. This store is intentionally framework-agnostic
 * and safe to import anywhere.
 *
 * What we keep here (persisted):
 * - theme: "dark" | "system" (default: "dark")
 * - view:  "player" | "settings" | "stream" (default: "player")
 * - reducedMotion: boolean | undefined (undefined => follow system)
 * - vizPreset: "low" | "medium" | "high" | "ultra" (default: "medium")
 * - hdrEnabled: boolean (default: true)
 * - dimmerEnabled: boolean (default: false)
 * - dimmerStrength: number [0..1] (default: 0.25)  // only used if enabled
 * - hotkeysEnabled: boolean (default: true)
 * - showStats: boolean (default: false) // drives the PerfOverlay mount; also dispatches a DOM CustomEvent
 *
 * What we keep here (ephemeral, NOT persisted):
 * - hasHydrated: boolean — allows components to avoid reading incomplete values
 *
 * Why not Context?
 * - Zustand gives us fine-grained selectors, fewer re-renders, and a single
 *   source of truth that any component can read without prop drilling.
 *
 * Persistence details:
 * - We use `zustand/middleware/persist` with a JSON storage pointing at
 *   localStorage. A `migrate` function keeps forward-compat and silences
 *   rehydrate warnings when the shape/version changes.
 * - `onRehydrateStorage` toggles a `hasHydrated` flag so consumers can defer
 *   sensitive reads until hydration completes.
 *
 * Side-effects:
 * - The store updates `<html>` theme classes to keep CSS in sync:
 *     theme === "dark"  => adds .theme-dark, removes .theme-light
 *     theme === "system"=> removes both (globals.css falls back to OS)
 *
 * Interop notes:
 * - SettingsPanel reads/writes: hdrEnabled, dimmerEnabled, vizPreset, showStats.
 * - GlobalHotkeys may read: hotkeysEnabled.
 * - PerfOverlayMount listens to showStats *and/or* the "eh:viz:stats" event.
 */

import { create } from "zustand";
import { persist, createJSONStorage, StateStorage } from "zustand/middleware";

/* ----------------------------------------------------------------------------
 * Local Types (self-contained to avoid external coupling)
 * ------------------------------------------------------------------------- */

export type ThemeMode = "dark" | "system";
export type AppView = "player" | "settings" | "stream";

/** Preset IDs match QualityPresets.ts keys (keep union in sync if you add more). */
export type VizPresetId = "low" | "medium" | "high" | "ultra";

/** Public shape (persisted + actions + ephemeral) */
export interface SettingsState {
  // Persisted
  theme: ThemeMode;
  view: AppView;
  reducedMotion: boolean | undefined;

  vizPreset: VizPresetId;
  hdrEnabled: boolean;
  dimmerEnabled: boolean;
  dimmerStrength: number; // 0..1
  hotkeysEnabled: boolean;
  showStats: boolean;

  // Ephemeral (not persisted)
  hasHydrated: boolean;

  // Actions
  setTheme: (mode: ThemeMode) => void;
  toggleTheme: () => void;

  setView: (view: AppView) => void;

  setReducedMotion: (v: boolean | undefined) => void;

  setVizPreset: (id: VizPresetId) => void;
  setHdrEnabled: (on: boolean) => void;

  setDimmerEnabled: (on: boolean) => void;
  setDimmerStrength: (v: number) => void; // clamps to [0..1]

  setHotkeysEnabled: (on: boolean) => void;

  setShowStats: (on: boolean) => void; // dispatches "eh:viz:stats"
}

/* ----------------------------------------------------------------------------
 * Constants & Utilities
 * ------------------------------------------------------------------------- */

const STORAGE_KEY = "eh-settings-v3";
const STORAGE_VERSION = 3;

// Narrow string → valid union helpers (guards bad or stale data)
function normalizeTheme(mode: any): ThemeMode {
  return mode === "system" ? "system" : "dark";
}
function normalizeView(view: any): AppView {
  return view === "settings" || view === "stream" ? view : "player";
}
function normalizePreset(id: any): VizPresetId {
  return id === "low" || id === "high" || id === "ultra" ? id : "medium";
}
function clamp01(n: number): number {
  return Number.isFinite(n) ? Math.min(1, Math.max(0, n)) : 0;
}

/** Reflect theme class to <html> for CSS tokens in globals.css/tokens.css. */
function applyThemeClass(mode: ThemeMode) {
  if (typeof document === "undefined") return;
  const el = document.documentElement;
  if (mode === "dark") {
    el.classList.add("theme-dark");
    el.classList.remove("theme-light");
  } else {
    // "system": let OS decide by removing explicit classes
    el.classList.remove("theme-dark");
    el.classList.remove("theme-light");
  }
}

/** Fire a tiny DOM event so non-React utilities can listen if needed. */
function dispatchStatsEvent(enabled: boolean) {
  if (typeof window === "undefined") return;
  try {
    window.dispatchEvent(
      new CustomEvent("eh:viz:stats", {
        detail: { enabled },
      })
    );
  } catch {
    // ignore
  }
}

/* ----------------------------------------------------------------------------
 * Defaults
 * ------------------------------------------------------------------------- */

const DEFAULTS: Omit<SettingsState, keyof SettingsState & string> & SettingsState = {
  theme: "dark",
  view: "player",
  reducedMotion: undefined,

  vizPreset: "medium",
  hdrEnabled: true,

  dimmerEnabled: false,
  dimmerStrength: 0.25,

  hotkeysEnabled: true,

  showStats: false,

  hasHydrated: false,

  // Actions (filled in create)
  setTheme: () => {},
  toggleTheme: () => {},
  setView: () => {},
  setReducedMotion: () => {},
  setVizPreset: () => {},
  setHdrEnabled: () => {},
  setDimmerEnabled: () => {},
  setDimmerStrength: () => {},
  setHotkeysEnabled: () => {},
  setShowStats: () => {},
};

/* ----------------------------------------------------------------------------
 * Migration
 *  v1  (historical)   - { mode?, route?, reducedMotion? }
 *  v2  (previous)     - { theme, view, reducedMotion }
 *  v3  (current)      - adds vizPreset, hdrEnabled, dimmerEnabled, dimmerStrength,
 *                       hotkeysEnabled, showStats
 * ------------------------------------------------------------------------- */

function migrate(persisted: unknown, fromVersion: number): SettingsState {
  // Always layer onto defaults to ensure missing keys are populated.
  const base: SettingsState = { ...DEFAULTS };

  if (!persisted || typeof persisted !== "object") {
    return base;
  }
  const s = persisted as Partial<Record<keyof SettingsState, any>> & Record<string, any>;

  if (fromVersion <= 1) {
    // Early builds used "mode" and "route"
    const theme = typeof s.theme === "string" ? s.theme : typeof s.mode === "string" ? s.mode : undefined;
    const view = typeof s.view === "string" ? s.view : typeof s.route === "string" ? s.route : undefined;

    base.theme = normalizeTheme(theme);
    base.view = normalizeView(view);
    if (typeof s.reducedMotion === "boolean") base.reducedMotion = s.reducedMotion;

    // v3 additions fallback to defaults
    return base;
  }

  if (fromVersion === 2) {
    // v2 → v3: copy forward known keys, add new settings with defaults.
    if (typeof s.theme === "string") base.theme = normalizeTheme(s.theme);
    if (typeof s.view === "string") base.view = normalizeView(s.view);
    if (typeof s.reducedMotion === "boolean") base.reducedMotion = s.reducedMotion;

    // New in v3 — safely normalize if present (e.g., from pre-release builds)
    if (typeof s.vizPreset === "string") base.vizPreset = normalizePreset(s.vizPreset);
    if (typeof s.hdrEnabled === "boolean") base.hdrEnabled = s.hdrEnabled;
    if (typeof s.dimmerEnabled === "boolean") base.dimmerEnabled = s.dimmerEnabled;
    if (typeof s.dimmerStrength === "number") base.dimmerStrength = clamp01(s.dimmerStrength);
    if (typeof s.hotkeysEnabled === "boolean") base.hotkeysEnabled = s.hotkeysEnabled;
    if (typeof s.showStats === "boolean") base.showStats = s.showStats;

    return base;
  }

  // Future: copy recognized keys; unknowns are discarded
  if (typeof s.theme === "string") base.theme = normalizeTheme(s.theme);
  if (typeof s.view === "string") base.view = normalizeView(s.view);
  if (typeof s.reducedMotion === "boolean") base.reducedMotion = s.reducedMotion;

  if (typeof s.vizPreset === "string") base.vizPreset = normalizePreset(s.vizPreset);
  if (typeof s.hdrEnabled === "boolean") base.hdrEnabled = s.hdrEnabled;
  if (typeof s.dimmerEnabled === "boolean") base.dimmerEnabled = s.dimmerEnabled;
  if (typeof s.dimmerStrength === "number") base.dimmerStrength = clamp01(s.dimmerStrength);
  if (typeof s.hotkeysEnabled === "boolean") base.hotkeysEnabled = s.hotkeysEnabled;
  if (typeof s.showStats === "boolean") base.showStats = s.showStats;

  return base;
}

/* ----------------------------------------------------------------------------
 * Store
 * ------------------------------------------------------------------------- */

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set, get) => ({
      ...DEFAULTS,

      // THEME
      setTheme: (mode) => {
        const next = normalizeTheme(mode);
        if (next === get().theme) return;
        set({ theme: next });
        // Keep DOM in sync immediately
        applyThemeClass(next);
      },
      toggleTheme: () => {
        const curr = get().theme;
        const next: ThemeMode = curr === "dark" ? "system" : "dark";
        set({ theme: next });
        applyThemeClass(next);
      },

      // VIEW (store-driven simple router)
      setView: (view) => {
        const v = normalizeView(view);
        if (v !== get().view) set({ view: v });
      },

      // REDUCED MOTION
      setReducedMotion: (v) => {
        if (typeof v === "boolean" || typeof v === "undefined") {
          set({ reducedMotion: v });
        }
      },

      // VISUALIZER PRESET
      setVizPreset: (id) => set({ vizPreset: normalizePreset(id) }),

      // HDR TOGGLE
      setHdrEnabled: (on) => set({ hdrEnabled: !!on }),

      // DIMMER
      setDimmerEnabled: (on) => set({ dimmerEnabled: !!on }),
      setDimmerStrength: (v) => set({ dimmerStrength: clamp01(v) }),

      // HOTKEYS
      setHotkeysEnabled: (on) => set({ hotkeysEnabled: !!on }),

      // PERF/DEV STATS
      setShowStats: (on) => {
        const enabled = !!on;
        if (enabled === get().showStats) return;
        set({ showStats: enabled });
        // Notify non-React listeners (PerfOverlayMount can also subscribe)
        dispatchStatsEvent(enabled);
      },
    }),
    {
      name: STORAGE_KEY,
      version: STORAGE_VERSION,
      storage: createJSONStorage((): StateStorage => localStorage),

      // Only persist stable user choices; omit ephemeral flags.
      partialize: (s) => ({
        theme: s.theme,
        view: s.view,
        reducedMotion: typeof s.reducedMotion === "boolean" ? s.reducedMotion : undefined,

        vizPreset: s.vizPreset,
        hdrEnabled: s.hdrEnabled,
        dimmerEnabled: s.dimmerEnabled,
        dimmerStrength: clamp01(s.dimmerStrength),

        hotkeysEnabled: s.hotkeysEnabled,
        showStats: s.showStats,
      }),

      migrate,

      // Hydration lifecycle to prevent "couldn't be migrated" warnings
      // and to run DOM side-effects (theme classes) once data is ready.
      onRehydrateStorage: () => (state, error) => {
        // If error, keep defaults but still mark hydrated to unblock UI.
        if (error) {
          console.warn("[useSettingsStore] Rehydrate error:", error);
        }

        // Coerce and apply theme classes after hydration
        const mode = normalizeTheme(state?.theme);
        applyThemeClass(mode);

        // Guard against missing or out-of-range values from older caches
        const next: Partial<SettingsState> = {
          hasHydrated: true,
          theme: mode,
          view: normalizeView(state?.view),
          reducedMotion:
            typeof state?.reducedMotion === "boolean" ? state?.reducedMotion : undefined,

          vizPreset: normalizePreset(state?.vizPreset),
          hdrEnabled: !!state?.hdrEnabled,
          dimmerEnabled: !!state?.dimmerEnabled,
          dimmerStrength: clamp01(state?.dimmerStrength ?? DEFAULTS.dimmerStrength),

          hotkeysEnabled: state?.hotkeysEnabled ?? DEFAULTS.hotkeysEnabled,
          showStats: !!state?.showStats,
        };

        // Apply the sanitized snapshot
        useSettingsStore.setState(next, false, "rehydrate:settings");
      },
    }
  )
);

/* ----------------------------------------------------------------------------
 * Selectors (stable primitives → fewer component re-renders)
 * ------------------------------------------------------------------------- */

export const selectHasHydrated = (s: SettingsState) => s.hasHydrated;

export const selectView = (s: SettingsState) => s.view;
export const selectTheme = (s: SettingsState) => s.theme;

export const selectReducedMotionOverride = (s: SettingsState) => s.reducedMotion;
/** Effective reduced-motion boolean; falls back to system if override is unset. */
export function selectEffectiveReducedMotion(s: SettingsState): boolean {
  if (typeof s.reducedMotion === "boolean") return s.reducedMotion;
  if (typeof window === "undefined" || typeof window.matchMedia !== "function") return false;
  try {
    return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  } catch {
    return false;
  }
}

export const selectVizPreset = (s: SettingsState) => s.vizPreset;
export const selectHdrEnabled = (s: SettingsState) => s.hdrEnabled;

export const selectDimmerEnabled = (s: SettingsState) => s.dimmerEnabled;
export const selectDimmerStrength = (s: SettingsState) => s.dimmerStrength;

export const selectHotkeysEnabled = (s: SettingsState) => s.hotkeysEnabled;
export const selectShowStats = (s: SettingsState) => s.showStats;

/* ----------------------------------------------------------------------------
 * Imperative helpers (non-hook usage)
 * ------------------------------------------------------------------------- */

export const setView = (view: AppView) => useSettingsStore.getState().setView(view);
export const setTheme = (mode: ThemeMode) => useSettingsStore.getState().setTheme(mode);
export const setReducedMotion = (v: boolean | undefined) =>
  useSettingsStore.getState().setReducedMotion(v);

export const setVizPreset = (id: VizPresetId) => useSettingsStore.getState().setVizPreset(id);
export const setHdrEnabled = (on: boolean) => useSettingsStore.getState().setHdrEnabled(on);

export const setDimmerEnabled = (on: boolean) => useSettingsStore.getState().setDimmerEnabled(on);
export const setDimmerStrength = (v: number) => useSettingsStore.getState().setDimmerStrength(v);

export const setHotkeysEnabled = (on: boolean) => useSettingsStore.getState().setHotkeysEnabled(on);

export const setShowStats = (on: boolean) => useSettingsStore.getState().setShowStats(on);
</file>

<file path="src/lib/state/useUIStore.ts">
// src/lib/state/useUIStore.ts
/**
 * useUIStore
 * -----------------------------------------------------------------------------
 * Purpose
 *  - Centralize ephemeral UI state that does NOT belong to domain stores
 *    (player/viz/settings). Keep it tiny, predictable, and accessibility-first.
 *
 * Scope (Phase 1/2)
 *  - SidePanel open/closed (persisted locally).
 *  - Controls rail pinning (persisted).
 *  - Diagnostics toggle (FPS meter) (persisted).
 *  - Lightweight modal manager for simple in-app overlays (NOT router-level).
 *  - A few layout measurements (topBarHeight) for responsive adjustments.
 *
 * Architecture
 *  - Zustand + persist (localStorage). We partialize persisted keys only.
 *  - Includes `migrate` to silence "couldn't be migrated" warnings across shapes/versions.
 *  - Exposes stable primitive selectors to minimize re-renders.
 *
 * Back-compat
 *  - Earlier builds used `sidebarCollapsed` + `toggleSidebar()`.
 *  - New API is `sidePanelOpen` + `toggleSidePanel()` + `setSidePanelOpen(open)`.
 *  - We migrate persisted data and keep the old actions as no-op wrappers.
 */

import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

/* ----------------------------------------------------------------------------
 * Types
 * ------------------------------------------------------------------------- */

export type UIModal =
  | "none"
  | "hotkeys"
  | "about"
  | "stream-wizard"
  | "device-picker";

export type UIState = {
  // Layout / shells
  sidePanelOpen: boolean;     // NEW canonical flag (true = visible)
  /** @deprecated use sidePanelOpen; kept for migration/rare legacy reads */
  sidebarCollapsed?: boolean; // legacy (true = hidden)

  controlsPinned: boolean;    // keep controls rail visible atop viz
  topBarHeight: number;       // measured in px (ephemeral, not persisted)

  // Diagnostics
  showFps: boolean;           // show FPS overlay

  // Overlays / modals
  modal: UIModal;

  // Actions (canonical)
  setSidePanelOpen: (open: boolean) => void;
  toggleSidePanel: () => void;

  setControlsPinned: (v: boolean) => void;
  toggleControlsPinned: () => void;

  setTopBarHeight: (px: number) => void;

  setShowFps: (v: boolean) => void;
  toggleFps: () => void;

  openModal: (m: UIModal) => void;
  closeModal: () => void;

  /** Reset only ephemeral (non-persisted) bits. */
  resetEphemeral: () => void;

  // Back-compat actions (no-op wrappers that delegate to canonical)
  /** @deprecated use toggleSidePanel */
  toggleSidebar?: () => void;
  /** @deprecated use setSidePanelOpen */
  setSidebarCollapsed?: (v: boolean) => void;
};

/* ----------------------------------------------------------------------------
 * Defaults & persistence
 * ------------------------------------------------------------------------- */

const STORAGE_KEY = "ui-v1";
const STORAGE_VERSION = 3; // bump: introduce sidePanelOpen canonical

/**
 * Default (boot) values. Keep minimal and predictable.
 * Mobile-first collapsed; desktop may auto-open in component on first mount.
 */
const DEFAULTS: UIState = {
  sidePanelOpen: false,
  // legacy shadow value provided for type completeness (not used at runtime)
  sidebarCollapsed: undefined,

  controlsPinned: true,
  topBarHeight: 56,
  showFps: false,
  modal: "none",

  // Filled by store initializer
  setSidePanelOpen: () => {},
  toggleSidePanel: () => {},
  setControlsPinned: () => {},
  toggleControlsPinned: () => {},
  setTopBarHeight: () => {},
  setShowFps: () => {},
  toggleFps: () => {},
  openModal: () => {},
  closeModal: () => {},
  resetEphemeral: () => {},

  // Back-compat placeholders
  toggleSidebar: () => {},
  setSidebarCollapsed: () => {},
};

/**
 * Migration
 *  v1 → v2 (your previous code handled this)
 *  v2 → v3:
 *    - Canonicalize to `sidePanelOpen` (inverse of legacy `sidebarCollapsed`)
 *    - Carry over showFps and controlsPinned
 *    - Do NOT persist/restore ephemeral `modal` and `topBarHeight`
 */
function migrate(persisted: unknown, fromVersion: number): UIState {
  // Start from defaults so ANY missing keys fall back safely.
  const base: UIState = { ...DEFAULTS };

  if (!persisted || typeof persisted !== "object") return base;
  const s = persisted as Partial<Record<keyof UIState, any>>;

  // v1 → v2 mapping existed previously for naming; keep behavior by reading both.
  // v2 → v3 canonicalization happens below.
  // We read both `sidebarCollapsed` and `sidePanelOpen` if present,
  // but prefer explicit `sidePanelOpen` because it's the new canonical flag.
  let sidePanelOpen: boolean | undefined = undefined;

  // If an older persist wrote `sidePanelOpen`, trust it.
  if (typeof (s as any).sidePanelOpen === "boolean") {
    sidePanelOpen = (s as any).sidePanelOpen;
  }

  // Otherwise, infer from legacy `sidebarCollapsed` if available.
  if (typeof (s as any).sidebarCollapsed === "boolean" && sidePanelOpen === undefined) {
    // legacy: collapsed=true meant hidden; open = !collapsed
    sidePanelOpen = !(s as any).sidebarCollapsed;
  }

  // Finalize open flag
  base.sidePanelOpen = sidePanelOpen ?? DEFAULTS.sidePanelOpen;

  // Carry other persisted choices forward
  if (typeof s.controlsPinned === "boolean") base.controlsPinned = s.controlsPinned;
  if (typeof s.showFps === "boolean") base.showFps = s.showFps;

  // Explicitly avoid restoring ephemeral fields
  base.topBarHeight = DEFAULTS.topBarHeight;
  base.modal = "none";

  return base;
}

/* ----------------------------------------------------------------------------
 * Store
 * ------------------------------------------------------------------------- */

export const useUIStore = create<UIState>()(
  persist(
    (set, get) => ({
      ...DEFAULTS,

      // Canonical actions
      setSidePanelOpen: (open) => set({ sidePanelOpen: !!open }),
      toggleSidePanel: () => set({ sidePanelOpen: !get().sidePanelOpen }),

      setControlsPinned: (v) => set({ controlsPinned: !!v }),
      toggleControlsPinned: () => set({ controlsPinned: !get().controlsPinned }),

      setTopBarHeight: (px) => {
        // Clamp to a sane range to avoid broken layout from bad measurements.
        const clamped = Math.max(32, Math.min(128, Math.floor(px || 0)));
        set({ topBarHeight: clamped });
      },

      setShowFps: (v) => set({ showFps: !!v }),
      toggleFps: () => set({ showFps: !get().showFps }),

      openModal: (m) => set({ modal: m }),
      closeModal: () => set({ modal: "none" }),

      resetEphemeral: () => set({ modal: "none", topBarHeight: DEFAULTS.topBarHeight }),

      // Back-compat shims
      toggleSidebar: () => set({ sidePanelOpen: !get().sidePanelOpen }),
      setSidebarCollapsed: (v: boolean) => set({ sidePanelOpen: !v }),
    }),
    {
      name: STORAGE_KEY,
      version: STORAGE_VERSION,
      storage: createJSONStorage(() => localStorage),

      /**
       * Persist only the user *choices* that should stick across sessions.
       * Do NOT persist ephemeral bits like modal/topBarHeight.
       */
      partialize: (s) => ({
        sidePanelOpen: s.sidePanelOpen, // NEW canonical key
        // keep writing this for one more version window if you want dual-writes:
        // sidebarCollapsed: !s.sidePanelOpen,
        controlsPinned: s.controlsPinned,
        showFps: s.showFps,
      }),

      migrate,
    }
  )
);

/* ----------------------------------------------------------------------------
 * Selectors (stable, primitive returns)
 * ------------------------------------------------------------------------- */

export const selectSidePanelOpen = (s: UIState) => s.sidePanelOpen;
export const selectControlsPinned = (s: UIState) => s.controlsPinned;
export const selectShowFps = (s: UIState) => s.showFps;
export const selectModal = (s: UIState) => s.modal;
export const selectTopBarHeight = (s: UIState) => s.topBarHeight;

/* ----------------------------------------------------------------------------
 * Convenience imperative helpers (non-hook usage)
 * ------------------------------------------------------------------------- */

export function openModal(modal: UIModal) {
  useUIStore.getState().openModal(modal);
}
export function closeModal() {
  useUIStore.getState().closeModal();
}

/** Toggle the SidePanel (e.g., from a keyboard shortcut). */
export function toggleSidePanel() {
  useUIStore.getState().toggleSidePanel();
}

/** Programmatically open/close the SidePanel. */
export function setSidePanelOpen(open: boolean) {
  useUIStore.getState().setSidePanelOpen(open);
}

/** Toggle diagnostics overlay. */
export function toggleFps() {
  useUIStore.getState().toggleFps();
}

/* ----------------------------------------------------------------------------
 * Notes
 * -------------------------------------------------------------------------
 * - Components should subscribe with primitive selectors to avoid rerenders:
 *     const isOpen = useUIStore(selectSidePanelOpen);
 * - SidePanel auto-open-on-desktop (first mount) should be implemented in the
 *   component, not here, to keep the store environment-agnostic and testable.
 * - Back-compat shims let older code paths continue to work while we finish
 *   renaming across the codebase.
 */
</file>

<file path="src/lib/state/useVizStore.ts">
// src/lib/state/useVizStore.ts
/**
 * Visualizer state (Phase 1/2)
 * -----------------------------------------------------------------------------
 * Ownership:
 *  - All UI-facing visualizer toggles & curated params that feed Three.js.
 *  - Preset selection & cycling.
 *
 * Persistence:
 *  - LocalStorage via zustand/persist.
 *  - We *intentionally* persist only long-lived choices (theme, toggles,
 *    presetId, params). Ephemeral flags (e.g., hasHydrated) are not persisted.
 *
 * Stability / Safety:
 *  - `version` + `migrate` eliminate rehydrate warnings and keep users' data.
 *  - Runtime clamps & numeric coercion prevent NaN/undefined bugs that crash
 *    controls (e.g., `.toFixed()` on undefined).
 *  - `hasHydrated` lets components wait until persistence is ready.
 *
 * Performance:
 *  - Export small, *primitive* selectors to avoid React "getSnapshot" loops.
 *  - Provide non-hook helpers for render-loop code (Three.js, workers).
 */

import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

/* ----------------------------------------------------------------------------
 * Types
 * ------------------------------------------------------------------------- */

export type VizPresetId = "nebula" | "glass-waves" | "strobe-pulse";

export type VizParams = {
  intensity: number;     // 0..1
  bloom: number;         // 0..0.5 (design clamp 0.25 to protect FPS)
  motionScale: number;   // 0..1
  smooth: number;        // 0..1 analyser smoothing (visual inertia)
  baseColor: string;     // CSS color token
  reactiveHue: string;   // CSS color token
  accent: string;        // CSS color token
  particleCount: number; // visual density (Three scene may cap by tier)
};

type VizState = {
  // Theme
  theme: "dark" | "system";

  // Toggles
  hdr: boolean;          // enable HDR post-processing pipeline
  dimmer: boolean;       // reduce overall brightness for readability

  // Selection
  presetId: VizPresetId;

  // Curated params (uniform-friendly)
  params: VizParams;

  // Persist hydration guard
  hasHydrated: boolean;

  // Actions
  setParam: <K extends keyof VizParams>(k: K, v: VizParams[K]) => void;
  setPreset: (id: VizPresetId) => void;
  cyclePreset: () => void;
  toggleHDR: () => void;
  toggleDimmer: () => void;
};

/* ----------------------------------------------------------------------------
 * Presets (tasteful, aligned to our palette)
 * ------------------------------------------------------------------------- */

const PRESET_ORDER: VizPresetId[] = ["nebula", "glass-waves", "strobe-pulse"];

const PRESET_TABLE: Record<VizPresetId, Partial<VizParams>> = {
  nebula: {
    intensity: 0.4,
    bloom: 0.18,
    motionScale: 0.25,
    baseColor: "#1A2B45",   // Deep Indigo
    reactiveHue: "#7F6A9F", // Soft Lavender
    accent: "#00F0FF",      // Radiant Aqua
  },
  "glass-waves": {
    intensity: 0.6,
    bloom: 0.22,
    motionScale: 0.35,
    baseColor: "#1A2B45",
    reactiveHue: "#7F6A9F",
    accent: "#00F0FF",
  },
  "strobe-pulse": {
    intensity: 0.8,
    bloom: 0.25,
    motionScale: 0.5,
    baseColor: "#1A2B45",
    reactiveHue: "#7F6A9F",
    accent: "#00F0FF",
  },
};

/* ----------------------------------------------------------------------------
 * Helpers (clamps, numeric coercion)
 * ------------------------------------------------------------------------- */

const clamp01 = (n: number) => Math.min(1, Math.max(0, n));
const clampBloom = (n: number) => Math.min(0.25, Math.max(0, n)); // guard FPS
const clampParticles = (n: number) => Math.max(1_000, Math.min(250_000, n));

const num = (v: unknown, fallback: number) => {
  const n = typeof v === "number" ? v : Number(v);
  return Number.isFinite(n) ? n : fallback;
};

/* ----------------------------------------------------------------------------
 * Defaults
 * ------------------------------------------------------------------------- */

const DEFAULTS: VizState = {
  theme: "dark",
  hdr: false,
  dimmer: false,
  presetId: "nebula",
  params: {
    intensity: 0.4,
    bloom: 0.18,
    motionScale: 0.25,
    smooth: 0.8,
    baseColor: "#1A2B45",
    reactiveHue: "#7F6A9F",
    accent: "#00F0FF",
    particleCount: 40_000,
  },
  hasHydrated: false,

  setParam: () => {},
  setPreset: () => {},
  cyclePreset: () => {},
  toggleHDR: () => {},
  toggleDimmer: () => {},
};

const STORE_KEY = "viz-v1";     // storage bucket name (kept stable)
const STORE_VERSION = 2;        // bump when shape changes

// Persisted shape from v1 for migration typing
type PersistShapeV1 = Omit<
  VizState,
  | "hasHydrated"
  | "setParam"
  | "setPreset"
  | "cyclePreset"
  | "toggleHDR"
  | "toggleDimmer"
>;

/* ----------------------------------------------------------------------------
 * Store
 * ------------------------------------------------------------------------- */

export const useVizStore = create<VizState>()(
  persist(
    (set, get) => ({
      ...DEFAULTS,

      // Update a single param with coercion/clamps to prevent NaNs
      setParam: (k, v) => {
        const cur = get().params;
        let nextVal = v;

        if (typeof cur[k] === "number") {
          const raw = num(v, cur[k] as number);
          if (k === "bloom") nextVal = clampBloom(raw) as VizParams[typeof k];
          else if (k === "intensity" || k === "motionScale" || k === "smooth")
            nextVal = clamp01(raw) as VizParams[typeof k];
          else if (k === "particleCount")
            nextVal = clampParticles(raw) as VizParams[typeof k];
          else nextVal = raw as VizParams[typeof k];
        }

        set({ params: { ...cur, [k]: nextVal } });
      },

      // Apply a curated preset (merge with current while re-clamping)
      setPreset: (id) => {
        const base = get().params;
        const override = PRESET_TABLE[id] || {};
        const merged: VizParams = {
          ...base,
          ...override,
          intensity: clamp01(num(override.intensity ?? base.intensity, DEFAULTS.params.intensity)),
          bloom: clampBloom(num(override.bloom ?? base.bloom, DEFAULTS.params.bloom)),
          motionScale: clamp01(num(override.motionScale ?? base.motionScale, DEFAULTS.params.motionScale)),
          smooth: clamp01(num(base.smooth, DEFAULTS.params.smooth)),
          particleCount: clampParticles(num(base.particleCount, DEFAULTS.params.particleCount)),
        };
        set({ presetId: id, params: merged });
      },

      // Cycle through the curated preset list
      cyclePreset: () => {
        const idx = PRESET_ORDER.indexOf(get().presetId);
        const next = PRESET_ORDER[(idx + 1) % PRESET_ORDER.length];
        get().setPreset(next);
      },

      toggleHDR: () => set({ hdr: !get().hdr }),
      toggleDimmer: () => set({ dimmer: !get().dimmer }),
    }),
    {
      name: STORE_KEY,
      version: STORE_VERSION,
      storage: createJSONStorage(() => localStorage),

      // Persist only durable choices (not ephemeral flags/functions)
      partialize: (s) => ({
        theme: s.theme,
        hdr: s.hdr,
        dimmer: s.dimmer,
        presetId: s.presetId,
        params: s.params,
      }),

      // v1 -> v2 migration with clamps & safe defaults
      migrate: (persisted: unknown, fromVersion) => {
        if (!persisted || typeof persisted !== "object") return DEFAULTS;

        const src = persisted as Partial<PersistShapeV1>;

        const pid: VizPresetId =
          src?.presetId === "glass-waves" || src?.presetId === "strobe-pulse" ? src.presetId : "nebula";

        const merged: VizState = {
          ...DEFAULTS,
          theme: src?.theme === "system" ? "system" : "dark",
          hdr: Boolean(src?.hdr),
          dimmer: Boolean(src?.dimmer),
          presetId: pid,
          params: {
            ...DEFAULTS.params,
            ...(src?.params || {}),
            intensity: clamp01(num(src?.params?.intensity, DEFAULTS.params.intensity)),
            bloom: clampBloom(num(src?.params?.bloom, DEFAULTS.params.bloom)),
            motionScale: clamp01(num(src?.params?.motionScale, DEFAULTS.params.motionScale)),
            smooth: clamp01(num(src?.params?.smooth, DEFAULTS.params.smooth)),
            baseColor: (src?.params?.baseColor ?? DEFAULTS.params.baseColor) as string,
            reactiveHue: (src?.params?.reactiveHue ?? DEFAULTS.params.reactiveHue) as string,
            accent: (src?.params?.accent ?? DEFAULTS.params.accent) as string,
            particleCount: clampParticles(num(src?.params?.particleCount, DEFAULTS.params.particleCount)),
          },
          hasHydrated: false,
        };

        switch (fromVersion) {
          case 0:
          case 1:
          default:
            return merged;
        }
      },

      // Flip hydration flag + final sanitize after rehydrate completes
      onRehydrateStorage: () => (state, error) => {
        if (error) {
          useVizStore.setState({ ...DEFAULTS, hasHydrated: true });
          return;
        }
        const s = useVizStore.getState();
        useVizStore.setState({
          hasHydrated: true,
          params: {
            ...s.params,
            intensity: clamp01(num(s.params.intensity, DEFAULTS.params.intensity)),
            bloom: clampBloom(num(s.params.bloom, DEFAULTS.params.bloom)),
            motionScale: clamp01(num(s.params.motionScale, DEFAULTS.params.motionScale)),
            smooth: clamp01(num(s.params.smooth, DEFAULTS.params.smooth)),
            particleCount: clampParticles(num(s.params.particleCount, DEFAULTS.params.particleCount)),
          },
        });
      },
    }
  )
);

/* ----------------------------------------------------------------------------
 * Selector helpers (stable primitives -> minimal re-renders)
 * ------------------------------------------------------------------------- */
export const selectHasHydrated = (s: VizState) => s.hasHydrated;
export const selectHDR = (s: VizState) => s.hdr;
export const selectDimmer = (s: VizState) => s.dimmer;
export const selectPresetId = (s: VizState) => s.presetId;
// Prefer selecting individual numbers in UI controls to avoid object identities:
export const selectIntensity = (s: VizState) => s.params.intensity;
export const selectBloom = (s: VizState) => s.params.bloom;
export const selectMotionScale = (s: VizState) => s.params.motionScale;
export const selectSmooth = (s: VizState) => s.params.smooth;
export const selectParticleCount = (s: VizState) => s.params.particleCount;

/* ----------------------------------------------------------------------------
 * Non-React helpers (for render loops, workers, or imperative code)
 * ------------------------------------------------------------------------- */
export const getVizParams = () => useVizStore.getState().params;
export const getVizToggles = () => {
  const { hdr, dimmer } = useVizStore.getState();
  return { hdr, dimmer };
};
export const cyclePreset = () => useVizStore.getState().cyclePreset();
</file>

<file path="src/lib/streaming/HlsController.ts">
// src/lib/streaming/HlsController.ts
/**
 * HlsController (Phase 2)
 * -----------------------------------------------------------------------------
 * A tiny wrapper that:
 *  - Uses native HLS when the browser can play "application/vnd.apple.mpegurl"
 *  - Otherwise lazily dynamic-imports `hls.js` (if present), attaches it,
 *    and loads the source
 *
 * CONTRACT with AudioEngine:
 *  - default export is a constructible class
 *  - methods:
 *      async attach(audio: HTMLMediaElement, url: string): Promise<void>
 *      destroy(): void
 *
 * AudioEngine integration reference (already implemented):
 *   const mod = await import("@/lib/streaming/HlsController").catch(() => null);
 *   const hls = typeof mod.default === "function" ? new mod.default() : mod;
 *   await hls.attach(this.audio, url);
 *   this.hls = hls; // later: this.hls?.destroy();
 *
 * Notes:
 * - This file uses dynamic import for `hls.js` only when needed. You can mark
 *   `hls.js` as an optional dependency; the native path still works without it.
 * - SSR-safe: All DOM usage is guarded; only run in the browser.
 */

type HlsCtor = new (config?: Record<string, any>) => {
  destroy(): void;
  attachMedia(media: HTMLMediaElement): void;
  loadSource(url: string): void;
  on(evt: any, cb: (...args: any[]) => void): void;
  off(evt: any, cb: (...args: any[]) => void): void;
};
type HlsNamespace = {
  default?: HlsCtor;
  isSupported?: () => boolean;
  Events?: Record<string, any>;
};

function isBrowser(): boolean {
  return typeof window !== "undefined" && typeof document !== "undefined";
}

function supportsNativeHls(media: HTMLMediaElement): boolean {
  if (!media || typeof media.canPlayType !== "function") return false;
  // Common MIME for HLS playlists
  const mime = 'application/vnd.apple.mpegurl';
  return !!media.canPlayType(mime);
}

export default class HlsController {
  /** hls.js instance when used; otherwise null for native path. */
  private hls: InstanceType<HlsCtor> | null = null;
  private audio: HTMLMediaElement | null = null;
  private url: string | null = null;

  /** Track bound handlers so we can detach cleanly if we attach events. */
  private readonly _bound = {
    onError: (..._args: any[]) => {},
    onMediaAttached: (..._args: any[]) => {},
    onManifestParsed: (..._args: any[]) => {},
  };

  /**
   * Attach a media element + URL to this controller.
   * - If native HLS is supported, sets `audio.src` directly.
   * - Else, attempts to import and use `hls.js`.
   */
  async attach(audio: HTMLMediaElement, url: string): Promise<void> {
    if (!isBrowser()) return; // No-op during SSR

    // If re-attaching, make sure we tear down prior state first.
    this.destroy();

    this.audio = audio;
    this.url = url;

    // Try native HLS first (Safari et al.)
    if (supportsNativeHls(audio)) {
      // For CORS-friendly analyzers; AudioEngine already sets this but keep safe.
      if (!audio.crossOrigin) audio.crossOrigin = "anonymous";
      audio.src = url;
      // Note: `.load()` is optional here; the engine will `.play()` as needed.
      return;
    }

    // Fallback to hls.js, loaded on-demand
    let HlsMod: HlsNamespace | null = null;
    try {
      HlsMod = await import(/* @vite-ignore */ "hls.js");
    } catch {
      // If hls.js is not present, we can't play HLS in non-Safari browsers.
      // As a last resort, assign src anyway — some UAs may do partial support.
      this.audio.src = url;
      return;
    }

    const HlsCtor = (HlsMod.default || (HlsMod as any)) as HlsCtor;
    const isSupported = (HlsMod.isSupported || (HlsCtor as any).isSupported || (() => false)) as () => boolean;

    if (!isSupported()) {
      // Same fallback as above
      this.audio.src = url;
      return;
    }

    // Construct hls.js with sensible defaults for desktop playback
    this.hls = new HlsCtor({
      // Keep worker/LL options conservative; can be tuned later
      enableWorker: true,
      lowLatencyMode: false,
      backBufferLength: 60, // seconds
      // You may add ABR/level selection hooks as needed
    });

    // Wire event listeners (optional but useful for diagnostics)
    const Events = (HlsMod.Events || (HlsCtor as any).Events) ?? {};
    this._bound.onError = (_evt: any, data?: any) => {
      // Non-fatal errors can often be ignored; fatal ones may require recover/level switch.
      if (data?.fatal) {
        try {
          // @ts-expect-error - hls.js typed APIs vary by version; defensive calls
          if (data?.type === "networkError" && (this.hls as any)?.startLoad) {
            (this.hls as any).startLoad();
          } else if ((this.hls as any)?.recoverMediaError) {
            (this.hls as any).recoverMediaError();
          }
        } catch {
          /* ignore */
        }
      }
    };
    this._bound.onMediaAttached = () => {
      // After media is attached, load source.
      try {
        this.hls?.loadSource(url);
      } catch {
        // If loadSource throws, fallback to element src.
        if (this.audio) this.audio.src = url;
      }
    };
    this._bound.onManifestParsed = () => {
      // No-op: AudioEngine drives play()
    };

    // Attach and kick off loading
    try {
      this.hls.attachMedia(audio);
      if (Events.ERROR) this.hls.on(Events.ERROR, this._bound.onError);
      if (Events.MEDIA_ATTACHED) this.hls.on(Events.MEDIA_ATTACHED, this._bound.onMediaAttached);
      if (Events.MANIFEST_PARSED) this.hls.on(Events.MANIFEST_PARSED, this._bound.onManifestParsed);
    } catch {
      // Fallback to direct assignment if attach fails
      this.detachHls();
      this.audio.src = url;
    }
  }

  /**
   * Teardown and release resources. Safe to call multiple times.
   * - Destroys hls.js instance and detaches from the element.
   * - Clears `audio.src` only if we were the ones to set it for HLS;
   *   the AudioEngine handles full media reset during `destroy()`.
   */
  destroy(): void {
    // Detach/destroy hls.js instance if present
    this.detachHls();

    // Do NOT force-clear element src here unconditionally; AudioEngine owns it.
    this.audio = null;
    this.url = null;
  }

  // Internal helper to detach hls.js cleanly
  private detachHls() {
    const hls = this.hls as any;
    if (!hls) return;

    try {
      // Remove events if present
      const Events = (hls.constructor && hls.constructor.Events) || {};
      if (Events.ERROR && this._bound.onError) hls.off?.(Events.ERROR, this._bound.onError);
      if (Events.MEDIA_ATTACHED && this._bound.onMediaAttached) hls.off?.(Events.MEDIA_ATTACHED, this._bound.onMediaAttached);
      if (Events.MANIFEST_PARSED && this._bound.onManifestParsed) hls.off?.(Events.MANIFEST_PARSED, this._bound.onManifestParsed);
    } catch {
      /* ignore */
    }

    try {
      // Prefer hls.detachMedia() then destroy()
      if (typeof hls.detachMedia === "function") hls.detachMedia();
    } catch {
      /* ignore */
    }

    try {
      hls.destroy();
    } catch {
      /* ignore */
    }

    this.hls = null;
  }
}
</file>

<file path="src/lib/three/components/ParticlesField.ts">
// src/lib/three/components/ParticlesField.ts
import * as THREE from 'three'
import vertexShader from '../shaders/particles.vert?raw'
import fragmentShader from '../shaders/particles.frag?raw'
import { analyserBus } from '@/lib/audio/AnalyserBus'
import { useVizStore } from '@/lib/state/useVizStore'
import { usePlayerStore } from '@/lib/state/usePlayerStore'
import { FpsGuard } from '@/lib/utils/FpsGuard'
import { onVisibilityChange } from '@/lib/utils/Visibility'
import { onReducedMotionChange } from '@/lib/utils/ReducedMotion'

const modeFromCurve = (curve: 'nebula' | 'waves' | 'strobe'): number => {
  if (curve === 'waves') return 1
  if (curve === 'strobe') return 2
  return 0
}

export class ParticlesField {
  private renderer!: THREE.WebGLRenderer
  private scene!: THREE.Scene
  private camera!: THREE.PerspectiveCamera
  private points!: THREE.Points
  private uniforms!: Record<string, THREE.IUniform>
  private disposed = false
  private animationId: number | null = null

  private unsubViz?: () => void
  private unsubPlayer?: () => void
  private offVisibility?: () => void
  private offReducedMotion?: () => void

  private pixelRatioSteps = [0.75, 1, 1.5, 2] as const
  private prIndex = 1
  private guard!: FpsGuard

  private hidden = false
  private reducedMotion = false
  private isPlaying = false
  private particleCount = 0

  constructor(private container: HTMLElement) {}

  init() {
    // Renderer
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    })
    const initialPR = Math.min(2, window.devicePixelRatio || 1)
    this.prIndex = this.pixelRatioSteps.findIndex((p) => p >= initialPR)
    if (this.prIndex < 0) this.prIndex = 1
    this.renderer.setPixelRatio(this.pixelRatioSteps[this.prIndex])
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight)
    this.container.appendChild(this.renderer.domElement)

    // FPS guard
    this.guard = new FpsGuard((dir) => {
      if (dir === 'down' && this.prIndex > 0) {
        this.prIndex -= 1
        this.renderer.setPixelRatio(this.pixelRatioSteps[this.prIndex])
      } else if (dir === 'up' && this.prIndex < this.pixelRatioSteps.length - 1) {
        this.prIndex += 1
        this.renderer.setPixelRatio(this.pixelRatioSteps[this.prIndex])
      }
    })

    // Scene + Camera
    this.scene = new THREE.Scene()
    this.camera = new THREE.PerspectiveCamera(
      55,
      this.container.clientWidth / this.container.clientHeight,
      0.1,
      100
    )
    this.camera.position.z = 8

    // Initial params
    const p = useVizStore.getState().params
    this.particleCount = p.particleCount

    // Geometry + material
    const geometry = this.buildGeometry(this.particleCount)
    this.uniforms = {
      u_energyLow: { value: 0 },
      u_energyMid: { value: 0 },
      u_energyHigh: { value: 0 },
      u_time: { value: 0 },
      u_baseColor: { value: new THREE.Color(p.baseColor) },
      u_accentColor: { value: new THREE.Color(p.accentColor) },
      u_intensity: { value: p.intensity },
      u_motionScale: { value: p.motionScale },
      u_mode: { value: modeFromCurve(p.curve) }
    }
    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: this.uniforms,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    })
    this.points = new THREE.Points(geometry, material)
    this.scene.add(this.points)

    // Subscribe: visualizer params
    this.unsubViz = useVizStore.subscribe(
      (s) => s.params,
      (params) => {
        ;(this.uniforms.u_baseColor.value as THREE.Color).set(params.baseColor)
        ;(this.uniforms.u_accentColor.value as THREE.Color).set(params.accentColor)
        this.uniforms.u_intensity.value = params.intensity
        this.uniforms.u_motionScale.value = params.motionScale
        this.uniforms.u_mode.value = modeFromCurve(params.curve)

        if (params.particleCount !== this.particleCount) {
          this.particleCount = params.particleCount
          this.rebuildGeometry(this.particleCount)
        }
      },
      { fireImmediately: false }
    )

    // Subscribe: player state
    this.isPlaying = usePlayerStore.getState().isPlaying
    this.unsubPlayer = usePlayerStore.subscribe(
      (s) => s.isPlaying,
      (v) => {
        this.isPlaying = v
      },
      { fireImmediately: false }
    )

    // Visibility + reduced motion
    this.offVisibility = onVisibilityChange((hidden) => {
      this.hidden = hidden
    })
    this.offReducedMotion = onReducedMotionChange((reduced) => {
      this.reducedMotion = reduced
    })

    // Resize
    const resizeObserver = new ResizeObserver(() => {
      this.camera.aspect = this.container.clientWidth / this.container.clientHeight
      this.camera.updateProjectionMatrix()
      this.renderer.setSize(this.container.clientWidth, this.container.clientHeight)
    })
    resizeObserver.observe(this.container)

    // Animation loop
    const loop = (time: number) => {
      if (this.disposed) return

      if (!this.hidden) {
        const { low, mid, high } = analyserBus.sample()
        this.uniforms.u_energyLow.value = this.isPlaying ? low : low * 0.2
        this.uniforms.u_energyMid.value = this.isPlaying ? mid : mid * 0.2
        this.uniforms.u_energyHigh.value = this.isPlaying ? high : high * 0.2
        this.uniforms.u_time.value = time * 0.001

        const rmFactor = this.reducedMotion ? 0 : 1
        const ms = (this.uniforms.u_motionScale.value as number) * rmFactor
        this.camera.position.x = Math.sin(time * 0.0003) * 0.15 * ms
        this.camera.position.y = Math.cos(time * 0.00025) * 0.12 * ms
        this.camera.lookAt(0, 0, 0)

        this.renderer.render(this.scene, this.camera)
        this.guard.tick(time)
      }

      this.animationId = requestAnimationFrame(loop)
    }
    this.animationId = requestAnimationFrame(loop)

    // Cleanup
    return () => {
      this.disposed = true
      if (this.animationId) cancelAnimationFrame(this.animationId)
      resizeObserver.disconnect()
      this.unsubViz?.()
      this.unsubPlayer?.()
      this.offVisibility?.()
      this.offReducedMotion?.()
      this.scene.clear()
      this.renderer.dispose()
      this.container.innerHTML = ''
    }
  }

  private buildGeometry(count: number) {
    const positions = new Float32Array(count * 3)
    const scales = new Float32Array(count)
    const area = 6
    for (let i = 0; i < count; i++) {
      positions[i * 3] = (Math.random() - 0.5) * area
      positions[i * 3 + 1] = (Math.random() - 0.5) * area
      positions[i * 3 + 2] = (Math.random() - 0.5) * area
      scales[i] = Math.random() * 2 + 1
    }
    const geometry = new THREE.BufferGeometry()
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3))
    geometry.setAttribute('scale', new THREE.Float32BufferAttribute(scales, 1))
    return geometry
  }

  private rebuildGeometry(count: number) {
    const newGeom = this.buildGeometry(count)
    const oldGeom = this.points.geometry
    this.points.geometry = newGeom
    oldGeom.dispose()
  }
}
</file>

<file path="src/lib/three/components/PostProcessing.ts">
/**
 * PostProcessing
 * - Wraps EffectComposer with RenderPass + optional passes (Bloom, FXAA/SMAA).
 * - Always constructs a composer, even if HDR/post is disabled (prevents null calls).
 * - Safe setSize(): tolerates partial init and updates AA uniforms.
 */

import {
  WebGLRenderer,
  Scene,
  Camera,
  NoToneMapping,
  ACESFilmicToneMapping,
} from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
import { SMAAPass } from "three/examples/jsm/postprocessing/SMAAPass.js";
import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
import { FXAAShader } from "three/examples/jsm/shaders/FXAAShader.js";

export type PostOptions = {
  /** enable HDR tone mapping path */
  hdrEnabled: boolean;
  /** tone mapping exposure */
  exposure: number; // [0.6..1.6] (clamped by store)
  /** which AA should be used; if both false, no post AA */
  aaEnabled: boolean; // for V1, we use FXAA by default when true
  /** scene bloom strength, 0 disables the pass */
  bloomStrength: number; // [0..~0.35]
  /** DPR override from guard (0.5..1) */
  bufferScale: number; // DPR scale from FpsGuard/useVizStore
};

export class PostProcessing {
  private renderer: WebGLRenderer;
  private composer?: EffectComposer;
  private renderPass?: RenderPass;
  private bloomPass?: UnrealBloomPass;
  private smaaPass?: SMAAPass;
  private fxaaPass?: ShaderPass;

  private width = 1;
  private height = 1;
  private dpr = 1;

  private _opts: PostOptions;

  constructor(renderer: WebGLRenderer, scene: Scene, camera: Camera, opts: PostOptions) {
    this.renderer = renderer;
    this._opts = opts;

    // Initialize renderer tone mapping path
    this.applyHdr(opts.hdrEnabled, opts.exposure);

    // Create composer + passes immediately (composer always exists)
    this.composer = new EffectComposer(this.renderer);

    this.renderPass = new RenderPass(scene, camera);
    this.composer.addPass(this.renderPass);

    // Bloom (enabled when strength > 0)
    if (opts.bloomStrength > 0) {
      const bloom = new UnrealBloomPass(/* resolution */ undefined as any, /* strength */ opts.bloomStrength, /* radius */ 0.4, /* threshold */ 0.85);
      this.bloomPass = bloom;
      this.composer.addPass(bloom);
    }

    // AA: prefer FXAA for simplicity and perf (SMAA optional if you toggle later)
    if (opts.aaEnabled) {
      this.fxaaPass = new ShaderPass(FXAAShader);
      this.composer.addPass(this.fxaaPass);
      // SMAA alternative: uncomment to experiment, but only enable one AA pass at once
      // this.smaaPass = new SMAAPass(this.width, this.height);
      // this.composer.addPass(this.smaaPass);
    }
  }

  /** Apply HDR/tone-mapping mode + exposure */
  private applyHdr(hdrOn: boolean, exposure: number) {
    if (hdrOn) {
      this.renderer.toneMapping = ACESFilmicToneMapping;
      this.renderer.toneMappingExposure = exposure;
    } else {
      this.renderer.toneMapping = NoToneMapping;
      this.renderer.toneMappingExposure = 1.0;
    }
  }

  /** Update size and DPR (call on init and on resize) */
  setSize(width: number, height: number, devicePixelRatio: number) {
    // record desired values
    this.width = Math.max(1, Math.floor(width));
    this.height = Math.max(1, Math.floor(height));
    this.dpr = Math.max(0.25, Math.min(2, devicePixelRatio)); // clamp for safety

    // Update renderer first
    this.renderer.setPixelRatio(this.dpr * (this._opts.bufferScale || 1));
    this.renderer.setSize(this.width, this.height, false);

    // Composer may not exist momentarily if constructor errored; guard calls
    if (this.composer) {
      this.composer.setPixelRatio(this.dpr * (this._opts.bufferScale || 1));
      this.composer.setSize(this.width, this.height);
    }

    // FXAA uniform expects inverse resolution in *rendering* pixels
    if (this.fxaaPass && this.fxaaPass.uniforms?.["resolution"]) {
      const invW = 1 / (this.width * this.dpr);
      const invH = 1 / (this.height * this.dpr);
      this.fxaaPass.uniforms["resolution"].value.set(invW, invH);
    }

    // SMAA size update (if used)
    if (this.smaaPass) {
      this.smaaPass.setSize(this.width, this.height);
    }
  }

  /** Toggle HDR on/off and update exposure */
  setHdrEnabled(on: boolean) {
    this._opts.hdrEnabled = !!on;
    this.applyHdr(this._opts.hdrEnabled, this._opts.exposure);
  }

  setExposure(exposure: number) {
    this._opts.exposure = exposure;
    this.applyHdr(this._opts.hdrEnabled, this._opts.exposure);
  }

  /** Enable/disable post AA; rebuild AA pass in place */
  setAAEnabled(on: boolean) {
    this._opts.aaEnabled = !!on;

    if (!this.composer) return;

    // Remove existing AA passes if present
    if (this.fxaaPass) {
      this.composer.removePass(this.fxaaPass);
      this.fxaaPass.dispose?.();
      this.fxaaPass = undefined;
    }
    if (this.smaaPass) {
      this.composer.removePass(this.smaaPass);
      (this.smaaPass as any).dispose?.();
      this.smaaPass = undefined;
    }

    if (this._opts.aaEnabled) {
      // Re-add FXAA (default)
      this.fxaaPass = new ShaderPass(FXAAShader);
      this.composer.addPass(this.fxaaPass);
      // Recompute resolution uniforms
      if (this.fxaaPass.uniforms?.["resolution"]) {
        const invW = 1 / (this.width * this.dpr);
        const invH = 1 / (this.height * this.dpr);
        this.fxaaPass.uniforms["resolution"].value.set(invW, invH);
      }
    }
  }

  /** Adjust bloom strength dynamically; add/remove pass if toggled to/from zero */
  setBloomStrength(strength: number) {
    this._opts.bloomStrength = Math.max(0, strength);

    if (!this.composer) return;

    if (this._opts.bloomStrength <= 0) {
      if (this.bloomPass) {
        this.composer.removePass(this.bloomPass);
        (this.bloomPass as any).dispose?.();
        this.bloomPass = undefined;
      }
      return;
    }

    if (!this.bloomPass) {
      this.bloomPass = new UnrealBloomPass(undefined as any, this._opts.bloomStrength, 0.4, 0.85);
      this.composer.addPass(this.bloomPass);
    } else {
      this.bloomPass.strength = this._opts.bloomStrength;
    }
  }

  /** Change DPR scaling from guard/store and re-apply */
  setBufferScale(scale: number) {
    this._opts.bufferScale = scale;
    this.setSize(this.width, this.height, this.dpr);
  }

  /** Render one frame (always via composer to keep codepath consistent) */
  render() {
    this.composer?.render();
  }

  /** Cleanup */
  dispose() {
    this.bloomPass = undefined;
    this.fxaaPass = undefined;
    this.smaaPass = undefined;
    if (this.composer) {
      // EffectComposer lacks a formal dispose in older examples; GC will collect.
      this.composer = undefined;
    }
  }
}
</file>

<file path="src/lib/three/shaders/particles.frag">
// src/lib/three/shaders/particles.frag
precision highp float;

uniform vec3 u_baseColor;
uniform vec3 u_accentColor;
uniform float u_time;
uniform int u_mode; /* 0 = nebula, 1 = waves, 2 = strobe */

varying float vEnergy;

void main() {
  vec2 uv = gl_PointCoord - vec2(0.5);
  float d = length(uv);
  if (d > 0.5) discard;

  vec3 color = mix(u_baseColor, u_accentColor, clamp(vEnergy * 1.2, 0.0, 1.0));

  if (u_mode == 2) {
    // Strobe Pulse - quick flash on highs
    float pulse = 0.5 + 0.5 * sin(u_time * 12.0);
    color *= 0.8 + 0.6 * smoothstep(0.75, 1.0, pulse);
  }

  float edge = smoothstep(0.5, 0.3, d);
  gl_FragColor = vec4(color, edge);
}
</file>

<file path="src/lib/three/shaders/particles.vert">
// src/lib/three/shaders/particles.vert
precision highp float;

/* Built-in attributes and uniforms (position, modelViewMatrix, projectionMatrix) are provided by Three.js. */
attribute float scale;

uniform float u_energyLow;
uniform float u_energyMid;
uniform float u_energyHigh;
uniform float u_time;
uniform float u_intensity;
uniform float u_motionScale;
uniform int u_mode;  /* 0 = nebula, 1 = waves, 2 = strobe */

varying float vEnergy;

void main() {
  float avgE = (u_energyLow + u_energyMid + u_energyHigh) / 3.0;
  vEnergy = avgE * u_intensity;

  vec3 disp = position;

  if (u_mode == 0) {
    // Nebula - soft 3D swirl
    disp += normalize(position + vec3(0.001)) * vEnergy * 0.6;
    disp.z += sin(u_time * 1.3 + position.x * 0.8) * 0.12 * u_motionScale;
    disp.z += cos(u_time * 1.1 + position.y * 0.7) * 0.10 * u_motionScale;
  } else if (u_mode == 1) {
    // Glass Waves - layered sine bands
    float w1 = sin(position.x * 1.25 + u_time * 0.9);
    float w2 = cos(position.y * 1.15 + u_time * 0.7);
    disp.z += (w1 + w2) * (0.18 + vEnergy * 0.4) * u_motionScale;
  } else {
    // Strobe Pulse - minimal displacement, size pulses
    disp += normalize(position + vec3(0.001)) * vEnergy * 0.25;
  }

  vec4 mv = modelViewMatrix * vec4(disp, 1.0);
  gl_Position = projectionMatrix * mv;

  float pulse = 0.5 + 0.5 * sin(u_time * 12.0);
  float size = scale * (1.0 + vEnergy * 2.2);
  if (u_mode == 2) {
    size = scale * (1.0 + vEnergy * 3.0 * smoothstep(0.7, 1.0, pulse));
  }
  gl_PointSize = size;
}
</file>

<file path="src/lib/three/ContextLossHandler.ts">
// src/lib/three/ContextLossHandler.ts
// Purpose: Robustly handle WebGL context loss & restoration.
// Usage:
//   const detach = attachContextLossHandler(renderer, {
//     onLoss: () => pauseRenderLoop(),
//     onRestore: async () => { await rebuildPipelines(); resumeRenderLoop(); },
//   });
//   // later: detach()

import type * as THREE from "three";

export type ContextLossCallbacks = {
  /** Fired immediately when the browser reports a context loss. */
  onLoss?: () => void | Promise<void>;
  /** Fired after the browser reports a context restore. Recreate FBOs, materials, and composer here. */
  onRestore?: () => void | Promise<void>;
};

/**
 * Attach loss/restore listeners to a renderer's canvas.
 * Prevents default on loss to allow restoration and provides a single detach() cleanup.
 */
export const attachContextLossHandler = (
  renderer: THREE.WebGLRenderer,
  callbacks: ContextLossCallbacks = {}
): (() => void) => {
  const el = renderer.domElement;

  const handleLoss = (e: Event) => {
    // Prevent default so the browser will try to restore automatically.
    if (typeof (e as any).preventDefault === "function") {
      (e as any).preventDefault();
    }
    console.warn("[EtherealHarmony] WebGL context lost");
    callbacks.onLoss?.();
  };

  const handleRestore = () => {
    console.info("[EtherealHarmony] WebGL context restored");
    // Important: renderer state may be reset; caller must recreate render targets/passes/materials.
    callbacks.onRestore?.();
  };

  el.addEventListener("webglcontextlost", handleLoss as EventListener, false);
  el.addEventListener("webglcontextrestored", handleRestore as EventListener, false);

  // Return a disposer to remove listeners when tearing down the renderer.
  return () => {
    el.removeEventListener("webglcontextlost", handleLoss as EventListener, false);
    el.removeEventListener("webglcontextrestored", handleRestore as EventListener, false);
  };
};

/**
 * Programmatically nudge the driver to simulate pressure. Some browsers ignore it.
 * Safe no-op if the extension is unavailable.
 */
export const tryLoseContext = (renderer: THREE.WebGLRenderer): boolean => {
  // @ts-expect-error - the extension type is not in TS DOM lib.
  const ext = renderer.getContext().getExtension?.("WEBGL_lose_context");
  if (ext?.loseContext) {
    ext.loseContext();
    return true;
  }
  return false;
};

/**
 * Attempt to restore a previously lost context (for testing).
 */
export const tryRestoreContext = (renderer: THREE.WebGLRenderer): boolean => {
  // @ts-expect-error - the extension type is not in TS DOM lib.
  const ext = renderer.getContext().getExtension?.("WEBGL_lose_context");
  if (ext?.restoreContext) {
    ext.restoreContext();
    return true;
  }
  return false;
};
</file>

<file path="src/lib/three/SceneController.ts">
/**
 * SceneController
 * - Creates renderer, scene, camera, and PostProcessing in correct order.
 * - Listens to store for HDR/AA/exposure/bufferScale changes.
 */

import {
  WebGLRenderer,
  Scene,
  PerspectiveCamera,
  Color,
} from "three";
import { PostProcessing } from "./components/PostProcessing";
import { useVizStore } from "@/lib/state/useVizStore";

export class SceneController {
  private canvas: HTMLCanvasElement;
  private renderer: WebGLRenderer;
  private scene: Scene;
  private camera: PerspectiveCamera;
  private post: PostProcessing;

  private unsubscribers: Array<() => void> = [];

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;

    // 1) Renderer first
    this.renderer = new WebGLRenderer({
      canvas: this.canvas,
      antialias: false, // we do post AA if enabled
      alpha: true,
      powerPreference: "high-performance",
    });

    // Get initial store values
    const s = useVizStore.getState();
    const { aaEnabled, bufferScale, hdrEnabled, exposure } = {
      aaEnabled: s.aaEnabled,
      bufferScale: s.bufferScale,
      hdrEnabled: s.hdrEnabled,
      exposure: s.exposure,
    };

    // 2) Initial size BEFORE post so passes can compute uniforms
    const width = this.canvas.clientWidth || 1;
    const height = this.canvas.clientHeight || 1;
    const dpr = window.devicePixelRatio || 1;
    this.renderer.setPixelRatio(dpr * bufferScale);
    this.renderer.setSize(width, height, false);

    // 3) Scene & camera
    this.scene = new Scene();
    this.scene.background = new Color("#000000");
    this.camera = new PerspectiveCamera(60, width / height, 0.1, 1000);
    this.camera.position.set(0, 0, 5);

    // 4) Post-processing (composer is always created)
    this.post = new PostProcessing(this.renderer, this.scene, this.camera, {
      hdrEnabled,
      exposure,
      aaEnabled,
      bloomStrength: s.params.bloom, // from store
      bufferScale,
    });
    this.post.setSize(width, height, dpr);

    // 5) Subscribe to store changes we care about
    this.unsubscribers.push(
      useVizStore.subscribe((st) => st.hdrEnabled, (on) => this.post.setHdrEnabled(on)),
      useVizStore.subscribe((st) => st.exposure, (v) => this.post.setExposure(v)),
      useVizStore.subscribe((st) => st.aaEnabled, (on) => this.post.setAAEnabled(on)),
      useVizStore.subscribe((st) => st.params.bloom, (v) => this.post.setBloomStrength(v)),
      useVizStore.subscribe((st) => st.bufferScale, (scale) => this.post.setBufferScale(scale)),
    );
  }

  resize(width: number, height: number) {
    const dpr = window.devicePixelRatio || 1;
    this.post.setSize(width, height, dpr);
    // Update camera aspect if you use perspective
    this.camera.aspect = Math.max(0.0001, width / Math.max(1, height));
    this.camera.updateProjectionMatrix();
  }

  /** render one frame */
  render() {
    this.post.render();
  }

  dispose() {
    this.unsubscribers.forEach((u) => u());
    this.unsubscribers = [];
    this.post.dispose();
    this.renderer.dispose();
  }

  /** Expose scene/camera if your Parts need to add meshes */
  getScene() { return this.scene; }
  getCamera() { return this.camera; }
  getRenderer() { return this.renderer; }
}
</file>

<file path="src/lib/three/VisualizerParams.ts">
/**
 * Shared visualizer types
 * - Keep only types or const name arrays here to avoid duplication of PRESETS data
 * - The store owns the concrete PRESETS object and the logic for defaults
 */

export type VizPresetName = "Nebula" | "Glass Waves" | "Strobe Pulse";

/**
 * Optional convenience list if you need it for external UIs.
 * The store still exposes getPresetList which should be preferred.
 */
export const VIZ_PRESET_NAMES: VizPresetName[] = ["Nebula", "Glass Waves", "Strobe Pulse"];
</file>

<file path="src/lib/three/VisualizerScene.ts">
import { analyserBus } from '@/lib/audio/AnalyserBus'
import { useVizStore } from '@/lib/state/useVizStore'

export class VisualizerScene {
  private three!: typeof import('three')
  private renderer!: import('three').WebGLRenderer
  private scene!: import('three').Scene
  private camera!: import('three').PerspectiveCamera
  private points!: import('three').Points
  private uniforms!: Record<string, { value: any }>
  private disposed = false

  async init(container: HTMLElement) {
    // Lazy load Three.js to keep TTI fast
    this.three = await import('three')

    const { WebGLRenderer, Scene, PerspectiveCamera, BufferGeometry, Float32BufferAttribute, ShaderMaterial, Points } = this.three

    this.renderer = new WebGLRenderer({ antialias: false, alpha: true, powerPreference: 'high-performance' })
    this.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1))
    this.renderer.setSize(container.clientWidth, container.clientHeight)
    this.renderer.setClearColor(0x000000, 0) // transparent
    container.appendChild(this.renderer.domElement)

    this.scene = new Scene()
    this.camera = new PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 100)
    this.camera.position.z = 6

    // Geometry: simple grid of particles
    const count = useVizStore.getState().particleCount
    const positions = new Float32Array(count * 3)
    const side = Math.floor(Math.sqrt(count))
    let ptr = 0
    for (let y = 0; y < side; y++) {
      for (let x = 0; x < side; x++) {
        positions[ptr++] = (x / side - 0.5) * 8
        positions[ptr++] = (y / side - 0.5) * 8
        positions[ptr++] = 0
        if (ptr >= positions.length) break
      }
    }
    const geom = new BufferGeometry()
    geom.setAttribute('position', new Float32BufferAttribute(positions, 3))

    const { baseColor, accentColor, intensity } = useVizStore.getState()
    this.uniforms = {
      u_time: { value: 0 },
      u_low: { value: 0 },
      u_mid: { value: 0 },
      u_high: { value: 0 },
      u_intensity: { value: intensity },
      u_base: { value: new this.three.Color(baseColor) },
      u_accent: { value: new this.three.Color(accentColor) }
    }

    const vert = /* glsl */`
      uniform float u_time;
      uniform float u_low, u_mid, u_high, u_intensity;
      attribute vec3 position;
      void main() {
        float e = (u_low*0.6 + u_mid*0.3 + u_high*0.1) * u_intensity;
        vec3 p = position;
        p.z = sin(p.x*0.8 + u_time*1.6) * e * 1.2 + cos(p.y*0.8 + u_time*1.3) * e * 1.2;
        gl_PointSize = 1.5 + e * 3.0;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
      }
    `
    const frag = /* glsl */`
      precision mediump float;
      uniform vec3 u_base;
      uniform vec3 u_accent;
      uniform float u_high;
      void main(){
        vec2 uv = gl_PointCoord - 0.5;
        float d = dot(uv, uv);
        if (d > 0.25) discard;              // soft round point
        vec3 c = mix(u_base, u_accent, clamp(u_high*1.2, 0.0, 1.0));
        float a = smoothstep(0.25, 0.0, d);
        gl_FragColor = vec4(c, a);
      }
    `
    const mat = new ShaderMaterial({ uniforms: this.uniforms, vertexShader: vert, fragmentShader: frag, transparent: true })
    this.points = new Points(geom, mat)
    this.scene.add(this.points)

    const onResize = () => {
      if (!this.renderer) return
      this.camera.aspect = container.clientWidth / container.clientHeight
      this.camera.updateProjectionMatrix()
      this.renderer.setSize(container.clientWidth, container.clientHeight)
    }
    const ro = new ResizeObserver(onResize); ro.observe(container)

    let raf = 0
    const loop = (t: number) => {
      if (this.disposed) return
      const e = analyserBus.sample()
      const viz = useVizStore.getState()
      this.uniforms.u_time.value = t * 0.001
      this.uniforms.u_low.value = e.low
      this.uniforms.u_mid.value = e.mid
      this.uniforms.u_high.value = e.high
      this.uniforms.u_intensity.value = viz.intensity

      this.renderer.render(this.scene, this.camera)
      raf = requestAnimationFrame(loop)
    }
    raf = requestAnimationFrame(loop)

    // teardown
    return () => {
      this.disposed = true
      cancelAnimationFrame(raf)
      ro.disconnect()
      this.scene.clear()
      this.renderer.dispose()
      container.replaceChildren()
    }
  }
}
</file>

<file path="src/lib/utils/ContrastCheck.ts">
/**
 * src/lib/utils/ContrastCheck.ts
 * Ethereal Harmony — WCAG Contrast Utilities (Phase 1 aligned, Phase 2-ready)
 *
 * Purpose in the project:
 *  - Provide reliable, framework-agnostic color utilities that help our
 *    glassmorphism UI maintain WCAG 2.1 AA contrast targets across dynamic
 *    backgrounds and translucency.
 *  - Zero external dependencies. SSR-safe (no window/document).
 *
 * What this module offers:
 *  - Robust color parsing: HEX (3/4/6/8), rgb()/rgba(), hsl()/hsla().
 *  - Relative luminance and contrast ratio (WCAG 2.1 equations).
 *  - AA / AAA checks for normal and large text.
 *  - Candidate selection: choose best text color for a background.
 *  - Auto-adjustment: nudge a color lighter/darker to reach target contrast.
 *  - Alpha blending helpers: compute effective color of translucent layers,
 *    e.g., our glass card (rgba(255,255,255,0.12)) over the deep indigo base.
 *
 * Design System context (constants included for convenience):
 *  - Glass Tokens:
 *      radius: 16px
 *      blur: 16px
 *      background: rgba(255,255,255,0.12)
 *      border: 1px solid rgba(255,255,255,0.25)
 *  - Palette:
 *      Primary Background: #1A2B45
 *      Primary Accent:     #7F6A9F
 *      Highlight:          #00F0FF
 *
 * Usage notes:
 *  - For UI components, prefer `pickBestTextColor` or `ensureContrast`.
 *  - When placing text on glass panels, compute the *effective background*
 *    using `blendOver()` with the base scene color, then run contrast checks.
 *
 * Privacy/Safety: Local only. No network. No side effects.
 */

/* ----------------------------------------------------------------------------
 * Types
 * ------------------------------------------------------------------------- */

export type RGB = { r: number; g: number; b: number };
export type RGBA = RGB & { a: number };

export type AAOptions = {
  /** WCAG level (default 'AA') */
  level?: "AA" | "AAA";
  /**
   * Treat text as large (≥18pt regular or ≥14pt bold). Large text has a lower
   * contrast threshold per WCAG: 3.0 for AA (vs 4.5 for normal).
   */
  large?: boolean;
};

export type AdjustOptions = {
  /** Desired contrast ratio target. Defaults to 4.5 for normal text. */
  target?: number;
  /**
   * How to push the color if it doesn't meet the target.
   *  - "auto": try both directions and pick the closest that achieves target.
   *  - "lighter": only move towards white.
   *  - "darker": only move towards black.
   */
  mode?: "auto" | "lighter" | "darker";
  /** Max iterations (safety) */
  maxSteps?: number;
  /** Amount of lightness delta applied per iteration (0..1). Default 0.02 (2%). */
  step?: number;
};

export type PickOptions = {
  /** Minimum acceptable contrast (default 4.5) */
  min?: number;
  /** If no candidate meets min, return the *highest* contrast anyway (default true) */
  fallbackToMax?: boolean;
};

/* ----------------------------------------------------------------------------
 * Design tokens (exported for convenience)
 * ------------------------------------------------------------------------- */

export const EH_COLORS = {
  BASE_BG: "#1A2B45",
  ACCENT: "#7F6A9F",
  HIGHLIGHT: "#00F0FF",
  GLASS_BG: "rgba(255,255,255,0.12)",
  GLASS_BORDER: "rgba(255,255,255,0.25)",
} as const;

/* ----------------------------------------------------------------------------
 * Helpers
 * ------------------------------------------------------------------------- */

const clamp01 = (v: number) => Math.max(0, Math.min(1, v));
const clamp255 = (v: number) => Math.max(0, Math.min(255, v | 0));
const toFixed = (n: number, p = 4) => Number(n.toFixed(p));

/* ----------------------------------------------------------------------------
 * Parsing — HEX, rgb(a), hsl(a)
 * ------------------------------------------------------------------------- */

const HEX_3 = /^#([0-9a-f]{3})$/i;
const HEX_4 = /^#([0-9a-f]{4})$/i;
const HEX_6 = /^#([0-9a-f]{6})$/i;
const HEX_8 = /^#([0-9a-f]{8})$/i;

const RGB_RE =
  /^rgba?\(\s*([\d.]+%?)\s*,\s*([\d.]+%?)\s*,\s*([\d.]+%?)(?:\s*[,/]\s*([\d.]+%?))?\s*\)$/i;

const HSL_RE =
  /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+%)\s*,\s*([\d.]+%)(?:\s*[,/]\s*([\d.]+%?))?\s*\)$/i;

const parseHex = (input: string): RGBA | null => {
  let r = 0,
    g = 0,
    b = 0,
    a = 1;

  let m = input.match(HEX_8);
  if (m) {
    const int = parseInt(m[1], 16);
    r = (int >> 24) & 0xff;
    g = (int >> 16) & 0xff;
    b = (int >> 8) & 0xff;
    a = ((int & 0xff) / 255);
    return { r, g, b, a };
  }

  m = input.match(HEX_6);
  if (m) {
    const int = parseInt(m[1], 16);
    r = (int >> 16) & 0xff;
    g = (int >> 8) & 0xff;
    b = int & 0xff;
    return { r, g, b, a };
  }

  m = input.match(HEX_4);
  if (m) {
    const hex = m[1];
    r = parseInt(hex[0] + hex[0], 16);
    g = parseInt(hex[1] + hex[1], 16);
    b = parseInt(hex[2] + hex[2], 16);
    a = parseInt(hex[3] + hex[3], 16) / 255;
    return { r, g, b, a };
  }

  m = input.match(HEX_3);
  if (m) {
    const hex = m[1];
    r = parseInt(hex[0] + hex[0], 16);
    g = parseInt(hex[1] + hex[1], 16);
    b = parseInt(hex[2] + hex[2], 16);
    return { r, g, b, a };
  }

  return null;
};

const pctTo255 = (val: string) => {
  if (val.endsWith("%")) {
    const v = parseFloat(val);
    return clamp255(Math.round((v / 100) * 255));
  }
  return clamp255(Math.round(parseFloat(val)));
};

const parseRgb = (input: string): RGBA | null => {
  const m = input.match(RGB_RE);
  if (!m) return null;
  const r = pctTo255(m[1]);
  const g = pctTo255(m[2]);
  const b = pctTo255(m[3]);
  let a = 1;
  if (m[4] != null) {
    const s = m[4];
    a = s.endsWith("%") ? clamp01(parseFloat(s) / 100) : clamp01(parseFloat(s));
  }
  return { r, g, b, a };
};

const hslToRgb = (h: number, s: number, l: number): RGB => {
  // h:[0,360), s:[0,1], l:[0,1]
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const hh = (h / 60) % 6;
  const x = c * (1 - Math.abs((hh % 2) - 1));
  let r1 = 0,
    g1 = 0,
    b1 = 0;

  if (0 <= hh && hh < 1) [r1, g1, b1] = [c, x, 0];
  else if (1 <= hh && hh < 2) [r1, g1, b1] = [x, c, 0];
  else if (2 <= hh && hh < 3) [r1, g1, b1] = [0, c, x];
  else if (3 <= hh && hh < 4) [r1, g1, b1] = [0, x, c];
  else if (4 <= hh && hh < 5) [r1, g1, b1] = [x, 0, c];
  else if (5 <= hh && hh < 6) [r1, g1, b1] = [c, 0, x];

  const m = l - c / 2;
  const r = clamp255(Math.round((r1 + m) * 255));
  const g = clamp255(Math.round((g1 + m) * 255));
  const b = clamp255(Math.round((b1 + m) * 255));
  return { r, g, b };
};

const parseHsl = (input: string): RGBA | null => {
  const m = input.match(HSL_RE);
  if (!m) return null;
  const h = ((parseFloat(m[1]) % 360) + 360) % 360;
  const s = clamp01(parseFloat(m[2]) / 100);
  const l = clamp01(parseFloat(m[3]) / 100);
  let a = 1;
  if (m[4] != null) {
    const s4 = m[4];
    a = s4.endsWith("%") ? clamp01(parseFloat(s4) / 100) : clamp01(parseFloat(s4));
  }
  const { r, g, b } = hslToRgb(h, s, l);
  return { r, g, b, a };
};

/**
 * Parse any supported color string to RGBA (0–255 + alpha 0–1).
 * Returns null if parsing fails.
 */
export const parseColor = (input: string): RGBA | null => {
  const s = input.trim();
  return (
    parseHex(s) ||
    parseRgb(s) ||
    parseHsl(s) ||
    null
  );
};

/* ----------------------------------------------------------------------------
 * Formatting
 * ------------------------------------------------------------------------- */

export const toHex = (rgb: RGB): string => {
  const r = clamp255(rgb.r).toString(16).padStart(2, "0");
  const g = clamp255(rgb.g).toString(16).padStart(2, "0");
  const b = clamp255(rgb.b).toString(16).padStart(2, "0");
  return `#${r}${g}${b}`.toUpperCase();
};

export const toRgbaString = (rgba: RGBA): string =>
  `rgba(${clamp255(rgba.r)}, ${clamp255(rgba.g)}, ${clamp255(rgba.b)}, ${toFixed(clamp01(rgba.a), 3)})`;

/* ----------------------------------------------------------------------------
 * Luminance & Contrast (WCAG 2.1)
 * ------------------------------------------------------------------------- */

/** Convert 0–255 sRGB → linearized component */
const srgbToLinear = (v: number): number => {
  const c = clamp01(v / 255);
  return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
};

/** Relative luminance (0..1) using WCAG coefficients. */
export const relativeLuminance = (rgb: RGB): number => {
  const r = srgbToLinear(rgb.r);
  const g = srgbToLinear(rgb.g);
  const b = srgbToLinear(rgb.b);
  // ITU-R BT.709
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
};

/** Contrast ratio between two colors (>=1, <=21). Order independent. */
export const contrastRatio = (a: RGB, b: RGB): number => {
  const L1 = relativeLuminance(a);
  const L2 = relativeLuminance(b);
  const lighter = Math.max(L1, L2);
  const darker = Math.min(L1, L2);
  return (lighter + 0.05) / (darker + 0.05);
};

/** WCAG thresholds */
const AA_NORMAL = 4.5;
const AA_LARGE = 3.0;
const AAA_NORMAL = 7.0;
const AAA_LARGE = 4.5;

/** Check if contrast meets WCAG AA/AAA for text. */
export const meetsWCAG = (fg: RGB, bg: RGB, opts: AAOptions = {}): boolean => {
  const { level = "AA", large = false } = opts;
  const ratio = contrastRatio(fg, bg);
  if (level === "AAA") return ratio >= (large ? AAA_LARGE : AAA_NORMAL);
  // AA
  return ratio >= (large ? AA_LARGE : AA_NORMAL);
};

/* ----------------------------------------------------------------------------
 * Alpha blending
 * ------------------------------------------------------------------------- */

/**
 * Blend a foreground color (with alpha) over an opaque background.
 * Returns the resulting *opaque* RGB.
 */
export const blendOver = (fg: RGBA, bg: RGB): RGB => {
  const a = clamp01(fg.a);
  const r = Math.round(fg.r * a + bg.r * (1 - a));
  const g = Math.round(fg.g * a + bg.g * (1 - a));
  const b = Math.round(fg.b * a + bg.b * (1 - a));
  return { r, g, b };
};

/**
 * Compute the effective background of a standard EH glass panel over a base bg.
 * Defaults to our design tokens.
 */
export const effectiveGlassBackground = (
  baseBg: string = EH_COLORS.BASE_BG,
  glass: string = EH_COLORS.GLASS_BG
): RGB => {
  const base = parseColor(baseBg);
  const pane = parseColor(glass);
  if (!base || !pane) {
    // Fallback to base background if parsing fails.
    const b = parseColor(EH_COLORS.BASE_BG)!;
    return { r: b.r, g: b.g, b: b.b };
  }
  return blendOver(pane, base);
};

/* ----------------------------------------------------------------------------
 * Candidate selection & adjustment
 * ------------------------------------------------------------------------- */

/**
 * Choose the best text color from candidates for a given background.
 * Returns the first candidate that meets the `min` contrast (default 4.5).
 * If none meet it and `fallbackToMax` is true, returns the highest-contrast one.
 */
export const pickBestTextColor = (
  bg: string,
  candidates: string[] = ["#FFFFFF", "#000000", EH_COLORS.HIGHLIGHT, EH_COLORS.ACCENT],
  opts: PickOptions = {}
): string => {
  const { min = AA_NORMAL, fallbackToMax = true } = opts;
  const bgRGB = parseColor(bg);
  if (!bgRGB) return "#FFFFFF";

  let best = candidates[0];
  let bestRatio = -Infinity;

  for (const c of candidates) {
    const fg = parseColor(c);
    if (!fg) continue;
    const ratio = contrastRatio(fg, bgRGB);
    if (ratio >= min) {
      return toHex(fg); // earliest passing candidate wins (stable preference)
    }
    if (ratio > bestRatio) {
      best = toHex(fg);
      bestRatio = ratio;
    }
  }

  return fallbackToMax ? best : candidates[0];
};

/**
 * Lighten/darken a color in HSL space by `delta` (0..1).
 * Positive delta lightens; negative darkens.
 */
const adjustLightness = (rgb: RGB, delta: number): RGB => {
  // RGB -> HSL
  const r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h = 0, s = 0;
  const l = (max + min) / 2;
  const d = max - min;

  if (d !== 0) {
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h *= 60;
  }

  const l2 = clamp01(l + delta);

  // Reuse existing h/s, convert back
  const { r: rr, g: gg, b: bb } = hslToRgb(h, s, l2);
  return { r: rr, g: gg, b: bb };
};

/**
 * Try to adjust a foreground color towards meeting a target contrast over bg.
 * Returns a new HEX string. If already sufficient, returns the original.
 */
export const ensureContrast = (
  fgStr: string,
  bgStr: string,
  options: AdjustOptions = {}
): string => {
  const target = options.target ?? AA_NORMAL;
  const step = options.step ?? 0.02;
  const maxSteps = options.maxSteps ?? 20;
  const mode = options.mode ?? "auto";

  const fg0 = parseColor(fgStr);
  const bg = parseColor(bgStr);
  if (!fg0 || !bg) return fgStr;

  // If fg has alpha, pre-flatten against bg to measure *visible* contrast,
  // but we return an opaque HEX for stability in UI text colors.
  const fgOpaque: RGB = { r: fg0.r, g: fg0.g, b: fg0.b };

  if (contrastRatio(fgOpaque, bg) >= target) return toHex(fgOpaque);

  const tryDirection = (dir: "lighter" | "darker") => {
    let cur = { ...fgOpaque };
    for (let i = 0; i < maxSteps; i++) {
      cur = adjustLightness(cur, dir === "lighter" ? step : -step);
      if (contrastRatio(cur, bg) >= target) return cur;
    }
    return null;
  };

  if (mode === "lighter" || mode === "darker") {
    const solved = tryDirection(mode);
    return solved ? toHex(solved) : toHex(fgOpaque);
  }

  // auto: evaluate both and pick the one that reaches target with fewer steps,
  // or the one with higher final contrast if neither reaches target.
  let curLight = { ...fgOpaque };
  let curDark = { ...fgOpaque };
  let bestLight: RGB | null = null;
  let bestDark: RGB | null = null;

  for (let i = 0; i < maxSteps; i++) {
    curLight = adjustLightness(curLight, step);
    if (!bestLight && contrastRatio(curLight, bg) >= target) bestLight = { ...curLight };

    curDark = adjustLightness(curDark, -step);
    if (!bestDark && contrastRatio(curDark, bg) >= target) bestDark = { ...curDark };
  }

  if (bestLight && bestDark) {
    // choose the one with minimal total lightness shift (first to reach usually)
    const lightRatio = contrastRatio(bestLight, bg);
    const darkRatio = contrastRatio(bestDark, bg);
    return toHex(lightRatio >= darkRatio ? bestLight : bestDark);
  }
  if (bestLight) return toHex(bestLight);
  if (bestDark) return toHex(bestDark);

  // Neither achieved target — return whichever yields higher contrast at the end.
  const finalContrastLight = contrastRatio(curLight, bg);
  const finalContrastDark = contrastRatio(curDark, bg);
  return toHex(finalContrastLight >= finalContrastDark ? curLight : curDark);
};

/* ----------------------------------------------------------------------------
 * Convenience helpers for EH components
 * ------------------------------------------------------------------------- */

/**
 * Get a recommended text color for a given background. Tries white, black,
 * highlight, accent (in that order), requiring 4.5:1 by default. If none pass,
 * returns the one with highest contrast. This is a good default for labels.
 */
export const pickTextOnBg = (
  bg: string,
  opts: PickOptions = { min: AA_NORMAL, fallbackToMax: true }
): string => pickBestTextColor(bg, ["#FFFFFF", "#000000", EH_COLORS.HIGHLIGHT, EH_COLORS.ACCENT], opts);

/**
 * Compute a safe foreground color for text placed on a glass card rendered
 * above a base scene background.
 *
 * @param baseSceneBg - base color behind the glass (e.g., '#1A2B45')
 * @param preferred   - hint for initial color direction ('light'|'dark')
 * @param target      - contrast target (default AA normal: 4.5)
 */
export const textOnGlass = (
  baseSceneBg: string = EH_COLORS.BASE_BG,
  preferred: "light" | "dark" = "light",
  target: number = AA_NORMAL
): string => {
  const effective = effectiveGlassBackground(baseSceneBg, EH_COLORS.GLASS_BG);
  const start = preferred === "light" ? "#FFFFFF" : "#000000";
  if (meetsWCAG(parseColor(start)!, effective, { level: "AA", large: false })) return start;
  return ensureContrast(start, toHex(effective), { target, mode: preferred === "light" ? "lighter" : "darker" });
};

/* ----------------------------------------------------------------------------
 * Module self-test (non-throwing checks in dev; can be removed for prod)
 * ------------------------------------------------------------------------- */

const __DEV__ = process.env.NODE_ENV !== "production";
if (__DEV__) {
  // Quick sanity checks without throwing (keep silent if anything goes wrong).
  try {
    const bg = parseColor(EH_COLORS.BASE_BG)!;
    const white = parseColor("#FFFFFF")!;
    const ratio = contrastRatio(white, bg);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const _ok = ratio > 1 && ratio <= 21;
  } catch {
    // ignore — do not crash in dev environments that shim process.*
  }
}

export default {
  parseColor,
  toHex,
  toRgbaString,
  relativeLuminance,
  contrastRatio,
  meetsWCAG,
  blendOver,
  effectiveGlassBackground,
  pickBestTextColor,
  ensureContrast,
  pickTextOnBg,
  textOnGlass,
  EH_COLORS,
};
</file>

<file path="src/lib/utils/FocusRing.ts">
/**
 * src/lib/utils/FocusRing.ts
 * Ethereal Harmony — Accessible Focus Ring Utilities (Phase 1 aligned, Phase 2-ready)
 *
 * Purpose in the project:
 *  - Provide a tiny, framework-friendly utility for rendering *consistent*,
 *    high-contrast focus indicators that satisfy WCAG 2.1 AA and match our
 *    glassmorphism aesthetic (Radiant Aqua glow, soft spread).
 *  - Avoid per-component boilerplate and ensure keyboard-only “focus-visible”
 *    behavior across browsers (with a safe polyfill for legacy engines).
 *
 * How it integrates:
 *  - UI components add the returned `className` from `withFocusRing()` or the
 *    hook `useFocusRingClass()` to any focusable element (button, slider thumb,
 *    card, custom role="button", etc). No state management required.
 *  - Global styles are injected once at runtime (SSR/rehydration safe).
 *  - We do not modify audio behavior or global resets. This is purely visual.
 *
 * Design system alignment:
 *  - Glass Tokens:
 *      radius          : 16px
 *      blur            : 16px
 *      background      : rgba(255,255,255,0.12)
 *      border          : 1px solid rgba(255,255,255,0.25)
 *  - Palette:
 *      Base (indigo)   : #1A2B45
 *      Accent (lavender): #7F6A9F
 *      Highlight (aqua): #00F0FF
 *  - The focus ring uses the highlight color with an outer soft halo for
 *    visibility on both dark base and glass surfaces.
 *
 * Accessibility:
 *  - Uses :focus-visible where supported to avoid showing focus on mouse click.
 *  - Polyfills the behavior by tracking input modality (keyboard vs pointer)
 *    and applying styles only when the modality is keyboard.
 *  - Meets AA contrast guidelines by using a solid inner outline + glow.
 *
 * Privacy/Safety:
 *  - No network calls. Local-only. SSR guarded.
 */

import * as React from "react";

/* ----------------------------------------------------------------------------
 * Tokens & Constants
 * ------------------------------------------------------------------------- */

export const FOCUS_TOKENS = {
  color: "#00F0FF", // Radiant Aqua
  innerPx: 2,       // crisp inner outline
  outerPx: 6,       // soft halo width
  radius: 16,       // default border radius
  offset: 0,        // visual offset (kept at 0 for our rounded cards)
};

const IS_BROWSER = typeof window !== "undefined" && typeof document !== "undefined";

/**
 * We install a single <style id="eh-focus-ring-styles"> tag with the core rules.
 * Components just use the utility class names.
 */
const STYLE_ID = "eh-focus-ring-styles";

/* ----------------------------------------------------------------------------
 * One-time style injection (SSR-safe)
 * ------------------------------------------------------------------------- */

let _stylesInstalled = false;

const installStylesOnce = () => {
  if (!IS_BROWSER || _stylesInstalled) return;
  if (document.getElementById(STYLE_ID)) {
    _stylesInstalled = true;
    return;
  }

  const style = document.createElement("style");
  style.id = STYLE_ID;

  // Using CSS variables allows runtime theming if needed.
  style.textContent = `
:root {
  --eh-focus-color: ${FOCUS_TOKENS.color};
  --eh-focus-inner: ${FOCUS_TOKENS.innerPx}px;
  --eh-focus-outer: ${FOCUS_TOKENS.outerPx}px;
  --eh-focus-radius: ${FOCUS_TOKENS.radius}px;
  --eh-focus-offset: ${FOCUS_TOKENS.offset}px;
}

/* Base utility class to attach on focusable elements */
.eh-focus-ring {
  outline: none;               /* avoid default outline to prevent double borders */
  -webkit-tap-highlight-color: transparent;
}

/* Variant to render the ring inside the element's bounds (useful for tight layouts) */
.eh-focus-inset {}

/* ---------------------------------------------
   Modern path: browsers with :focus-visible
   --------------------------------------------- */
.eh-focus-ring:focus-visible {
  box-shadow:
    0 0 0 var(--eh-focus-inner) var(--eh-focus-color),
    0 0 0 calc(var(--eh-focus-inner) + var(--eh-focus-outer)) color-mix(in oklab, var(--eh-focus-color) 40%, transparent);
  border-radius: var(--eh-focus-radius);
  outline: none;
}

/* Inset variant */
.eh-focus-inset:focus-visible {
  box-shadow:
    inset 0 0 0 var(--eh-focus-inner) var(--eh-focus-color),
    inset 0 0 0 calc(var(--eh-focus-inner) + var(--eh-focus-outer)) color-mix(in oklab, var(--eh-focus-color) 28%, transparent);
  border-radius: var(--eh-focus-radius);
  outline: none;
}

/* ---------------------------------------------
   Polyfill path: for browsers lacking :focus-visible
   We add [data-eh-modality="keyboard"] on <html>.
   Only show focus ring when the last input modality was keyboard.
   --------------------------------------------- */
html[data-eh-modality="keyboard"] .eh-focus-ring:focus {
  box-shadow:
    0 0 0 var(--eh-focus-inner) var(--eh-focus-color),
    0 0 0 calc(var(--eh-focus-inner) + var(--eh-focus-outer)) color-mix(in oklab, var(--eh-focus-color) 40%, transparent);
  border-radius: var(--eh-focus-radius);
  outline: none;
}

html[data-eh-modality="keyboard"] .eh-focus-inset:focus {
  box-shadow:
    inset 0 0 0 var(--eh-focus-inner) var(--eh-focus-color),
    inset 0 0 0 calc(var(--eh-focus-inner) + var(--eh-focus-outer)) color-mix(in oklab, var(--eh-focus-color) 28%, transparent);
  border-radius: var(--eh-focus-radius);
  outline: none;
}

/* Respect users who prefer reduced motion by slightly reducing shadow spread.
   (Not strictly "motion", but large glow changes can be distracting.) */
@media (prefers-reduced-motion: reduce) {
  :root {
    --eh-focus-outer: 4px;
  }
}
`.trim();

  document.head.appendChild(style);
  _stylesInstalled = true;
};

/* ----------------------------------------------------------------------------
 * Input modality tracking (lightweight :focus-visible polyfill)
 * ------------------------------------------------------------------------- */

/**
 * We track the last input source (keyboard vs pointer) and mirror it to
 * <html data-eh-modality="keyboard|pointer">. Rules above use this attribute in
 * browsers without :focus-visible.
 */
let _listenersBound = false;

const bindModalityListeners = () => {
  if (!IS_BROWSER || _listenersBound) return;
  _listenersBound = true;

  const root = document.documentElement;

  const setMod = (mod: "keyboard" | "pointer") => {
    // Avoid layout trashing; write only on change.
    if (root.getAttribute("data-eh-modality") !== mod) {
      root.setAttribute("data-eh-modality", mod);
    }
  };

  const onKeyDown = (e: KeyboardEvent) => {
    // Keys that typically move focus or interact without pointer.
    const keys = ["Tab", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    if (keys.includes(e.key)) setMod("keyboard");
  };

  const toPointer = () => setMod("pointer");

  window.addEventListener("keydown", onKeyDown, true);
  window.addEventListener("mousedown", toPointer, true);
  window.addEventListener("pointerdown", toPointer, true);
  window.addEventListener("touchstart", toPointer, { passive: true, capture: true } as any);

  // Initialize to pointer to avoid flashing rings on initial click.
  setMod("pointer");
};

/* ----------------------------------------------------------------------------
 * Runtime configuration API
 * ------------------------------------------------------------------------- */

export type FocusRingOptions = Partial<{
  /** Set custom color for this element or globally via install (hex or css color). */
  color: string;
  /** Border radius in px (defaults to 16). */
  radius: number;
  /** Inner solid outline width in px. */
  inner: number;
  /** Outer glow width in px. */
  outer: number;
  /** Use inset ring variant. */
  inset: boolean;
}>;

/**
 * Apply per-element overrides by returning a className string to append.
 * Adds the base `eh-focus-ring` class and optionally `eh-focus-inset`.
 *
 * Note: Color/size overrides here rely on CSS variables via inline style —
 *       pass the returned `style` object as well if you want overrides.
 */
export const withFocusRing = (
  className?: string,
  opts?: FocusRingOptions
): { className: string; style?: React.CSSProperties } => {
  installStylesOnce();
  bindModalityListeners();

  const classes = ["eh-focus-ring"];
  if (opts?.inset) classes.push("eh-focus-inset");
  if (className) classes.push(className);

  const style: React.CSSProperties = {};
  if (opts?.color) style["--eh-focus-color" as any] = opts.color;
  if (typeof opts?.radius === "number") style["--eh-focus-radius" as any] = `${opts.radius}px`;
  if (typeof opts?.inner === "number") style["--eh-focus-inner" as any] = `${opts.inner}px`;
  if (typeof opts?.outer === "number") style["--eh-focus-outer" as any] = `${opts.outer}px`;

  return { className: classes.join(" "), style: Object.keys(style).length ? style : undefined };
};

/**
 * Hook variant for React components.
 * Usage:
 *   const focus = useFocusRingClass({ inset: true });
 *   <button {...focus}>Play</button>
 */
export const useFocusRingClass = (opts?: FocusRingOptions) => {
  // Install once on mount (safe if called multiple times)
  React.useEffect(() => {
    installStylesOnce();
    bindModalityListeners();
  }, []);

  return React.useMemo(() => withFocusRing(undefined, opts), [opts?.color, opts?.radius, opts?.inner, opts?.outer, opts?.inset]);
};

/**
 * Globally override default tokens *for the entire app* at runtime.
 * Call early in app boot if you need different radii/widths.
 */
export const configureGlobalFocusRing = (tokens: Partial<typeof FOCUS_TOKENS>) => {
  if (!IS_BROWSER) return;
  installStylesOnce();
  const root = document.documentElement;

  if (tokens.color) root.style.setProperty("--eh-focus-color", tokens.color);
  if (typeof tokens.innerPx === "number") root.style.setProperty("--eh-focus-inner", `${tokens.innerPx}px`);
  if (typeof tokens.outerPx === "number") root.style.setProperty("--eh-focus-outer", `${tokens.outerPx}px`);
  if (typeof tokens.radius === "number") root.style.setProperty("--eh-focus-radius", `${tokens.radius}px`);
  if (typeof tokens.offset === "number") root.style.setProperty("--eh-focus-offset", `${tokens.offset}px`);
};

/* ----------------------------------------------------------------------------
 * Convenience helpers for common components
 * ------------------------------------------------------------------------- */

/**
 * Returns props for a standard glass button using our default ring.
 * Example:
 *   <button {...focusButtonProps()}>Play</button>
 */
export const focusButtonProps = (opts?: FocusRingOptions) => {
  const { className, style } = withFocusRing(undefined, opts);
  return { className, style, type: "button" as const };
};

/**
 * Returns props for a focusable non-native element (e.g., a div with role="button").
 * Ensures correct ARIA & keyboard focusability; adds the ring class.
 *
 * Example:
 *   <div {...focusRoleButtonProps({ pressed })} onClick={...}>Toggle</div>
 */
export const focusRoleButtonProps = (opts?: FocusRingOptions & { pressed?: boolean }) => {
  const { className, style } = withFocusRing(undefined, opts);
  return {
    className,
    style,
    role: "button" as const,
    tabIndex: 0,
    "aria-pressed": typeof opts?.pressed === "boolean" ? opts.pressed : undefined,
  };
};

/* ----------------------------------------------------------------------------
 * Minimal React helper component (optional)
 * ------------------------------------------------------------------------- */

/**
 * FocusRingScope ensures styles and modality listeners are present.
 * You can render it once near the root (e.g., inside App.tsx).
 */
export const FocusRingScope: React.FC<{ children?: React.ReactNode }> = ({ children }) => {
  React.useEffect(() => {
    installStylesOnce();
    bindModalityListeners();
  }, []);
  return <>{children}</>;
};

/* ----------------------------------------------------------------------------
 * Notes for maintainers:
 *  - We intentionally keep this file dependency-free and light so it can be
 *    imported anywhere (components, storybook, test scaffolding).
 *  - If we later add theming, prefer exposing a single `configureGlobalFocusRing`
 *    call from the app shell rather than multiplying per-component overrides.
 *  - For sliders/knobs where the focus outline may clip, prefer the `inset`
 *    variant or increase border radius via options.
 * ------------------------------------------------------------------------- */
</file>

<file path="src/lib/utils/FpsGuard.ts">
// src/lib/utils/FpsGuard.ts
export type AdjustDir = 'up' | 'down'

export class FpsGuard {
  private last = performance.now()
  private emaFps = 60
  private lastAdjust = this.last
  private readonly adjustIntervalMs = 2000

  constructor(private onAdjust: (dir: AdjustDir, fps: number) => void) {}

  tick(now: number) {
    const dt = now - this.last
    this.last = now
    if (dt <= 0) return

    const inst = 1000 / dt
    this.emaFps = this.emaFps * 0.9 + inst * 0.1

    if (now - this.lastAdjust < this.adjustIntervalMs) return

    if (this.emaFps < 48) {
      this.onAdjust('down', this.emaFps)
      this.lastAdjust = now
      return
    }
    if (this.emaFps > 59) {
      this.onAdjust('up', this.emaFps)
      this.lastAdjust = now
    }
  }
}
</file>

<file path="src/lib/utils/Hotkeys.ts">
// src/lib/utils/Hotkeys.ts
/**
 * Ethereal Harmony — Global Hotkeys Manager (framework-agnostic, SSR-safe)
 *
 * Purpose:
 *  - Provide a tiny, dependency-free registry for global keyboard shortcuts.
 *  - Avoid per-component listeners and duplicate logic scattered across the app.
 *  - Respect accessibility: ignore shortcuts while typing in inputs/textareas,
 *    unless explicitly allowed per binding.
 *
 * Design:
 *  - Singleton manager attaching one `keydown` listener to window (on first add).
 *  - String combos like: "p", "h", "d", "space", "arrowleft", "ctrl+`", "shift+/"
 *  - Options per binding: preventDefault, allowInInputs, allowRepeat, scope tag.
 *  - Returns an unsubscribe function to remove the binding.
 *
 * SSR:
 *  - All DOM access is guarded. No-ops on the server.
 *
 * NOTE:
 *  - This is intentionally framework-agnostic so both React code and non-React
 *    utilities (e.g., DevToggle) can share hotkey definitions consistently.
 */

export type HotkeyHandler = (e: KeyboardEvent) => void;

export type HotkeyOptions = {
  /** If true (default), e.preventDefault() is called when the combo matches. */
  preventDefault?: boolean;
  /** Allow the hotkey to fire while typing in inputs/textarea/contenteditable. Default false. */
  allowInInputs?: boolean;
  /** Allow the hotkey to fire on auto-repeat (holding down key). Default false. */
  allowRepeat?: boolean;
  /** Optional app-defined scope label (for debugging/cleanup). */
  scope?: string;
};

export type HotkeyRegistration = {
  id: number;
  combo: string;
  handler: HotkeyHandler;
  opts: Required<HotkeyOptions>;
};

const IS_BROWSER = typeof window !== "undefined";

let _enabled = true;
let _nextId = 1;
const _regs: HotkeyRegistration[] = [];
let _listenerBound = false;

/* -------------------------------------------------------------------------- */
/* Helpers                                                                    */
/* -------------------------------------------------------------------------- */

/** Returns true if `el` is an editable/context where typing is expected. */
const isTypingTarget = (el: EventTarget | null): boolean => {
  if (!(el instanceof HTMLElement)) return false;
  const tag = el.tagName.toLowerCase();
  if (tag === "input") {
    const type = (el as HTMLInputElement).type;
    return ["text", "search", "email", "url", "password", "number", "tel"].includes(type);
  }
  return tag === "textarea" || el.isContentEditable || tag === "select";
};

type Combo = {
  key: string; // normalized to e.key.toLowerCase()
  ctrl: boolean;
  alt: boolean;
  shift: boolean;
  meta: boolean;
};

const normalizeKeyName = (k: string) => {
  const key = k.toLowerCase().trim();
  // normalize synonyms
  if (key === "esc") return "escape";
  if (key === "spacebar") return " ";
  if (key === "space") return " ";
  if (key === "left") return "arrowleft";
  if (key === "right") return "arrowright";
  if (key === "up") return "arrowup";
  if (key === "down") return "arrowdown";
  return key;
};

const parseCombo = (combo: string): Combo => {
  const parts = combo.split("+").map((p) => p.trim().toLowerCase());
  let ctrl = false,
    alt = false,
    shift = false,
    meta = false,
    key = "";

  for (const p of parts) {
    if (p === "ctrl" || p === "control") ctrl = true;
    else if (p === "alt" || p === "option") alt = true;
    else if (p === "shift") shift = true;
    else if (p === "meta" || p === "cmd" || p === "command" || p === "super") meta = true;
    else key = normalizeKeyName(p);
  }
  return { key, ctrl, alt, shift, meta };
};

const eventToCombo = (e: KeyboardEvent): Combo => ({
  key: normalizeKeyName(e.key),
  ctrl: !!e.ctrlKey,
  alt: !!e.altKey,
  shift: !!e.shiftKey,
  meta: !!e.metaKey,
});

const combosEqual = (a: Combo, b: Combo) =>
  a.key === b.key && a.ctrl === b.ctrl && a.alt === b.alt && a.shift === b.shift && a.meta === b.meta;

/* -------------------------------------------------------------------------- */
/* Core listener                                                               */
/* -------------------------------------------------------------------------- */

const onKeyDown = (e: KeyboardEvent) => {
  if (!_enabled) return;
  if (!_regs.length) return;

  const fromInput = isTypingTarget(document.activeElement);
  const evCombo = eventToCombo(e);

  // iterate in reverse so later registrations have precedence (LIFO)
  for (let i = _regs.length - 1; i >= 0; i--) {
    const r = _regs[i];
    const want = parseCombo(r.combo);

    if (combosEqual(want, evCombo)) {
      if (!r.opts.allowRepeat && e.repeat) continue;
      if (!r.opts.allowInInputs && fromInput) continue;

      if (r.opts.preventDefault) {
        try {
          e.preventDefault();
        } catch {
          // ignore
        }
      }
      try {
        r.handler(e);
      } catch {
        // never throw from handlers
      }
      // Stop after first match to avoid cascading
      return;
    }
  }
};

const ensureListener = () => {
  if (!_listenerBound && IS_BROWSER) {
    window.addEventListener("keydown", onKeyDown, { passive: false });
    _listenerBound = true;
  }
};

const removeListenerIfIdle = () => {
  if (_listenerBound && IS_BROWSER && _regs.length === 0) {
    window.removeEventListener("keydown", onKeyDown as any);
    _listenerBound = false;
  }
};

/* -------------------------------------------------------------------------- */
/* Public API                                                                  */
/* -------------------------------------------------------------------------- */

export const Hotkeys = {
  /**
   * Register a global hotkey. Returns an unsubscribe function.
   * Example:
   *   const off = Hotkeys.add("ctrl+`", () => togglePanel(), { scope: "diagnostics" });
   *   // later: off()
   */
  add(combo: string, handler: HotkeyHandler, opts: HotkeyOptions = {}) {
    if (!IS_BROWSER) return () => void 0;

    const reg: HotkeyRegistration = {
      id: _nextId++,
      combo,
      handler,
      opts: {
        preventDefault: opts.preventDefault !== false, // default true
        allowInInputs: !!opts.allowInInputs,
        allowRepeat: !!opts.allowRepeat,
        scope: opts.scope ?? "app",
      },
    };
    _regs.push(reg);
    ensureListener();

    return () => {
      const idx = _regs.findIndex((r) => r.id === reg.id);
      if (idx >= 0) _regs.splice(idx, 1);
      removeListenerIfIdle();
    };
  },

  /** Enable/disable processing (does not remove bindings). */
  setEnabled(next: boolean) {
    _enabled = !!next;
  },

  /** Is the manager currently processing events? */
  isEnabled() {
    return _enabled;
  },

  /** Remove all bindings (useful on major route/shell teardown). */
  clear(scope?: string) {
    if (typeof scope === "string") {
      for (let i = _regs.length - 1; i >= 0; i--) {
        if (_regs[i].opts.scope === scope) _regs.splice(i, 1);
      }
    } else {
      _regs.splice(0, _regs.length);
    }
    removeListenerIfIdle();
  },
} as const;

export default Hotkeys;

/* -------------------------------------------------------------------------- */
/* Common combos used across Ethereal Harmony (optional helpers)              */
/* -------------------------------------------------------------------------- */

export const EH_HOTKEYS = {
  TOGGLE_DEV_PANEL: "ctrl+`",
  VIZ_CYCLE_PRESET: "p",
  VIZ_TOGGLE_HDR: "h",
  VIZ_TOGGLE_DIMMER: "d",
  PLAY_PAUSE: " ", // space
  NEXT_TRACK: "arrowright",
  PREV_TRACK: "arrowleft",
} as const;
</file>

<file path="src/lib/utils/IconRegistry.ts">
// src/lib/utils/IconRegistry.ts
/**
 * Central icon mapping + safe <Icon/> wrapper.
 * - Supports both canonical keys and legacy dotted aliases (e.g., "transport.play").
 * - Logs once for unknown names and renders a harmless <span> instead of crashing.
 */

import React from "react";
import {
  // Core UI
  Menu,
  ChevronLeft,
  ChevronRight,
  ChevronUp,
  ChevronDown,
  Cog,
  Search,
  EllipsisVertical,
  X,
  User,
  ArrowRight,
  Upload,
  // Player / transport
  Play,
  Pause,
  SkipForward,
  SkipBack,
  Repeat,
  Shuffle,
  // Volume
  Volume2,
  VolumeX,
  // App / nav metaphors
  AppWindow,
  Library as LibraryIcon,
  ListMusic,
  Compass,
  Waves,
} from "lucide-react";

/** Canonical (preferred) keys */
type CanonicalIconName =
  | "menu"
  | "chevronLeft"
  | "chevronRight"
  | "chevronUp"
  | "chevronDown"
  | "settings"
  | "search"
  | "kebab"
  | "close"
  | "user"
  | "enter"
  | "upload"
  | "play"
  | "pause"
  | "next"
  | "prev"
  | "transport.play"
  | "transport.pause"
  | "transport.next"
  | "transport.prev"
  | "repeat"
  | "shuffle"
  | "volume"       // on
  | "mute"         // off
  | "app"
  | "library"
  | "playlists"
  | "discovery"
  | "waves";

/** Primary canonical registry */
const canonical: Record<CanonicalIconName, React.ComponentType<React.ComponentPropsWithoutRef<'svg'>>> = {
  // Core UI
  menu: Menu,
  chevronLeft: ChevronLeft,
  chevronRight: ChevronRight,
  chevronUp: ChevronUp,
  chevronDown: ChevronDown,
  settings: Cog,
  search: Search,
  kebab: EllipsisVertical,
  close: X,
  user: User,
  enter: ArrowRight,
  upload: Upload,

  // Player / transport
  play: Play,
  pause: Pause,
  next: SkipForward,
  prev: SkipBack,
  "transport.play": Play,
  "transport.pause": Pause,
  "transport.next": SkipForward,
  "transport.prev": SkipBack,
  repeat: Repeat,
  shuffle: Shuffle,

  // Volume
  volume: Volume2,
  mute: VolumeX,
  "volume.on": Volume2,
  "volume.off": VolumeX,

  // App / nav metaphors
  app: AppWindow,
  library: LibraryIcon,
  playlists: ListMusic,
  discovery: Compass,
  waves: Waves,
};

/**
 * Aliases for legacy/dotted names still present in some components
 * e.g. "transport.play", "volume.on".
 */
const aliases: Record<string, React.ComponentType<React.ComponentPropsWithoutRef<'svg'>>> = {
  // Transport namespace
  "transport.play": canonical.play,
  "transport.pause": canonical.pause,
  "transport.next": canonical.next,
  "transport.prev": canonical.prev,
  "transport.repeat": canonical.repeat,
  "transport.shuffle": canonical.shuffle,

  // Volume namespace
  "volume.on": canonical.volume,
  "volume.off": canonical.mute,

  // App/nav namespace (if any legacy usage exists)
  "app.logo": canonical.app,
  "nav.library": canonical.library,
  "nav.playlists": canonical.playlists,
  "nav.discovery": canonical.discovery,
};

export const iconRegistry: Record<string, React.ComponentType<React.ComponentPropsWithoutRef<'svg'>>> = {
  ...canonical,
  ...aliases,
};

export type IconProps = {
  name: string;                 // allow any string; we guard at runtime
  size?: number;
  width?: number;
  height?: number;
  className?: string;
  strokeWidth?: number;
  "aria-hidden"?: boolean;
  role?: string;
  title?: string;
};

/** Safe <Icon/> that won’t crash on unknown names */
const unknownWarned = new Set<string>();

export const Icon: React.FC<IconProps> = ({
  name,
  size = 20,
  width,
  height,
  className,
  strokeWidth = 1.75,
  ...rest
}) => {
  const Cmp = iconRegistry[name];
  if (!Cmp) {
    if (!unknownWarned.has(name)) {
      // eslint-disable-next-line no-console
      console.error(
        `[IconRegistry] Unknown icon "${name}". Add it to iconRegistry or update usages. Rendering a placeholder.`
      );
      unknownWarned.add(name);
    }
    return React.createElement("span", { className, "aria-hidden": "true", ...rest });
  }
  return React.createElement(Cmp, {
    width: width || size,
    height: height || size,
    strokeWidth,
    className,
    ...rest,
  });
};

export default Icon;
</file>

<file path="src/lib/utils/MediaSession.ts">
// src/lib/utils/MediaSession.ts
/**
 * MediaSession helpers (Phase 2)
 * -----------------------------------------------------------------------------
 * Tiny, safe wrappers around the Media Session API.
 *
 * Responsibilities:
 *  - Update metadata (title/artist/album/artwork).
 *  - Register action handlers (play/pause/next/previous/seekto).
 *  - Update playback & position state for lock-screen/OS integrations.
 *
 * Design notes:
 *  - All functions are no-ops when Media Session is unavailable.
 *  - Defensively typed and guarded for SSR.
 *  - We keep the last applied metadata/handlers so callers can re-apply or
 *    update incrementally without juggling state.
 */

type ArtworkItem = { src: string; sizes?: string; type?: string };

export type MediaSessionActions = Partial<{
  play: () => void | Promise<void>;
  pause: () => void | Promise<void>;
  stop: () => void | Promise<void>;
  nexttrack: () => void | Promise<void>;
  previoustrack: () => void | Promise<void>;
  seekbackward: (seconds: number) => void | Promise<void>;
  seekforward: (seconds: number) => void | Promise<void>;
  seekto: (position: number) => void | Promise<void>;
}>;

export type UpdateMediaSessionPayload = {
  title: string;
  artist?: string;
  album?: string;
  artwork?: ArtworkItem[];
  actions?: MediaSessionActions;
};

type PositionState = {
  duration?: number; // seconds
  position?: number; // seconds
  playbackRate?: number; // 0.25..4
};

const hasWindow = typeof window !== "undefined";
const hasNavigator = typeof navigator !== "undefined";
const ms: () => MediaSession | null = () =>
  (hasNavigator && "mediaSession" in navigator ? (navigator as any).mediaSession : null);

const normalizeArtwork = (art?: ArtworkItem[] | null): ArtworkItem[] | undefined => {
  if (!Array.isArray(art) || art.length === 0) return undefined;
  // Deduplicate by src; ensure sizes are strings like "96x96"
  const seen = new Set<string>();
  const out: ArtworkItem[] = [];
  for (const a of art) {
    if (!a || !a.src || seen.has(a.src)) continue;
    seen.add(a.src);
    out.push({
      src: a.src,
      sizes: a.sizes && /^\d+x\d+$/.test(a.sizes) ? a.sizes : undefined,
      type: a.type,
    });
  }
  return out.length ? out : undefined;
};

// Keep last-applied state so we can reapply if needed
let lastMeta: UpdateMediaSessionPayload | null = null;
let lastPosition: PositionState | null = null;

/**
 * Register handlers. Replaces existing handlers by clearing first.
 */
export function setActionHandlers(actions: MediaSessionActions | undefined): void {
  const session = ms();
  if (!session || typeof session.setActionHandler !== "function") return;

  // Clear everything first to avoid dangling references
  clearActionHandlers();

  if (!actions) return;

  try {
    if (actions.play) session.setActionHandler("play", () => void actions.play!());
    if (actions.pause) session.setActionHandler("pause", () => void actions.pause!());
    if (actions.stop) session.setActionHandler("stop", () => void actions.stop!());
    if (actions.nexttrack) session.setActionHandler("nexttrack", () => void actions.nexttrack!());
    if (actions.previoustrack)
      session.setActionHandler("previoustrack", () => void actions.previoustrack!());
    if (actions.seekbackward)
      session.setActionHandler("seekbackward", (d: MediaSessionActionDetails) =>
        actions.seekbackward!(d.seekOffset ?? 10)
      );
    if (actions.seekforward)
      session.setActionHandler("seekforward", (d: MediaSessionActionDetails) =>
        actions.seekforward!(d.seekOffset ?? 10)
      );
    if (actions.seekto)
      session.setActionHandler("seekto", (d: MediaSessionActionDetails) => {
        if (typeof d.seekTime === "number") actions.seekto!(d.seekTime);
      });
  } catch {
    // Some handlers may throw in older engines; ignore.
  }
}

/** Remove all registered action handlers (safe no-op if unsupported). */
export function clearActionHandlers(): void {
  const session = ms();
  if (!session || typeof session.setActionHandler !== "function") return;
  try {
    const all: MediaSessionAction[] = [
      "play",
      "pause",
      "stop",
      "nexttrack",
      "previoustrack",
      "seekbackward",
      "seekforward",
      "seekto",
    ];
    for (const a of all) session.setActionHandler(a, null);
  } catch {
    // ignore
  }
}

/**
 * Update metadata (title/artist/album/artwork) and optionally actions.
 * This is the primary, convenient entry point used by the controller.
 */
export function updateMediaSession(payload: UpdateMediaSessionPayload): void {
  const session = ms();
  if (!session) return;

  const artwork = normalizeArtwork(payload.artwork);
  lastMeta = { ...payload, artwork };

  // Set metadata
  try {
    const meta = new (window as any).MediaMetadata({
      title: payload.title || "Unknown title",
      artist: payload.artist ?? "",
      album: payload.album ?? "",
      artwork,
    });
    session.metadata = meta;
  } catch {
    // On older browsers, metadata may not exist; ignore.
  }

  // Apply actions if provided
  if (payload.actions) {
    setActionHandlers(payload.actions);
  }
}

/** Update playback state ("none" | "paused" | "playing"). */
export function setPlaybackState(state: MediaSessionPlaybackState): void {
  const session = ms();
  if (!session) return;
  try {
    session.playbackState = state;
  } catch {
    // ignore
  }
}

/** Update position state (duration, position, playbackRate) when available. */
export function setPositionState(state: PositionState): void {
  const session = ms();
  if (!session || typeof (session as any).setPositionState !== "function") {
    lastPosition = { ...state };
    return;
  }
  // Clamp to safe numbers to avoid DOM exceptions
  const duration = isFiniteNumber(state.duration) ? Math.max(0, state.duration!) : undefined;
  const position = isFiniteNumber(state.position) ? Math.max(0, state.position!) : undefined;
  const playbackRate = isFiniteNumber(state.playbackRate) ? state.playbackRate! : undefined;

  try {
    (session as any).setPositionState({
      duration,
      position,
      playbackRate,
    });
    lastPosition = { duration, position, playbackRate };
  } catch {
    // ignore
  }
}

/** Reapply the last known metadata, actions, and position state (if any). */
export function reapply(): void {
  if (lastMeta) updateMediaSession(lastMeta);
  if (lastPosition) setPositionState(lastPosition);
}

/** Clear metadata and handlers (useful on teardown). */
export function reset(): void {
  const session = ms();
  if (!session) return;
  try {
    session.metadata = null as any;
  } catch {
    // ignore
  }
  clearActionHandlers();
  lastMeta = null;
  lastPosition = null;
}

/** Convenience: update everything in one go. */
export function updateAll(payload: UpdateMediaSessionPayload & PositionState & { playing?: boolean }) {
  updateMediaSession(payload);
  setPositionState({
    duration: payload.duration,
    position: payload.position,
    playbackRate: payload.playbackRate,
  });
  if (typeof payload.playing === "boolean") {
    setPlaybackState(payload.playing ? "playing" : "paused");
  }
}

// ---- Utilities --------------------------------------------------------------

function isFiniteNumber(n: unknown): n is number {
  return typeof n === "number" && Number.isFinite(n);
}

// Minimal DOM type fallbacks for older TS lib versions
type MediaSessionAction =
  | "play"
  | "pause"
  | "stop"
  | "seekbackward"
  | "seekforward"
  | "seekto"
  | "previoustrack"
  | "nexttrack"
  | "skipad";

type MediaSessionActionDetails = {
  action: MediaSessionAction;
  seekTime?: number;
  seekOffset?: number;
  fastSeek?: boolean;
};

export default updateMediaSession;
</file>

<file path="src/lib/utils/ReducedMotion.ts">
// src/lib/utils/ReducedMotion.ts
export const onReducedMotionChange = (cb: (reduced: boolean) => void) => {
  const mql = window.matchMedia('(prefers-reduced-motion: reduce)')
  const handler = (e: MediaQueryListEvent) => cb(e.matches)
  if (mql.addEventListener) mql.addEventListener('change', handler)
  else mql.addListener(handler)
  cb(mql.matches)
  return () => {
    if (mql.removeEventListener) mql.removeEventListener('change', handler)
    else mql.removeListener(handler)
  }
}
</file>

<file path="src/lib/utils/UrlGuard.ts">
// src/lib/utils/UrlGuard.ts
/**
 * UrlGuard (Phase 2)
 * -----------------------------------------------------------------------------
 * Centralized, zero-dependency URL helpers for the audio player.
 * Goals:
 *  - Normalize user-provided URLs into an absolute, safe form.
 *  - Decide whether a URL is acceptable under our privacy/safety policy.
 *  - Provide quick predicates for HLS and common audio types.
 *
 * Notes:
 *  - We prefer HTTPS for remote resources. HTTP is allowed only for localhost.
 *  - We consider blob: (object URLs) safe (local-only), used for File playback.
 *  - We reject dangerous schemes (javascript:, data:*, chrome-extension:, etc.).
 */

const HTTPS = "https:";
const HTTP = "http:";
const BLOB = "blob:";
const DATA = "data:";

const LOCALHOST_HOSTS = new Set([
  "localhost",
  "127.0.0.1",
  "0.0.0.0",
  "[::1]",
]);

/** Safe parse that never throws. Returns null on failure. */
export function tryParseUrl(input: string, base?: string): URL | null {
  try {
    return new URL(input, base);
  } catch {
    return null;
  }
}

/** True if the string looks like a domain/path without scheme (e.g., example.com/a.m3u8). */
function looksSchemelessHttpish(s: string): boolean {
  // domain.tld[/...],  or localhost[:port][/...]
  return /^[a-z0-9.-]+(:\d+)?(\/|$)/i.test(s);
}

/** Returns true if the URL uses https:// */
export function isHttpsUrl(url: string): boolean {
  const u = tryParseUrl(url);
  return !!u && u.protocol === HTTPS;
}

/** Returns true if the URL uses https:// or http:// */
export function isHttpUrl(url: string): boolean {
  const u = tryParseUrl(url);
  return !!u && (u.protocol === HTTPS || u.protocol === HTTP);
}

/** Returns true if url host is localhost or loopback. */
export function isLocalhostUrl(url: string): boolean {
  const u = tryParseUrl(url);
  if (!u) return false;
  return LOCALHOST_HOSTS.has(u.hostname);
}

/** Normalize user input into an absolute URL string.
 *  - Trims whitespace
 *  - Converts protocol-relative URLs (//host/path) to https://
 *  - Adds https:// for schemeless domain/path
 *  - Allows http:// only for localhost/loopback if allowHttpOnLocalhost
 */
export function normalizeUrl(
  input: string,
  opts: { allowHttpOnLocalhost?: boolean } = { allowHttpOnLocalhost: true }
): string {
  const raw = (input || "").trim();
  if (!raw) return "";

  // protocol-relative
  if (/^\/\//.test(raw)) return `${HTTPS}${raw}`;

  // schemeless domain/path
  if (!/^[a-z]+:\/\//i.test(raw) && looksSchemelessHttpish(raw)) {
    // If it's localhost-ish with explicit port and opts allow, use http, else https
    const host = raw.split(/[/?#]/, 1)[0];
    if (opts.allowHttpOnLocalhost && LOCALHOST_HOSTS.has(host.split(":")[0])) {
      return `http://${raw}`;
    }
    return `https://${raw}`;
  }

  // Already has a scheme
  return raw;
}

/** True if scheme is allowed by our policy (https, http[localhost], blob). */
export function isAllowedScheme(url: string, allowHttpOnLocalhost = true): boolean {
  const u = tryParseUrl(url);
  if (!u) return false;
  if (u.protocol === HTTPS) return true;
  if (u.protocol === BLOB) return true; // local object URLs from File API
  if (u.protocol === HTTP) {
    return allowHttpOnLocalhost && LOCALHOST_HOSTS.has(u.hostname);
  }
  // Disallow data:, javascript:, file:, chrome-extension:, etc.
  return false;
}

/** Convenience guard that combines normalize + policy check. */
export function normalizeAndGuard(
  input: string,
  opts: { allowHttpOnLocalhost?: boolean } = { allowHttpOnLocalhost: true }
): { ok: boolean; url: string } {
  const url = normalizeUrl(input, opts);
  return { ok: isAllowedScheme(url, !!opts.allowHttpOnLocalhost), url };
}

/** File extension (lowercase, without dot). */
export function extOf(urlOrName: string): string {
  const clean = urlOrName.split("?")[0].split("#")[0];
  const m = /\.([a-z0-9]+)$/i.exec(clean);
  return m ? m[1].toLowerCase() : "";
}

/** True if URL/path suggests an HLS playlist. */
export function isLikelyHlsUrl(url: string): boolean {
  try {
    const u = new URL(url);
    return /\.m3u8$/i.test(u.pathname);
  } catch {
    // fallback for schemeless paths
    return /\.m3u8(\?.*)?$/i.test(url);
  }
}

/** True if extension looks like a common audio file. */
export function isLikelyAudioFile(url: string): boolean {
  const e = extOf(url);
  return (
    e === "mp3" ||
    e === "m4a" ||
    e === "aac" ||
    e === "flac" ||
    e === "wav" ||
    e === "ogg" ||
    e === "oga" ||
    e === "opus" ||
    e === "webm"
  );
}

/** Guess MIME from extension (best-effort). */
export function guessMimeFromExt(urlOrName: string): string | undefined {
  switch (extOf(urlOrName)) {
    case "m3u8":
      return "application/vnd.apple.mpegurl";
    case "mp3":
      return "audio/mpeg";
    case "m4a":
    case "aac":
      return "audio/aac";
    case "flac":
      return "audio/flac";
    case "wav":
      return "audio/wav";
    case "ogg":
    case "oga":
      return "audio/ogg";
    case "opus":
      return "audio/opus";
    case "webm":
      return "audio/webm";
    default:
      return undefined;
  }
}

/** True if a Content-Type header indicates audio. */
export function isAudioContentType(contentType?: string | null): boolean {
  if (!contentType) return false;
  return /^audio\//i.test(contentType) || /application\/(x-)?mpegurl/i.test(contentType);
}

/** Same-origin helper (compares origin against current location). */
export function isSameOrigin(url: string): boolean {
  const u = tryParseUrl(url, typeof window !== "undefined" ? window.location.href : undefined);
  if (!u) return false;
  if (typeof window === "undefined") return false;
  return u.origin === window.location.origin;
}

/** Export a compact API as default for convenience. */
const UrlGuard = {
  tryParseUrl,
  isHttpsUrl,
  isHttpUrl,
  isLocalhostUrl,
  normalizeUrl,
  isAllowedScheme,
  normalizeAndGuard,
  extOf,
  isLikelyHlsUrl,
  isLikelyAudioFile,
  guessMimeFromExt,
  isAudioContentType,
  isSameOrigin,
};

export default UrlGuard;
</file>

<file path="src/lib/utils/useHotkeys.ts">
// src/lib/utils/useHotkeys.ts
/**
 * Ethereal Harmony — React hook wrapper for Hotkeys manager
 *
 * Purpose:
 *  - Provide a React-friendly way to bind/unbind the project's default
 *    visualization hotkeys (P/H/D) and optional extra bindings per component.
 *  - Keep the original behavior the repo already used, but route through the
 *    central Hotkeys manager so global rules (typing targets, repeat, etc.)
 *    are consistent.
 *
 * Defaults (Phase 1):
 *  - P: cycle visualizer presets
 *  - H: toggle HDR
 *  - D: toggle dimmer
 *
 * Notes:
 *  - Selectors are primitive to avoid re-renders (Zustand best practice).
 *  - SSR safe: no-ops on the server.
 */

import { useEffect } from "react";
import Hotkeys, { EH_HOTKEYS, HotkeyHandler } from "@/lib/utils/Hotkeys";
import { useVizStore } from "@/lib/state/useVizStore";

export type ExtraHotkey = {
  combo: string;
  handler: HotkeyHandler;
  /** If true, do not preventDefault on match. Default false. */
  allowDefault?: boolean;
  /** Allow firing while typing in inputs/textarea. Default false. */
  allowInInputs?: boolean;
  /** Allow auto-repeat while holding keys. Default false. */
  allowRepeat?: boolean;
  /** Optional scope label for easier cleanup (defaults to "react:useHotkeys"). */
  scope?: string;
};

export type UseHotkeysOptions = {
  /** Bind the default EH visualizer hotkeys (P/H/D). Default true. */
  enableDefaults?: boolean;
  /** Additional bindings owned by the component. */
  extra?: ExtraHotkey[];
};

export const useHotkeys = (options: UseHotkeysOptions = {}): void => {
  const { enableDefaults = true, extra = [] } = options;

  // Pull primitive actions from the viz store
  const cyclePreset = useVizStore((s: any) => s?.cyclePreset);
  const toggleHDR = useVizStore((s: any) => s?.toggleHDR);
  const toggleDimmer = useVizStore((s: any) => s?.toggleDimmer);

  useEffect(() => {
    const offs: Array<() => void> = [];

    if (enableDefaults) {
      if (typeof cyclePreset === "function") {
        offs.push(
          Hotkeys.add(EH_HOTKEYS.VIZ_CYCLE_PRESET, () => cyclePreset(), {
            scope: "react:useHotkeys",
          })
        );
      }
      if (typeof toggleHDR === "function") {
        offs.push(
          Hotkeys.add(EH_HOTKEYS.VIZ_TOGGLE_HDR, () => toggleHDR(), {
            scope: "react:useHotkeys",
          })
        );
      }
      if (typeof toggleDimmer === "function") {
        offs.push(
          Hotkeys.add(EH_HOTKEYS.VIZ_TOGGLE_DIMMER, () => toggleDimmer(), {
            scope: "react:useHotkeys",
          })
        );
      }
    }

    // Extra, component-owned bindings
    for (const hk of extra) {
      offs.push(
        Hotkeys.add(hk.combo, hk.handler, {
          preventDefault: hk.allowDefault ? false : true,
          allowInInputs: !!hk.allowInInputs,
          allowRepeat: !!hk.allowRepeat,
          scope: hk.scope ?? "react:useHotkeys",
        })
      );
    }

    return () => {
      offs.forEach((off) => off());
    };
  }, [enableDefaults, extra, cyclePreset, toggleHDR, toggleDimmer]);
};

export default useHotkeys;
</file>

<file path="src/lib/utils/Visibility.ts">
// src/lib/utils/Visibility.ts
export const onVisibilityChange = (cb: (hidden: boolean) => void) => {
  const handler = () => cb(document.hidden)
  document.addEventListener('visibilitychange', handler)
  cb(document.hidden)
  return () => document.removeEventListener('visibilitychange', handler)
}
</file>

<file path="src/lib/visualizer/QualityPresets.ts">
// src/lib/visualizer/QualityPresets.ts
/**
 * QualityPresets
 * -----------------------------------------------------------------------------
 * Central mapping of QualityTier → concrete Three.js visualizer settings.
 *
 * Consumers:
 *   - useVizStore.applyQualityPreset(tier)
 *   - AdaptiveGuard (degrade/upgrade steps based on rolling FPS)
 *   - SceneController / WebGLCanvas (resolution scale, AA, post, particle counts)
 *
 * Design goals:
 *   1) Single source of truth for tiered rendering knobs.
 *   2) Predictable adaptive ladder: SMALL → MEDIUM → LARGE trade-offs.
 *   3) Safe bounds so we never request "impossible" settings of the scene.
 *
 * Notes:
 *   - All values are "intent". Scene code should clamp to hardware support
 *     (e.g., if WebGL2 or certain post passes are unavailable).
 *   - Resolution is expressed as a scale factor (0.66…1.0) relative to canvas size.
 *   - AA strategy is declarative; renderer will map to FXAA pass or TAA, etc.
 *   - Bloom can be fully disabled at lower tiers to protect frame budget.
 *
 * Tier rationale (from blueprint & changelog):
 *   - Target 55–60 FPS on a mid-range reference device.
 *   - Adaptive guard reduces: bloom → particles → resolution → AA → finally fallback.
 *   - First launch probe informs the starting tier (see `inferInitialTierFromProbe`).
 */

export type AAKind = "none" | "fxaa" | "taa";
export type QualityTier = "ultra" | "high" | "medium" | "low" | "fallback";

/** Ordered strongest → weakest (used by ladder helpers). */
export const QUALITY_ORDER = ["ultra", "high", "medium", "low", "fallback"] as const;

export type QualityPreset = {
  /** Human readable label for settings UI and diagnostics overlay. */
  label: string;

  /** Render buffer resolution scale (1.0 = native; < 1.0 = internal downscale). */
  resolutionScale: number; // 0.66 … 1.0

  /** Particle instance count target for ParticlesField. Scene clamps to safe bounds. */
  particleCount: number;

  /** Post-processing: bloom on/off and tuning. Scene may ignore if post not available. */
  bloomEnabled: boolean;
  bloomStrength: number; // 0 … 2.5 (scene clamps)
  bloomThreshold: number; // 0 … 1
  bloomRadius: number; // pass-specific radius

  /** Anti-aliasing strategy (mapped by renderer layer). */
  aa: AAKind;

  /** HDR pipeline (tone mapping + float buffers). Scene may disable if not supported. */
  hdr: boolean;

  /** Motion budget: cap for subtle camera/mesh motion (helps reduced motion and perf). */
  motionScaleMax: number; // 0 … 1

  /** Misc scene toggles */
  dither: boolean;
  postEnabled: boolean;

  /** Optional hints for SceneController tuning. */
  hints?: {
    /** Shadow toggles for future scene elements; we default off for V1 visuals. */
    shadows?: boolean;
    /** If true, prefer half float buffers; otherwise 8-bit targets. */
    preferHalfFloat?: boolean;
  };
};

/**
 * Canonical presets, tuned for our visual style and target devices.
 * Particle counts are chosen to scale roughly 2× per tier where possible.
 * Bloom is the most visually expensive pass and is the first to step down.
 */
export const QUALITY_PRESETS: Record<QualityTier, QualityPreset> = {
  ultra: {
    label: "Ultra",
    resolutionScale: 1.0,
    particleCount: 220_000,
    bloomEnabled: true,
    bloomStrength: 1.2,
    bloomThreshold: 0.75,
    bloomRadius: 0.6,
    aa: "taa",
    hdr: true,
    motionScaleMax: 1.0,
    dither: true,
    postEnabled: true,
    hints: { shadows: false, preferHalfFloat: true },
  },

  high: {
    label: "High",
    resolutionScale: 0.9,
    particleCount: 160_000,
    bloomEnabled: true,
    bloomStrength: 0.95,
    bloomThreshold: 0.78,
    bloomRadius: 0.55,
    aa: "fxaa",
    hdr: true,
    motionScaleMax: 0.9,
    dither: true,
    postEnabled: true,
    hints: { shadows: false, preferHalfFloat: true },
  },

  medium: {
    label: "Medium",
    resolutionScale: 0.8,
    particleCount: 110_000,
    bloomEnabled: true,
    bloomStrength: 0.7,
    bloomThreshold: 0.8,
    bloomRadius: 0.48,
    aa: "fxaa",
    hdr: true,
    motionScaleMax: 0.8,
    dither: true,
    postEnabled: true,
    hints: { shadows: false, preferHalfFloat: true },
  },

  low: {
    label: "Low",
    resolutionScale: 0.72,
    particleCount: 70_000,
    bloomEnabled: false,
    bloomStrength: 0.0,
    bloomThreshold: 0.85,
    bloomRadius: 0.45,
    aa: "fxaa",
    hdr: false,
    motionScaleMax: 0.7,
    dither: true,
    postEnabled: true,
    hints: { shadows: false, preferHalfFloat: false },
  },

  /**
   * Fallback is the "must keep responsive" floor. No bloom, no AA, smaller buffer.
   * Visual identity remains intact via particles + mist with conservative params.
   */
  fallback: {
    label: "Fallback",
    resolutionScale: 0.66,
    particleCount: 40_000,
    bloomEnabled: false,
    bloomStrength: 0.0,
    bloomThreshold: 1.0,
    bloomRadius: 0.4,
    aa: "none",
    hdr: false,
    motionScaleMax: 0.6,
    dither: true,
    postEnabled: false,
    hints: { shadows: false, preferHalfFloat: false },
  },
};

// -----------------------------------------------------------------------------
// Adaptive ladder
// -----------------------------------------------------------------------------

/**
 * The adaptive guard degrades settings in small, reversible steps.
 * We encode those steps here so SceneController/AdaptiveGuard/useVizStore
 * all share the exact same semantics.
 */
export type AdaptiveStep =
  | "bloom-→-0.8" // reduce bloom strength by 0.2 (clamped ≥ 0)
  | "bloom-off" // full disable
  | "particles-×-0.85" // reduce particle count by 15%
  | "resolution-×-0.92" // reduce internal render scale by ~8%
  | "aa→fxaa" // switch to FXAA if TAA
  | "aa→none" // disable AA
  | "post-off" // disable all post
  | "tier-down" // move to next lower tier
  | "tier-up"; // (used when recovering)

export const ADAPTIVE_DEGRADE_SEQUENCE: AdaptiveStep[] = [
  "bloom-→-0.8",
  "bloom-off",
  "particles-×-0.85",
  "resolution-×-0.92",
  "aa→fxaa",
  "aa→none",
  "post-off",
  "tier-down",
];

export const ADAPTIVE_RECOVER_SEQUENCE: AdaptiveStep[] = [
  "tier-up",
  // Note: fine-grained "undo" steps are left to the next preset jump,
  // which is simpler and avoids oscillation.
];

/** Safe clamp helpers used by mutation utilities. */
const clamp01 = (v: number) => Math.max(0, Math.min(1, v));
const clampScale = (v: number) => Math.max(0.5, Math.min(1, v)); // safety guard
const clampParticles = (v: number) => Math.max(5_000, Math.min(500_000, Math.round(v)));

/**
 * Return a new preset with a single adaptive step applied.
 * (Pure function — does not mutate the original.)
 */
export function applyAdaptiveStep(preset: QualityPreset, step: AdaptiveStep): QualityPreset {
  switch (step) {
    case "bloom-→-0.8": {
      if (!preset.bloomEnabled) return preset;
      const strength = Math.max(0, preset.bloomStrength - 0.2);
      return { ...preset, bloomStrength: strength };
    }
    case "bloom-off": {
      if (!preset.bloomEnabled) return preset;
      return { ...preset, bloomEnabled: false, bloomStrength: 0 };
    }
    case "particles-×-0.85": {
      const next = clampParticles(preset.particleCount * 0.85);
      return { ...preset, particleCount: next };
    }
    case "resolution-×-0.92": {
      const next = clampScale(preset.resolutionScale * 0.92);
      return { ...preset, resolutionScale: next };
    }
    case "aa→fxaa": {
      if (preset.aa === "taa") return { ...preset, aa: "fxaa" };
      return preset;
    }
    case "aa→none": {
      if (preset.aa !== "none") return { ...preset, aa: "none" };
      return preset;
    }
    case "post-off": {
      if (!preset.postEnabled) return preset;
      return { ...preset, postEnabled: false, bloomEnabled: false, bloomStrength: 0 };
    }
    // 'tier-down' and 'tier-up' are handled by helpers that change the tier,
    // not the shape of this preset.
    default:
      return preset;
  }
}

// -----------------------------------------------------------------------------
// Tier helpers
// -----------------------------------------------------------------------------

export function getTierIndex(tier: QualityTier): number {
  return QUALITY_ORDER.indexOf(tier);
}

export function tierFromIndex(idx: number): QualityTier {
  const i = Math.max(0, Math.min(QUALITY_ORDER.length - 1, idx));
  return QUALITY_ORDER[i] as QualityTier;
}

export function nextLowerTier(tier: QualityTier): QualityTier {
  return tierFromIndex(getTierIndex(tier) + 1);
}

export function nextHigherTier(tier: QualityTier): QualityTier {
  return tierFromIndex(getTierIndex(tier) - 1);
}

/**
 * Given a current tier and step, return the next tier and preset.
 * Non-tier steps return the same tier with a mutated preset.
 */
export function stepPreset(
  tier: QualityTier,
  preset: QualityPreset,
  step: AdaptiveStep
): { tier: QualityTier; preset: QualityPreset } {
  if (step === "tier-down") {
    const t = nextLowerTier(tier);
    return { tier: t, preset: QUALITY_PRESETS[t] };
  }
  if (step === "tier-up") {
    const t = nextHigherTier(tier);
    return { tier: t, preset: QUALITY_PRESETS[t] };
  }
  return { tier, preset: applyAdaptiveStep(preset, step) };
}

// -----------------------------------------------------------------------------
// Probe → initial tier heuristic
// -----------------------------------------------------------------------------

export type ProbeSnapshot = {
  /** Rolling FPS during an initial light scene (if measured). */
  fps?: number;
  /** Device memory hint in GB (Chrome-only; undefined elsewhere). */
  deviceMemory?: number;
  /** 0 (worst) … 3 (best) GPU tier if using detect-gpu style probe. */
  gpuTier?: number;
  /** Battery saver mode detected. */
  batterySaver?: boolean;
  /** Mobile UA hint. */
  isMobile?: boolean;
};

/**
 * Heuristic mapping from device hints to a starting quality tier.
 * This is intentionally conservative; the AdaptiveGuard can always promote.
 */
export function inferInitialTierFromProbe(p: ProbeSnapshot): QualityTier {
  // Battery saver or very low fps → start low/fallback.
  if (p.batterySaver) return "low";
  if (p.fps !== undefined && p.fps < 50) return "low";

  // Device memory hint: <= 2 GB → low; 3–4 GB → medium
  if (p.deviceMemory !== undefined) {
    if (p.deviceMemory <= 2) return "low";
    if (p.deviceMemory <= 4) return "medium";
  }

  // GPU tier (rough guide; 0-3 scale)
  if (p.gpuTier !== undefined) {
    if (p.gpuTier <= 0) return "low";
    if (p.gpuTier === 1) return "medium";
    if (p.gpuTier === 2) return "high";
    if (p.gpuTier >= 3) return "ultra";
  }

  // Mobile devices tend to prefer medium as a safe start.
  if (p.isMobile) return "medium";

  // Default to high on desktop where no hints are available.
  return "high";
}

// -----------------------------------------------------------------------------
// Safety & normalization
// -----------------------------------------------------------------------------

/**
 * Normalize a preset to safe bounds. Call this before applying into scene.
 */
export function normalizePreset(p: QualityPreset): QualityPreset {
  return {
    ...p,
    resolutionScale: clampScale(p.resolutionScale),
    particleCount: clampParticles(p.particleCount),
    bloomStrength: clamp01(p.bloomStrength) * 2.5, // cap to 2.5 for our pipeline
    bloomThreshold: clamp01(p.bloomThreshold),
    bloomRadius: Math.max(0, Math.min(1.2, p.bloomRadius)),
    motionScaleMax: clamp01(p.motionScaleMax),
  };
}

/** Convenience to fetch a normalized preset for a tier. */
export function getPresetForTier(tier: QualityTier): QualityPreset {
  return normalizePreset(QUALITY_PRESETS[tier]);
}
</file>

<file path="src/lib/visualizer/SceneController.ts">
// src/lib/visualizer/SceneController.ts
import * as THREE from "three";
import {
  type QualityTier,
  type QualityPreset,
  getPresetForTier,
  normalizePreset,
} from "./QualityPresets";

/**
 * SceneController
 * -----------------------------------------------------------------------------
 * Non-React controller that owns the Three.js scene graph and all render-time
 * configuration. It does *not* touch audio playback; it only consumes an
 * analyser-like data source to drive uniforms.
 *
 * Responsibilities:
 *  - Create/own Scene + Camera + a minimal visual (audio-reactive particle field).
 *  - Maintain a compact set of shader uniforms updated from an external analyser.
 *  - Apply quality presets (particle counts, post-FX toggles, HDR hints).
 *  - Expose a small public API for the React wrapper (SceneCanvas) and stores.
 *
 * Out of scope (Phase 1):
 *  - Post-processing composer (FXAA/TAA/Bloom) — controller exposes flags but
 *    uses in-shader "bloom-ish" additive shaping as a placeholder.
 *  - Routing / UI / telemetry.
 *
 * Lifecycle:
 *  const ctrl = new SceneController({ renderer, canvas, initialTier: "high" })
 *  ctrl.mount()        // constructs scene graph
 *  ctrl.update(dt)     // per-frame (from RAF in SceneCanvas)
 *  ctrl.setTier("low") // dynamic quality change
 *  ctrl.dispose()      // release GPU resources
 */

// ----------------------------------------------------------------------------
// External contracts (lightweight & defensive)
// ----------------------------------------------------------------------------

/** Minimal analyser interface used by the controller. */
export interface AnalyserBus {
  /** Rolling average of full-band loudness (0..1). */
  getRms(): number;
  /** Coarse band energies (0..1). All optional. */
  getBass?(): number;
  getMid?(): number;
  getTreble?(): number;
}

/** Options accepted by the controller. */
export interface SceneControllerOptions {
  renderer: THREE.WebGLRenderer;
  canvas: HTMLCanvasElement;
  initialTier?: QualityTier;
  /** If provided, overrides the initial tier mapping. */
  presetOverride?: Partial<QualityPreset>;
  /** Optional analyser; can be attached later via setAnalyser(). */
  analyser?: AnalyserBus | null;

  /** Visual toggles that may also be changed later. */
  hdr?: boolean;
  dimmer?: boolean;

  /** Camera initial params (kept intentionally simple). */
  fov?: number; // degrees
  near?: number;
  far?: number;
}

/** Public API surface for Viz store / React wrapper. */
export interface ISceneController {
  mount(): void;
  update(dt: number): void;
  resize(width: number, height: number): void;
  dispose(): void;

  /** Quality / features */
  setTier(tier: QualityTier): void;
  applyPreset(preset: Partial<QualityPreset>): void;
  getTier(): QualityTier;
  getPreset(): QualityPreset;

  setHDR(on: boolean): void;
  setDimmer(on: boolean): void;

  /** External drivers */
  setAnalyser(bus: AnalyserBus | null): void;

  /** Read-only handles for advanced integrations */
  getScene(): THREE.Scene;
  getCamera(): THREE.PerspectiveCamera;
  getRenderer(): THREE.WebGLRenderer;
}

// ----------------------------------------------------------------------------
// Internals
// ----------------------------------------------------------------------------

type Uniforms = {
  uTime: { value: number };
  uAudioRms: { value: number };
  uAudioBass: { value: number };
  uAudioMid: { value: number };
  uAudioTreble: { value: number };
  uDimmer: { value: number };
  uMotionScale: { value: number };
  uBloomMix: { value: number };
  uColorA: { value: THREE.Color };
  uColorB: { value: THREE.Color };
};

const DEFAULT_COLORS = {
  a: new THREE.Color("#00F0FF"), // Radiant Aqua (highlight)
  b: new THREE.Color("#7F6A9F"), // Soft Lavender (accent)
};

/** Small utility: dispose safely if object has a dispose() method. */
const safeDispose = (obj: any) => {
  try {
    if (obj && typeof obj.dispose === "function") obj.dispose();
  } catch {
    /* no-op */
  }
};

export class SceneController implements ISceneController {
  private renderer: THREE.WebGLRenderer;
  private canvas: HTMLCanvasElement;

  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera;

  private particleMesh: THREE.Points | null = null;
  private particleGeometry: THREE.BufferGeometry | null = null;
  private particleMaterial: THREE.ShaderMaterial | null = null;

  private uniforms!: Uniforms;

  private tier: QualityTier;
  private preset: QualityPreset;

  private analyser: AnalyserBus | null;

  // Runtime flags
  private hdr: boolean;
  private dimmer: boolean;

  // Frame clock
  private time = 0;

  constructor(opts: SceneControllerOptions) {
    this.renderer = opts.renderer;
    this.canvas = opts.canvas;

    this.tier = opts.initialTier ?? "high";
    this.preset = normalizePreset({
      ...getPresetForTier(this.tier),
      ...(opts.presetOverride ?? {}),
    });

    this.analyser = opts.analyser ?? null;
    this.hdr = !!opts.hdr;
    this.dimmer = !!opts.dimmer;

    // Camera defaults
    const fov = opts.fov ?? 55;
    const near = opts.near ?? 0.1;
    const far = opts.far ?? 100;

    // Initialize core containers and camera
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(fov, 1, near, far);
    this.camera.position.set(0, 0, 6);

    // Renderer hints (HDR placeholder — true HDR requires float buffers/post)
    this.applyRendererHints();
  }

  // --------------------------------------------------------------------------
  // Public API
  // --------------------------------------------------------------------------

  mount(): void {
    // Set initial viewport
    this.resize(this.canvas.clientWidth || 1, this.canvas.clientHeight || 1);

    // Uniforms shared across materials
    this.uniforms = {
      uTime: { value: 0 },
      uAudioRms: { value: 0 },
      uAudioBass: { value: 0 },
      uAudioMid: { value: 0 },
      uAudioTreble: { value: 0 },
      uDimmer: { value: this.dimmer ? 1 : 0 },
      uMotionScale: { value: this.preset.motionScaleMax },
      uBloomMix: { value: this.preset.bloomEnabled ? 1 : 0 },
      uColorA: { value: DEFAULT_COLORS.a.clone() },
      uColorB: { value: DEFAULT_COLORS.b.clone() },
    };

    // Create the particle field matching the quality preset
    this.rebuildParticles(this.preset.particleCount);

    // Ambient fog-like tint for depth cueing (cheap)
    const bg = new THREE.Color("#1A2B45"); // Deep Indigo
    this.scene.fog = new THREE.Fog(bg.getHex(), 12, 22);
  }

  update(dt: number): void {
    // Advance time for shader motion. Clamp to avoid large jumps.
    const step = Math.min(0.05, Math.max(0, dt));
    this.time += step;
    this.uniforms.uTime.value = this.time;

    // Analyse audio — values are 0..1
    if (this.analyser) {
      const rms = clamp01(this.analyser.getRms?.() ?? 0);
      const bass = clamp01(this.analyser.getBass?.() ?? rms * 0.9);
      const mid = clamp01(this.analyser.getMid?.() ?? rms * 0.7);
      const treble = clamp01(this.analyser.getTreble?.() ?? rms * 0.5);

      // Slight easing to reduce harsh jitter
      this.uniforms.uAudioRms.value = lerp(this.uniforms.uAudioRms.value, rms, 0.25);
      this.uniforms.uAudioBass.value = lerp(this.uniforms.uAudioBass.value, bass, 0.25);
      this.uniforms.uAudioMid.value = lerp(this.uniforms.uAudioMid.value, mid, 0.25);
      this.uniforms.uAudioTreble.value = lerp(this.uniforms.uAudioTreble.value, treble, 0.25);
    }

    // Update any cheap camera motion driven by audio (scaled by motionScale)
    const ms = this.preset.motionScaleMax;
    const wobble = this.uniforms.uAudioBass.value * 0.05 * ms;
    this.camera.position.x = Math.sin(this.time * 0.6) * wobble;
    this.camera.position.y = Math.cos(this.time * 0.4) * wobble;
    this.camera.lookAt(0, 0, 0);

    // Render — SceneCanvas owns the RAF cadence and clears/etc.
    this.renderer.render(this.scene, this.camera);
  }

  resize(width: number, height: number): void {
    const w = Math.max(1, width);
    const h = Math.max(1, height);

    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
    // The actual renderer size & DPR are managed by SceneCanvas.
  }

  dispose(): void {
    // Teardown GPU resources
    if (this.particleMesh) {
      this.scene.remove(this.particleMesh);
    }
    safeDispose(this.particleMaterial);
    safeDispose(this.particleGeometry);

    // Clear refs
    this.particleMesh = null;
    this.particleGeometry = null;
    this.particleMaterial = null;

    // Scene-level disposals (if we add textures, etc., later)
    // Intentionally not disposing the renderer; SceneCanvas owns it.
  }

  // ----- Quality / Features ---------------------------------------------------

  setTier(tier: QualityTier): void {
    if (tier === this.tier) return;
    this.tier = tier;
    this.preset = normalizePreset(getPresetForTier(tier));
    this.applyPreset(this.preset);
  }

  applyPreset(partial: Partial<QualityPreset>): void {
    // Merge and normalize
    this.preset = normalizePreset({ ...this.preset, ...partial });

    // Particle count may require geometry rebuild
    if (typeof partial.particleCount === "number") {
      this.rebuildParticles(this.preset.particleCount);
    }

    // Update uniforms & flags
    this.uniforms.uMotionScale.value = this.preset.motionScaleMax;
    this.uniforms.uBloomMix.value = this.preset.bloomEnabled ? 1 : 0;

    // Renderer hints (HDR placeholder)
    this.applyRendererHints();

    // (AA/Post toggles are acknowledged but realized in a future composer)
  }

  getTier(): QualityTier {
    return this.tier;
  }

  getPreset(): QualityPreset {
    return this.preset;
  }

  setHDR(on: boolean): void {
    this.hdr = !!on;
    this.applyRendererHints();
  }

  setDimmer(on: boolean): void {
    this.dimmer = !!on;
    this.uniforms.uDimmer.value = this.dimmer ? 1 : 0;
  }

  // ----- External drivers -----------------------------------------------------

  setAnalyser(bus: AnalyserBus | null): void {
    this.analyser = bus;
  }

  // ----- Read-only handles ----------------------------------------------------

  getScene(): THREE.Scene {
    return this.scene;
  }

  getCamera(): THREE.PerspectiveCamera {
    return this.camera;
  }

  getRenderer(): THREE.WebGLRenderer {
    return this.renderer;
  }

  // ----------------------------------------------------------------------------
  // Private helpers
  // ----------------------------------------------------------------------------

  /** (Re)build the particle field to match the requested instance count. */
  private rebuildParticles(count: number): void {
    // Remove old mesh
    if (this.particleMesh) {
      this.scene.remove(this.particleMesh);
      safeDispose(this.particleMaterial);
      safeDispose(this.particleGeometry);
      this.particleMesh = null;
      this.particleMaterial = null;
      this.particleGeometry = null;
    }

    // Geometry: distribute points within a stretched sphere shell to suggest depth.
    const positions = new Float32Array(count * 3);
    const seeds = new Float32Array(count);
    const tmp = new THREE.Vector3();

    for (let i = 0; i < count; i++) {
      // Fibonacci-ish distribution on unit sphere, then scale to shell radius
      const r1 = Math.random();
      const r2 = Math.random();
      const theta = 2 * Math.PI * r1;
      const phi = Math.acos(2 * r2 - 1);
      tmp.setFromSphericalCoords(1, phi, theta);

      // Radial band (0.5..1.0) to leave center less dense for readability
      const radius = 1.0 + Math.random() * 2.6; // 1..3.6
      // Slight anisotropy to create a "nebula" look
      tmp.multiply(new THREE.Vector3(1.0, 0.82, 1.0)).multiplyScalar(radius);

      positions[i * 3 + 0] = tmp.x;
      positions[i * 3 + 1] = tmp.y;
      positions[i * 3 + 2] = tmp.z;

      // Seed influences per-point twinkle/velocity
      seeds[i] = Math.random();
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));

    // Material: audio-reactive shimmer
    const material = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: this.uniforms as any,
      vertexShader: PARTICLE_VS,
      fragmentShader: PARTICLE_FS,
    });

    const points = new THREE.Points(geometry, material);
    points.frustumCulled = false;

    // Keep references
    this.particleGeometry = geometry;
    this.particleMaterial = material;
    this.particleMesh = points;

    // Insert into scene
    this.scene.add(points);
  }

  /** Apply renderer-level hints based on toggles/preset. */
  private applyRendererHints(): void {
    // "HDR" placeholder: actual HDR would require float render targets and tone mapping.
    // We approximate with a mild exposure boost only when hdr flag is true.
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = this.hdr ? 1.1 : 1.0;

    // Dithering helps gradients on LDR displays
    (this.renderer as any).dither = this.preset.dither === true;
  }
}

// ----------------------------------------------------------------------------
// Shaders
// ----------------------------------------------------------------------------

// Vertex shader: places particles and applies subtle audio/time displacement.
const PARTICLE_VS = /* glsl */ `
attribute float aSeed;

uniform float uTime;
uniform float uAudioRms;
uniform float uAudioBass;
uniform float uAudioMid;
uniform float uAudioTreble;
uniform float uMotionScale;

varying float vTwinkle;
varying float vDepth;

void main() {
  vec3 p = position;

  // Seed-based orbit with slow drift; bass adds pulsation magnitude.
  float seed = aSeed * 43758.5453123;
  float t = uTime * (0.25 + fract(seed));
  float wob = (uAudioBass * 0.65 + uAudioRms * 0.35) * uMotionScale;

  // Low-frequency circular drift around origin (cheap orbital look)
  p.x += sin(t * 0.7 + seed) * wob * 0.6;
  p.y += cos(t * 0.6 + seed * 1.7) * wob * 0.4;
  p.z += sin(t * 0.5 + seed * 2.1) * wob * 0.5;

  // Audio-reactive scale inward/outward to "breathe" with the music
  float breathe = 1.0 + (uAudioRms * 0.08 + uAudioMid * 0.04) * uMotionScale;
  p *= breathe;

  vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
  gl_Position = projectionMatrix * mvPosition;

  // Size attenuates with distance; add a little treble sparkle
  float dist = length(mvPosition.xyz);
  float baseSize = 1.6 + uAudioTreble * 0.8;
  gl_PointSize = baseSize * (300.0 / max(60.0, dist * 60.0));

  // Varying for fragment
  vDepth = clamp(dist / 26.0, 0.0, 1.0);
  vTwinkle = fract(seed + uTime * (0.3 + uAudioTreble * 1.5));
}
`;

// Fragment shader: soft round sprite with gradient color and optional "bloom mix".
const PARTICLE_FS = /* glsl */ `
precision highp float;

uniform float uDimmer;
uniform float uBloomMix;
uniform vec3  uColorA;
uniform vec3  uColorB;
uniform float uAudioRms;
uniform float uAudioTreble;

varying float vTwinkle;
varying float vDepth;

void main() {
  // Normalized point coordinates (-1..1)
  vec2 uv = gl_PointCoord * 2.0 - 1.0;
  float r2 = dot(uv, uv);

  // Soft disc: falloff towards edges
  float alpha = smoothstep(1.0, 0.0, r2);

  // Twinkle modulates alpha subtly, more at the center
  float tw = (sin(vTwinkle * 6.28318) * 0.5 + 0.5) * 0.25 * (1.0 - r2);
  alpha *= 0.85 + tw;

  // Color blend from A to B based on depth
  vec3 col = mix(uColorA, uColorB, vDepth);

  // "Bloom mix" is a placeholder — we bias brightness if enabled
  float energy = (0.9 + uBloomMix * 0.6) * (0.7 + uAudioRms * 0.6 + uAudioTreble * 0.2);

  // Dimmer reduces contribution to avoid washing out the UI
  float dim = mix(1.0, 0.72, uDimmer);

  gl_FragColor = vec4(col * energy * dim, alpha * dim);

  // Premultiply for better compositing on glass backgrounds
  gl_FragColor.rgb *= gl_FragColor.a;
}
`;

// ----------------------------------------------------------------------------
// Small math helpers
// ----------------------------------------------------------------------------

function clamp01(v: number): number {
  if (v < 0) return 0;
  if (v > 1) return 1;
  return v;
}

function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}

export default SceneController;
</file>

<file path="src/styles/globals.css">
/* ==========================================================================
   Ethereal Harmony — Global Styles (V1)
   - Design tokens (palette, radii, blur, typography)
   - Minimal, modern reset
   - Glassmorphism utilities (cards, buttons, inputs)
   - Accessible focus ring + reduced motion guard
   - Component hooks used across the app (TopBar, PlayerCard, Transport)
   ========================================================================== */

/* --------------------------------------------------
   Fonts (Montserrat for titles, Lato for body)
   -------------------------------------------------- */
@import url("https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Lato:wght@400&display=swap");

/* --------------------------------------------------
   Root tokens (Dark first — primary theme)
   Toggle .theme-dark / .theme-light on <html> or <body> if needed.
   -------------------------------------------------- */
:root,
:root.theme-dark {
  /* Brand palette */
  --eh-indigo: #1A2B45;     /* Primary Background (Deep Indigo) */
  --eh-lavender: #7F6A9F;   /* Primary Accent (Soft Lavender) */
  --eh-aqua: #00F0FF;       /* Highlight/Interactive (Radiant Aqua) */

  /* Text colors for dark surfaces (AA/AAA against indigo) */
  --eh-text: #EAF1FF;
  --eh-text-muted: #C8D3EA;
  --eh-text-subtle: #A6B6D6;

  /* Glass tokens (strict) */
  --eh-glass-bg: rgba(255, 255, 255, 0.18);            /* slight bump for contrast */
  --eh-glass-bg-strong: rgba(26, 43, 69, 0.30);        /* for small text over visuals */
  --eh-glass-border-color: rgba(255, 255, 255, 0.25);
  --eh-glass-border: 1px solid var(--eh-glass-border-color);
  --eh-glass-radius: 16px;
  --eh-glass-blur: 16px;

  /* Elevation */
  --eh-shadow-1: 0 8px 24px rgba(0, 0, 0, 0.28);
  --eh-shadow-2: 0 12px 32px rgba(0, 0, 0, 0.32);

  /* Focus ring (keyboard only) */
  --eh-focus-outer: 2px solid var(--eh-aqua);
  --eh-focus-offset: 2px;
  --eh-focus-glow: 0 0 0 3px rgba(0, 240, 255, 0.25);

  /* TopBar surface */
  --eh-topbar-bg: rgba(26, 43, 69, 0.92);
  --eh-topbar-border: rgba(255, 255, 255, 0.12);
  --eh-topbar-shadow: 0 2px 10px rgba(0, 0, 0, 0.45);

  /* TopBar improvements */
  --eh-topbar-icon-bg: rgba(255, 255, 255, 0.15);
  --eh-topbar-icon-border: rgba(255, 255, 255, 0.25);
  --eh-topbar-user-bg: rgba(255, 255, 255, 0.1);

  /* Typography */
  --eh-font-title: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  --eh-font-body: "Lato", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;

  /* Type scale (root 16) */
  --eh-fs-xxl: 28px;
  --eh-fs-xl: 22px;
  --eh-fs-lg: 18px;
  --eh-fs-md: 16px;
  --eh-fs-sm: 14px;
  --eh-fs-xs: 12px;

  /* Spacing */
  --eh-gap-2: 2px;
  --eh-gap-4: 4px;
  --eh-gap-6: 6px;
  --eh-gap-8: 8px;
  --eh-gap-12: 12px;
  --eh-gap-16: 16px;
  --eh-gap-24: 24px;
  --eh-gap-md: 16px;
  --eh-gap-lg: 24px;

  /* Shape tokens for controls */
  --eh-radius-16: 16px;
  --eh-radius-12: 12px;
  --eh-radius-10: 10px;
  --eh-radius: var(--eh-radius-16);
  --eh-blur: 16px;

  /* Range/slider */
  --eh-range-track: rgba(255, 255, 255, 0.16);
  --eh-range-thumb: var(--eh-aqua);

  /* Layout container */
  --eh-container-max: 1280px;
  --eh-container-pad: 16px;

  /* Layers */
  --eh-z-overlay: 30;
  --eh-z-toast: 40;
  --eh-z-modal: 50;
}

:root.theme-light {
  --eh-indigo: #f6f7fb;
  --eh-text: #0c1630;
  --eh-text-muted: #364564;
  --eh-text-subtle: #4d5c7a;

  --eh-glass-bg: rgba(26, 43, 69, 0.08);
  --eh-glass-bg-strong: rgba(26, 43, 69, 0.16);
  --eh-glass-border-color: rgba(26, 43, 69, 0.18);
  --eh-glass-border: 1px solid var(--eh-glass-border-color);

  --eh-topbar-bg: rgba(255, 255, 255, 0.82);
  --eh-topbar-border: rgba(26, 43, 69, 0.16);
  --eh-topbar-shadow: 0 2px 10px rgba(0, 0, 0, 0.12);
}

/* Respect OS theme when no explicit theme class is set */
@media (prefers-color-scheme: light) {
  :root:not(.theme-dark):not(.theme-light) {
    --eh-indigo: #f6f7fb;
    --eh-text: #0c1630;
    --eh-text-muted: #364564;
    --eh-text-subtle: #4d5c7a;
    --eh-glass-bg: rgba(26, 43, 69, 0.08);
    --eh-glass-bg-strong: rgba(26, 43, 69, 0.16);
    --eh-glass-border-color: rgba(26, 43, 69, 0.18);
    --eh-glass-border: 1px solid var(--eh-glass-border-color);
    --eh-topbar-bg: rgba(255, 255, 255, 0.82);
    --eh-topbar-border: rgba(26, 43, 69, 0.16);
    --eh-topbar-shadow: 0 2px 10px rgba(0, 0, 0, 0.12);
  }
}

/* --------------------------------------------------
   Minimal modern reset
   -------------------------------------------------- */
*,
*::before,
*::after { box-sizing: border-box; }
html, body, #root { height: 100%; }
html { -webkit-text-size-adjust: 100%; }
body {
  margin: 0;
  background: var(--eh-indigo);
  color: var(--eh-text);
  font-family: var(--eh-font-body);
  font-size: var(--eh-fs-md);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
img, picture, video, canvas, svg { display: block; max-width: 100%; }
button, input, select, textarea { font: inherit; color: inherit; background: transparent; border: none; }
a { color: var(--eh-aqua); text-decoration: none; }
a:hover, a:focus-visible { text-decoration: underline; text-underline-offset: 2px; }
ul, ol { padding-inline-start: 1.25rem; }
::selection { background: color-mix(in oklab, var(--eh-aqua) 30%, transparent); }

/* --------------------------------------------------
   Typography
   -------------------------------------------------- */
h1, h2, h3, h4, h5, h6 {
  font-family: var(--eh-font-title);
  color: var(--eh-text);
  margin: 0 0 var(--eh-gap-12);
}
h1 { font-size: var(--eh-fs-xxl); letter-spacing: 0.5px; }
h2 { font-size: var(--eh-fs-xl); letter-spacing: 0.4px; }
h3 { font-size: var(--eh-fs-lg); letter-spacing: 0.3px; }
.eh-title { font-family: var(--eh-font-title); letter-spacing: 0.5px; }

/* --------------------------------------------------
   Accessibility — focus ring
   -------------------------------------------------- */
:where(
  button,
  [role="button"],
  [href],
  input,
  select,
  textarea,
  [tabindex]:not([tabindex="-1"])
):focus-visible {
  outline: var(--eh-focus-outer);
  outline-offset: var(--eh-focus-offset);
  box-shadow: var(--eh-focus-glow);
}
:focus:not(:focus-visible) { outline: none; }

/* Screen reader only utility */
.sr-only,
.visually-hidden {
  position: absolute !important;
  width: 1px; height: 1px;
  padding: 0; margin: -1px;
  overflow: hidden; clip: rect(0, 0, 0, 0);
  white-space: nowrap; border: 0;
}

/* --------------------------------------------------
   Layout utilities
   -------------------------------------------------- */
.eh-container { width: 100%; max-width: var(--eh-container-max); margin-inline: auto; padding-inline: var(--eh-container-pad); }
.eh-hstack { display: flex; align-items: center; gap: var(--eh-gap-12); }
.eh-vstack { display: flex; flex-direction: column; gap: var(--eh-gap-12); }
.eh-clamp { max-width: 70ch; }

/* --------------------------------------------------
   Glassmorphism blocks
   -------------------------------------------------- */
.eh-glass {
  background: var(--eh-glass-bg);
  backdrop-filter: blur(var(--eh-glass-blur)) saturate(120%);
  -webkit-backdrop-filter: blur(var(--eh-glass-blur)) saturate(120%);
  border: var(--eh-glass-border);
  border-radius: var(--eh-glass-radius);
  box-shadow: var(--eh-shadow-1), inset 0 1px 0 rgba(255,255,255,0.20);
}
.eh-glass--strong {
  background:
    linear-gradient(0deg, var(--eh-glass-bg-strong), var(--eh-glass-bg-strong)),
    var(--eh-glass-bg);
}
.eh-card { padding: var(--eh-gap-16); border-radius: var(--eh-glass-radius); }

/* Canvas layering */
.eh-canvas-wrap { position: fixed; inset: 0; z-index: 0; pointer-events: none; }
.eh-content-layer { position: relative; z-index: 1; }

/* --------------------------------------------------
   TopBar (A/B/C clean + blocking fix)
   -------------------------------------------------- */
.topbar {
  position: sticky;
  top: 0;
  height: var(--eh-topbar-h);
  z-index: 30; /* above content, below modals */
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  gap: 24px;
  padding: 0 24px;
  background: var(--eh-topbar-bg);
  border: 1px solid var(--eh-topbar-border);
  border-radius: var(--eh-radius-16);
  box-shadow: var(--eh-topbar-shadow);
}

.topbar__left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.topbar__center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.topbar__right {
  display: flex;
  align-items: center;
  gap: 12px;
}

/* Optional visible title (keep hidden in most cases to avoid duplication) */
.topbar__title {
  font-family: var(--eh-font-title);
  font-weight: 700;
  font-size: 14px;
  letter-spacing: .4px;
  color: #fff;
}

/* Status dot */
.topbar__status {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--eh-aqua);
  box-shadow: 0 0 10px var(--eh-aqua), 0 0 20px rgba(0,240,255,.6);
  margin-left: 8px;
}

/* Center wrapper never eats clicks outside the search itself */
.topbar__center .searchbar,
.topbar__center .searchbar * {
  pointer-events: auto;
}

/* Brand visuals (decorative) */
.topbar__brand {
  display: flex;
  align-items: center;
  gap: 8px;
}

.brandmark {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  color: var(--eh-aqua);
}

.topbar__silhouette {
  width: 2px;
  height: 16px;
  background: var(--eh-text-muted);
  border-radius: 1px;
}

/* Icon buttons */
.icon-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 12px;
  border: 1px solid transparent;
  background: transparent;
  outline: none;
  cursor: pointer;
}
.icon-btn:hover { background: rgba(255,255,255,0.06); }
.icon-btn:focus-visible {
  box-shadow: 0 0 0 2px rgba(0,240,255,.9), 0 0 0 4px rgba(0,0,0,.3);
  border-color: rgba(255,255,255,0.25);
}

/* Searchbar (glass) used inside topbar__center */
.searchbar {
  display: grid;
  grid-template-columns: 20px 1fr;
  align-items: center;
  gap: 8px;
  width: 100%;
  max-width: 640px;
  height: 40px;
  padding: 0 12px;
  border-radius: var(--eh-radius-16);
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  backdrop-filter: blur(var(--eh-glass-blur));
}
.searchbar__input {
  width: 100%;
  height: 100%;
  background: transparent;
  color: #fff;
  border: 0;
  outline: none;
  font: 400 14px/1 var(--eh-font-body, Lato, system-ui, sans-serif);
}
.searchbar__input::placeholder { color: rgba(255,255,255,0.7); }

/* Optional generic input with glass styling */
.input-glass {
  width: 100%; max-width: 560px; height: 38px;
  padding: 0 12px;
  border-radius: var(--eh-radius-12);
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  color: var(--eh-text);
  outline: none;
  transition: box-shadow 120ms ease, background-color 120ms ease;
  backdrop-filter: blur(var(--eh-glass-blur));
}
.input-glass::placeholder { color: var(--eh-text-subtle); }
.input-glass:focus-visible { outline: var(--eh-focus-outer); outline-offset: var(--eh-focus-offset); box-shadow: var(--eh-focus-glow); }

/* --------------------------------------------------
   SidePanel guards so it does not block clicks when closed
   -------------------------------------------------- */
/* SidePanel visibility hooks */
.sidepanel {
  width: 100%;
  height: 100%;
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  border-radius: var(--eh-glass-radius);
  backdrop-filter: blur(var(--eh-glass-blur));
  box-shadow: var(--eh-shadow-1);
  overflow: hidden;
}

.sidepanel[data-state="open"] {
  transform: translateX(0);
  opacity: 1;
  pointer-events: auto;
}

/* Keep layout reserved width when open on desktop */
@media (min-width: 1024px) {
  .layout-shell {
    grid-template-columns: var(--sidepanel-w, 280px) 1fr;
  }
}

/* Header layout with search - removed conflicting styles */

/* --------------------------------------------------
   Buttons (glass) used across toolbar/transport
   -------------------------------------------------- */
.glass-btn {
  min-width: 44px; min-height: 36px;
  display: inline-flex; align-items: center; justify-content: center;
  padding: 0 12px;
  border-radius: var(--eh-radius-12);
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  color: var(--eh-text);
  cursor: pointer; user-select: none;
  transition: transform 120ms ease, box-shadow 120ms ease, background-color 120ms ease;
  will-change: transform;
}
.glass-btn:hover { transform: translateY(-1px); box-shadow: var(--eh-shadow-2); }
.glass-btn:active { transform: translateY(0); }
.glass-btn[aria-pressed="true"], .glass-btn.is-active {
  background: color-mix(in oklab, var(--eh-aqua) 20%, var(--eh-glass-bg));
  border-color: color-mix(in oklab, var(--eh-aqua) 60%, var(--eh-glass-border-color));
}
.glass-btn--primary {
  background: color-mix(in oklab, var(--eh-aqua) 12%, var(--eh-glass-bg));
  border-color: color-mix(in oklab, var(--eh-aqua) 45%, var(--eh-glass-border-color));
}
.eh-iconbtn { width: 36px; height: 36px; padding: 0; border-radius: var(--eh-radius-10); }

/* --------------------------------------------------
   Transport / Playback layout
   -------------------------------------------------- */
.playback-buttons {
  display: flex; align-items: center; gap: var(--eh-gap-8);
}
.playback-buttons__spacer { flex: 1 1 auto; }

/* --------------------------------------------------
   Range inputs (sliders: intensity, bloom, volume)
   -------------------------------------------------- */
input[type="range"] {
  -webkit-appearance: none; appearance: none;
  width: 100%; height: 2px;
  background: var(--eh-range-track);
  border-radius: 999px; outline: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none;
  width: 14px; height: 14px; border-radius: 50%;
  background: var(--eh-range-thumb); border: 2px solid rgba(0,0,0,0.15);
  margin-top: -6px;
}
input[type="range"]::-moz-range-thumb {
  width: 14px; height: 14px; border-radius: 50%;
  background: var(--eh-range-thumb); border: 2px solid rgba(0,0,0,0.15);
}
input[type="range"]:focus-visible::-webkit-slider-thumb,
input[type="range"]:focus-visible::-moz-range-thumb { box-shadow: var(--eh-focus-glow); }

/* --------------------------------------------------
   Segmented control (PresetSelector)
   -------------------------------------------------- */
.eh-segment {
  display: inline-flex; gap: var(--eh-gap-6); padding: var(--eh-gap-6);
  border-radius: calc(var(--eh-radius-12) + 4px);
  background: color-mix(in oklab, var(--eh-glass-bg) 80%, transparent);
  border: var(--eh-glass-border);
  backdrop-filter: blur(var(--eh-glass-blur));
}
.eh-segment__item {
  color: var(--eh-text);
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  border-radius: var(--eh-radius-12);
  padding: 8px 12px; cursor: pointer; user-select: none;
  transition: transform 120ms ease, box-shadow 120ms ease, background-color 120ms ease;
}
.eh-segment__item:hover { transform: translateY(-1px); }
.eh-segment__item:active { transform: translateY(0); }
.eh-segment__item.is-selected {
  box-shadow: 0 0 0 2px var(--eh-aqua);
  background: color-mix(in oklab, var(--eh-aqua) 18%, var(--eh-glass-bg));
}
.eh-segment__item:focus-visible { outline: var(--eh-focus-outer); outline-offset: var(--eh-focus-offset); }

/* --------------------------------------------------
   Scrollbar (WebKit)
   -------------------------------------------------- */
*::-webkit-scrollbar { width: 10px; height: 10px; }
*::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.2);
  border-radius: 999px;
  border: 2px solid transparent;
  background-clip: padding-box;
}
*::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.28); }

/* --------------------------------------------------
   Overlays / Toasts
   -------------------------------------------------- */
.eh-overlay {
  position: fixed; inset: 0; z-index: var(--eh-z-overlay);
  display: grid; place-items: center;
  background: rgba(0,0,0,0.35);
  backdrop-filter: blur(6px);
}
.eh-toast {
  z-index: var(--eh-z-toast);
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  border-radius: var(--eh-glass-radius);
  padding: var(--eh-gap-16);
  box-shadow: var(--eh-shadow-1), inset 0 1px 0 rgba(255,255,255,0.20);
}

/* --------------------------------------------------
   Reduced motion
   -------------------------------------------------- */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.001ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.001ms !important;
    scroll-behavior: auto !important;
  }
}

/* --------------------------------------------------
   Legacy helpers for compatibility
   -------------------------------------------------- */
.glass-panel {
  border-radius: 16px;
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  background: rgba(255, 255, 255, 0.18);
  border: 1px solid rgba(255, 255, 255, 0.25);
}
.title-font {
  font-family: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
  font-weight: 700;
}

/* ==========================================================================
   COMPONENT STYLES
   ========================================================================== */

/* TopBar improvements */
.topbar__left {
  display: flex;
  align-items: center;
  gap: 24px;
}

.topbar__title h1 {
  font-family: var(--eh-font-title);
  font-weight: 700;
  color: var(--eh-text);
  white-space: nowrap;
}

.topbar__menu {
  display: flex;
  align-items: center;
  gap: 16px;
}

.menu-item {
  font-size: 12px;
  color: var(--eh-text-muted);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 6px;
  transition: all 0.2s ease;
  user-select: none;
}

.menu-item:hover {
  color: var(--eh-text);
  background: rgba(255, 255, 255, 0.05);
}

.topbar__right {
  display: flex;
  align-items: center;
  gap: 16px; /* Increased gap for better spacing */
}

.topbar__search {
  display: flex;
  align-items: center;
  margin-right: 8px; /* Add some space before the user avatar */
}

.topbar__user {
  display: flex;
  align-items: center;
}

.user-avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--eh-text);
  cursor: pointer;
  transition: all 0.2s ease;
}

.user-avatar:hover {
  background: rgba(255, 255, 255, 0.08) !important;
  border-color: rgba(255, 255, 255, 0.3) !important;
}

.topbar__settings {
  transition: all 0.2s ease;
}

.topbar__settings:hover {
  background: rgba(255, 255, 255, 0.08) !important;
  border-color: rgba(255, 255, 255, 0.3) !important;
}

/* Collapsible TopBar */
.topbar-collapsed {
  position: sticky;
  top: 0;
  z-index: 30;
  display: flex;
  justify-content: center;
  padding: 8px;
  background: rgba(26, 43, 69, 0.8);
  backdrop-filter: blur(8px);
}

/* Collapsible SidePanel */
.sidepanel-collapsed {
  position: fixed;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  z-index: 25;
  display: flex;
  justify-content: center;
  padding: 8px;
  background: rgba(26, 43, 69, 0.8);
  backdrop-filter: blur(8px);
  border-radius: 0 8px 8px 0;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-left: none;
}

.collapse-toggle {
  transition: all 0.2s ease;
}

.collapse-toggle:hover {
  background: rgba(255, 255, 255, 0.08) !important;
  border-color: rgba(255, 255, 255, 0.3) !important;
  transform: translateY(-1px);
}

/* LED Indicator Animation */
@keyframes pulse {
  0% {
    opacity: 0.6;
    box-shadow: 0 0 10px var(--eh-aqua), 0 0 20px rgba(0,240,255,.4);
  }
  100% {
    opacity: 1;
    box-shadow: 0 0 15px var(--eh-aqua), 0 0 30px rgba(0,240,255,.8);
  }
}

.led-indicator {
  flex-shrink: 0;
}

/* SidePanel improvements */
.sidepanel__header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
}

.sidepanel__brand {
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1;
}

.sidepanel__label {
  font-weight: 600;
  font-size: 14px;
  color: var(--eh-text);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.sidepanel__toggle {
  position: absolute;
  right: 16px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.sidepanel__toggle:hover {
  background: rgba(255, 255, 255, 0.15);
  border-color: rgba(255, 255, 255, 0.3);
}

.sidepanel__nav {
  padding: 16px;
}

.sidepanel__search-integrated {
  margin-bottom: 20px;
  display: flex;
  justify-content: center;
}

.navlist {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.navitem {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  border-radius: 12px;
  color: var(--eh-text);
  text-decoration: none;
  transition: background-color 0.2s ease;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  margin-bottom: 4px;
}

.navitem:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.2);
}

.navitem__icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  color: var(--eh-aqua);
  flex-shrink: 0;
}

.navitem__label {
  font-weight: 500;
  font-size: 14px;
  flex: 1;
}

/* Improved icon button styling */
.icon-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: var(--eh-text);
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(8px);
}

.icon-btn:hover {
  background: rgba(255, 255, 255, 0.15);
  border-color: rgba(255, 255, 255, 0.3);
  transform: translateY(-1px);
}

.icon-btn:active {
  transform: translateY(0);
}

/* Glass surface utilities */
.glass-surface {
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  border-radius: var(--eh-glass-radius);
  backdrop-filter: blur(var(--eh-glass-blur));
  box-shadow: var(--eh-shadow-1);
}

.eh-glass {
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  border-radius: var(--eh-glass-radius);
  backdrop-filter: blur(var(--eh-glass-blur));
  box-shadow: var(--eh-shadow-1);
}

/* Layout utilities */
.eh-hstack {
  display: flex;
  align-items: center;
}

.eh-vstack {
  display: flex;
  flex-direction: column;
}

.eh-title {
  font-family: var(--eh-font-title);
  font-weight: 700;
  color: var(--eh-text);
}

.eh-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 8px 16px;
  border-radius: var(--eh-radius-12);
  border: 1px solid rgba(255, 255, 255, 0.2);
  background: rgba(255, 255, 255, 0.1);
  color: var(--eh-text);
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(8px);
}

.eh-btn:hover {
  background: rgba(255, 255, 255, 0.15);
  border-color: rgba(255, 255, 255, 0.3);
}

.eh-iconbtn {
  width: 40px;
  height: 40px;
  padding: 0;
  border-radius: var(--eh-radius-12);
}

/* Controls grid */
.eh-controls-grid {
  display: flex;
  align-items: center;
  gap: var(--eh-gap-md);
  padding: var(--eh-gap-md);
  background: var(--eh-glass-bg);
  border: var(--eh-glass-border);
  border-radius: var(--eh-glass-radius);
  backdrop-filter: blur(var(--eh-glass-blur));
  min-height: 60px; /* Proper height for HDR/Dimmer controls bar */
}

/* Screen reader only */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.sidepanel__search {
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  margin-bottom: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.sidepanel__hide-btn {
  width: 32px;
  height: 32px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.sidepanel__hide-btn:hover {
  background: rgba(255, 255, 255, 0.08) !important;
  border-color: rgba(255, 255, 255, 0.3) !important;
  transform: translateX(-2px);
}
</file>

<file path="src/styles/tokens.css">
/* ==========================================================================
   Ethereal Harmony — DESIGN TOKENS (V1)
   --------------------------------------------------------------------------
   Purpose:
     Central source of truth for colors, typography, radii, spacing, motion,
     elevation, component dimensions, z-layers, and breakpoints.

   Usage:
     - Import this file once in your app entry (e.g., main.tsx).
     - Reference tokens via var(--token-name) in all component styles.
     - Do NOT put component-specific rules here; keep this file 100% tokens.

   Themes:
     - Dark is the default aesthetic (Deep Indigo).
     - Optional Light theme overrides are provided via .theme-light.
     - If no theme class is set, OS preference can steer tokens.
   ========================================================================== */


/* --------------------------------------------------------------------------
   SECTION 1 — DARK THEME (DEFAULT)
   Attach .theme-dark to :root or body to force dark explicitly.
   Without any theme class, these variables define the baseline.
   -------------------------------------------------------------------------- */
:root,
:root.theme-dark {
  /* ===== 1.1 BRAND PALETTE =====
     Hex codes are canonical and must match the blueprint.
     - Deep Indigo: Primary canvas/background
     - Soft Lavender: Accent (non-critical)
     - Radiant Aqua: Interactive/focus highlight
  */
  --eh-indigo:   #1A2B45;
  --eh-lavender: #7F6A9F;
  --eh-aqua:     #00F0FF;

  /* ===== 1.2 SURFACES & TEXT =====
     Surface alphas are tuned to remain legible over reactive visuals.
     Text colors meet AA on Deep Indigo backgrounds.
  */
  --eh-bg:              var(--eh-indigo);
  --eh-surface:         rgba(255, 255, 255, 0.06);
  --eh-surface-strong:  rgba(26, 43, 69, 0.30);
  --eh-text:            #EAF1FF;
  --eh-text-muted:      #C8D3EA;
  --eh-text-subtle:     #A6B6D6;

  /* ===== 1.3 SEMANTIC (Reserved for toasts/status/UI cues) ===== */
  --eh-success: #37D39B;
  --eh-warning: #FFCC66;
  --eh-danger:  #FF6B6B;
  --eh-info:    #7FB7FF;

  /* ===== 1.4 GLASS TOKENS =====
     Strictly follow our glassmorphism spec.
  */
  --eh-glass-bg:             rgba(255, 255, 255, 0.12);
  --eh-glass-bg-strong:      rgba(26, 43, 69, 0.30); /* text AA on bright viz */
  --eh-glass-border-color:   rgba(255, 255, 255, 0.25);
  --eh-glass-border:         1px solid var(--eh-glass-border-color);
  --eh-glass-radius:         16px;
  --eh-glass-blur:           16px;

  /* ===== 1.5 ELEVATION / SHADOWS =====
     Keep modest for perf; avoid deep multi-layer stacks.
  */
  --eh-shadow-1:     0 8px 24px rgba(0, 0, 0, 0.28);
  --eh-shadow-2:     0 12px 32px rgba(0, 0, 0, 0.32);
  --eh-shadow-inset: inset 0 1px 0 rgba(255, 255, 255, 0.20);

  /* ===== 1.6 TYPOGRAPHY =====
     Montserrat (titles), Lato (body). Scale assumes root 16px.
  */
  --eh-font-title: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  --eh-font-body:  "Lato",       system-ui, -apple-system, Segoe UI, Roboto, sans-serif;

  --eh-fs-xxl: 28px;
  --eh-fs-xl:  22px;
  --eh-fs-lg:  18px;
  --eh-fs-md:  16px;
  --eh-fs-sm:  14px;
  --eh-fs-xs:  12px;

  /* ===== 1.7 SPACING SCALE ===== */
  --eh-gap-2:   2px;
  --eh-gap-4:   4px;
  --eh-gap-6:   6px;
  --eh-gap-8:   8px;
  --eh-gap-12:  12px;
  --eh-gap-16:  16px;
  --eh-gap-24:  24px;
  --eh-gap-32:  32px;

  /* ===== 1.8 RADII ===== */
  --eh-radius-10: 10px;  /* small chips, icon buttons */
  --eh-radius-12: 12px;  /* inputs, buttons */
  --eh-radius-16: 16px;  /* cards/panels  */

  /* Component aliases for clarity */
  --eh-button-radius: var(--eh-radius-12);
  --eh-chip-radius:   var(--eh-radius-12);

  /* ===== 1.9 CONTROLS (range/slider) ===== */
  --eh-range-track: rgba(255, 255, 255, 0.15);
  --eh-range-thumb: var(--eh-aqua);

  /* ===== 1.10 FOCUS / ACCESSIBILITY ===== */
  --eh-focus-outer:  2px solid var(--eh-aqua);
  --eh-focus-offset: 2px;
  --eh-focus-glow:   0 0 0 3px rgba(0, 240, 255, 0.25);

  /* ===== 1.11 MOTION / EASING / DURATION =====
     Keep values small and responsive—WebGL backdrop should stay 55–60 FPS.
  */
  --eh-ease-out:     cubic-bezier(0.16, 1, 0.3, 1);
  --eh-ease-in:      cubic-bezier(0.32, 0, 0.67, 0);
  --eh-ease-in-out:  cubic-bezier(0.65, 0, 0.35, 1);

  --eh-duration-1: 120ms; /* micro interactions: buttons, toggles */
  --eh-duration-2: 180ms; /* small surfaces: menus, dropdowns     */
  --eh-duration-3: 240ms; /* overlays: modals, drawers            */

  /* ===== 1.12 Z-LAYERS =====
     Tight, predictable ranges aid compositor stability.
  */
  --eh-z-base:    0;
  --eh-z-canvas:  0; /* WebGL layer */
  --eh-z-content: 1; /* UI above canvas */
  --eh-z-overlay: 30;
  --eh-z-toast:   40;
  --eh-z-modal:   50;
  --eh-z-tooltip: 60;

  /* ===== 1.13 DIMENSIONS ===== */
  --eh-sidepanel-w: 260px;
  --eh-topbar-h:    64px;
  --eh-component-gap: 24px;
  --eh-controls-gap: 16px;

  /* ===== 1.14 BREAKPOINTS ===== */
  --eh-bp-sm:  480px;
  --eh-bp-md:  768px;
  --eh-bp-lg:  1024px;
  --eh-bp-xl:  1280px;

  /* ===== 1.15 LAYOUT CONTAINER ===== */
  --eh-container-max: 1280px;
  --eh-container-pad: 16px;

  /* ===== 1.16 BRAND GRADIENT (decorative) ===== */
  --eh-gradient-brand: linear-gradient(90deg, #1A2B45 0%, #7F6A9F 100%);

  /* ===== 1.17 TOPBAR SURFACE (used in global.css styles) ===== */
  --eh-topbar-bg:     rgba(26, 43, 69, 0.92);
  --eh-topbar-border: rgba(255, 255, 255, 0.12);
  --eh-topbar-shadow: 0 2px 10px rgba(0, 0, 0, 0.45);
}


/* --------------------------------------------------------------------------
   SECTION 2 — LIGHT THEME (OPTIONAL)
   Overrides a small set of tokens to maintain contrast on light surfaces.
   -------------------------------------------------------------------------- */
:root.theme-light {
  /* Base canvas & text */
  --eh-bg:         #F6F7FB;
  --eh-text:       #0C1630;
  --eh-text-muted: #364564;
  --eh-text-subtle:#4D5C7A;

  /* Surfaces tuned for light background */
  --eh-surface:        rgba(26, 43, 69, 0.04);
  --eh-surface-strong: rgba(26, 43, 69, 0.16);

  /* Keep brand colors identical */
  --eh-indigo:   #1A2B45;
  --eh-lavender: #7F6A9F;
  --eh-aqua:     #00F0FF;

  /* Glass on light must be a bit stronger to hold AA */
  --eh-glass-bg:           rgba(26, 43, 69, 0.08);
  --eh-glass-bg-strong:    rgba(26, 43, 69, 0.16);
  --eh-glass-border-color: rgba(26, 43, 69, 0.18);
  --eh-glass-border:       1px solid var(--eh-glass-border-color);

  /* TopBar on light */
  --eh-topbar-bg:     rgba(255, 255, 255, 0.82);
  --eh-topbar-border: rgba(26, 43, 69, 0.16);
  --eh-topbar-shadow: 0 2px 10px rgba(0, 0, 0, 0.12);
}


/* --------------------------------------------------------------------------
   SECTION 3 — OS PREFERENCE BASELINE
   If no explicit theme class is present, allow prefers-color-scheme: light
   to adjust a minimal subset of tokens. App store can still set class-based
   theme to persist choice.
   -------------------------------------------------------------------------- */
@media (prefers-color-scheme: light) {
  :root:not(.theme-dark):not(.theme-light) {
    --eh-bg:         #F6F7FB;
    --eh-text:       #0C1630;
    --eh-text-muted: #364564;
    --eh-text-subtle:#4D5C7A;

    --eh-surface:        rgba(26, 43, 69, 0.04);
    --eh-surface-strong: rgba(26, 43, 69, 0.16);

    --eh-glass-bg:           rgba(26, 43, 69, 0.08);
    --eh-glass-bg-strong:    rgba(26, 43, 69, 0.16);
    --eh-glass-border-color: rgba(26, 43, 69, 0.18);
    --eh-glass-border:       1px solid var(--eh-glass-border-color);

    --eh-topbar-bg:     rgba(255, 255, 255, 0.82);
    --eh-topbar-border: rgba(26, 43, 69, 0.16);
    --eh-topbar-shadow: 0 2px 10px rgba(0, 0, 0, 0.12);
  }
}


/* --------------------------------------------------------------------------
   SECTION 4 — ALPHA & MIX HELPERS (UTILITY TOKENS)
   Use these to generate consistent semi-transparent overlays in components.
   (Keep the set small to avoid proliferation.)
   -------------------------------------------------------------------------- */
:root {
  --eh-alpha-02: rgba(255, 255, 255, 0.02);
  --eh-alpha-04: rgba(255, 255, 255, 0.04);
  --eh-alpha-08: rgba(255, 255, 255, 0.08);
  --eh-alpha-12: rgba(255, 255, 255, 0.12);
  --eh-alpha-16: rgba(255, 255, 255, 0.16);
  --eh-alpha-24: rgba(255, 255, 255, 0.24);
  --eh-alpha-32: rgba(255, 255, 255, 0.32);
}


/* --------------------------------------------------------------------------
   SECTION 5 — BACKWARD-COMPATIBILITY ALIASES
   These map older variable names from early drafts to the new canonical set.
   DO NOT add new features here; remove mappings only in a major version.
   -------------------------------------------------------------------------- */
:root {
  /* Early brand tokens */
  --eh-accent:    var(--eh-lavender);
  --eh-highlight: var(--eh-aqua);

  /* Older text naming */
  --eh-text-dim:  var(--eh-text-muted);

  /* Early radius alias */
  --eh-radius: var(--eh-glass-radius);

  /* Legacy border alias (some files referenced this) */
  --eh-glass-border-legacy: var(--eh-glass-border);

  /* Container aliases */
  --eh-container: var(--eh-container-max);
}


/* --------------------------------------------------------------------------
   SECTION 6 — COMPONENT TOKEN SLOTS (NO STYLES)
   These are named hooks for components to consume consistently.
   Example: TopBar uses the variables but its CSS lives in global.css/components.
   -------------------------------------------------------------------------- */
:root {
  /* TopBar */
  --eh-topbar-bg-token:     var(--eh-topbar-bg);
  --eh-topbar-border-token: var(--eh-topbar-border);
  --eh-topbar-shadow-token: var(--eh-topbar-shadow);

  /* PlayerCard */
  --eh-player-surface:      var(--eh-glass-bg);
  --eh-player-border:       var(--eh-glass-border);
  --eh-player-radius:       var(--eh-glass-radius);

  /* Visualizer overlay controls */
  --eh-viz-chip-bg:         var(--eh-glass-bg);
  --eh-viz-chip-border:     var(--eh-glass-border);
  --eh-viz-chip-radius:     var(--eh-chip-radius);

  /* Focusable control surfaces */
  --eh-ctl-bg:              var(--eh-glass-bg);
  --eh-ctl-bg-active:       color-mix(in oklab, var(--eh-aqua) 18%, var(--eh-glass-bg));
  --eh-ctl-border:          var(--eh-glass-border);
  --eh-ctl-radius:          var(--eh-button-radius);
}
</file>

<file path="src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="src/index.css">
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
</file>

<file path="src/index.tsx">
// src/index.tsx
/**
 * Entry point (Vite + React 18)
 * -----------------------------------------------------------------------------
 * Responsibilities
 * - Bootstraps the React application into #root.
 * - Loads global design tokens and base styles.
 * - Applies a small viewport height fix for mobile browsers (100vh issue).
 * - Keeps StrictMode enabled for dev sanity; our stores/components are designed
 *   to be resilient to double-invoked effects in development.
 * - Wires up Vite HMR for a smooth DX (React Refresh handles component state).
 */

import React from "react";
import ReactDOM from "react-dom/client";

// Global styles: tokens first, then globals (order matters).
import "@/styles/tokens.css";
import "@/styles/globals.css";

// Optional app-level stylesheet(s). Keep lightweight to avoid blocking render.
// If you use index.css for utility classes, import it here.
// import "@/index.css";

import App from "@/app/App";

/** Ensure we have a #root element (Vite template provides this in index.html). */
function ensureRootElement(): HTMLElement {
  const EXISTING = document.getElementById("root");
  if (EXISTING) return EXISTING;

  // In case the host page is missing the container, create one so we can still render.
  const el = document.createElement("div");
  el.id = "root";
  // Use the project's primary background color so we don't flash white.
  el.style.background = "#1A2B45";
  document.body.appendChild(el);
  return el;
}

/**
 * Mobile 100vh fix:
 * Many mobile browsers include the URL bar in the viewport height. We maintain
 * a CSS variable --vh (1% of the current viewport height) that can be used
 * in styles, e.g. height: calc(var(--vh) * 100);
 */
function applyViewportUnitFix() {
  const set = () => {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty("--vh", `${vh}px`);
  };
  set();
  window.addEventListener("resize", set);
  // Clean up on hot-reload navigation (HMR preserves listeners, but keep it simple)
  if (import.meta && import.meta.hot) {
    import.meta.hot.dispose(() => window.removeEventListener("resize", set));
  }
}

// Bootstrap viewport fix ASAP (before first paint where possible)
applyViewportUnitFix();

/** Mount the React tree. */
const rootEl = ensureRootElement();
const root = ReactDOM.createRoot(rootEl);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

/**
 * Vite HMR glue:
 * React Refresh already handles component hot-swapping; we keep this block to
 * avoid duplicate listeners and allow cleanup logic during module replacement.
 */
if (import.meta && import.meta.hot) {
  import.meta.hot.accept();
  import.meta.hot.dispose(() => {
    // You could clean timers or detach global listeners here if you attach any
    // outside React (we already remove the resize listener above).
  });
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path=".hintrc">
{
  "extends": [
    "development"
  ],
  "browserslist": [
    "defaults",
    "not ie 11",
    "not and_ff <= 139",
    "not firefox <= 139",
    "not opera <= 117"
  ]
}
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to the Ethereal Harmony project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased] - 2025-01-XX

### 🎯 Major Features Added
- **Collapsible TopBar**: Added up/down carrot buttons to hide/show the top bar
- **Collapsible SidePanel**: Implemented left/right chevron toggle to hide/show navigation panel
- **LED Light Indicator**: Restored and enhanced blue LED light circle with pulsing animation
- **Functional Audio Player**: All player controls now fully functional with PlaybackController integration

### 🎵 Player Functionality
- **Transport Controls**: Play/pause, previous/next track buttons now control actual audio playback
- **File Upload**: Upload button allows users to select and load local audio files
- **Progress Bar**: Real-time playback progress with seek functionality
- **Volume Controls**: Working volume slider and mute toggle
- **Playback Speed**: Speed control dropdown with rates from 0.5x to 2x
- **Time Display**: Shows current time and total duration

### 🎨 UI/UX Improvements
- **Glassmorphism Enhancement**: Applied consistent glassmorphism effects across all UI elements
  - Subtle drop shadows: `0 2px 8px rgba(0, 0, 0, 0.2)`
  - White stroke borders: `1px solid rgba(255, 255, 255, 0.25)`
  - Reduced opacity: `0.75` for more glass-like appearance
- **Layout Refinements**: 
  - SidePanel width reduced to 260px for better spacing
  - Player controls increased by 30% for better usability
  - Album art placeholder increased by 50%
  - Volume slider extended to 200px width
- **Navigation Cleanup**: 
  - Centered "Navigation" label in SidePanel header
  - Properly positioned search field in dedicated section
  - Clean menu structure for Library, Playlists, Discovery

### 🏗️ Architecture Improvements
- **State Management**: Fixed undefined function errors in SidePanel and TopBar
- **Event Handling**: Proper keyboard shortcuts (Ctrl/Cmd+B, Escape) for panel toggles
- **Component Structure**: Cleaner separation of concerns between layout components
- **Error Handling**: Added proper error handling for file uploads

### 🔧 Technical Fixes
- **Vite Configuration**: Resolved module resolution and alias issues
- **Linter Errors**: Fixed ARIA attribute validation issues
- **Component Props**: Added missing onClick handlers and event functions
- **CSS Organization**: Improved styling structure and consistency

### 📱 Responsive Design
- **Mobile Support**: Enhanced touch interactions for collapsible panels
- **Breakpoint Handling**: Proper desktop vs mobile behavior for SidePanel
- **Accessibility**: Maintained ARIA compliance throughout UI changes

## [Previous Versions]

### [0.2.0] - 2025-01-XX
- **EQ Integration**: EqPanel wired to AudioEngine.ensureEq()
- **Device Management**: Consolidated into OutputDeviceManager
- **Settings Panel**: Centralized HDR, Dimmer, Visualizer preset, and FPS stats
- **HLS Support**: Added hls.js as dependency, documented Safari vs. Chromium path

### [0.1.0] - 2025-01-XX
- **Initial Release**: Core audio player with Three.js visualizer
- **Glassmorphism UI**: Base design system implementation
- **Audio Engine**: Basic playback functionality
- **Visualizer**: SceneCanvas with quality presets

---

## 🚀 How to Use New Features

### Collapsible Panels
- **TopBar**: Click the up carrot (^) to hide, down carrot (v) to show
- **SidePanel**: Click the left chevron (←) to hide, right chevron (→) to show

### Audio Player
- **Upload**: Click upload button to select and load audio files
- **Playback**: Use transport controls to play/pause and navigate tracks
- **Seek**: Click/drag on progress bar to jump to specific times
- **Volume**: Adjust volume with slider or mute with button
- **Speed**: Change playback rate with dropdown selector

### Navigation
- **Keyboard Shortcuts**: 
  - `Ctrl/Cmd + B`: Toggle SidePanel
  - `Escape`: Close SidePanel
- **Search**: Use search fields in both TopBar and SidePanel
- **Menu Items**: Access Library, Playlists, and Discovery sections

---

## 📋 Known Issues

- Some ARIA linter warnings persist (non-blocking)
- Volume slider may need fine-tuning for optimal UX
- File upload error handling could be enhanced with better user feedback

---

## 🔮 Next Steps

- [ ] Add missing icons for Playlists and Discovery navigation items
- [ ] Implement playlist management functionality
- [ ] Add audio format detection and validation
- [ ] Enhance visualizer integration with audio playback
- [ ] Add keyboard shortcuts for all player controls
- [ ] Implement audio metadata extraction from uploaded files
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <meta name="theme-color" content="#1A2B45" />
    <meta name="theme-color" content="#1A2B45" media="(prefers-color-scheme: dark)" />
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)" />
    <meta name="msapplication-TileColor" content="#1A2B45" />
    <title>Ethereal Harmony</title>

    <!-- Performance: preconnect for Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Typography: Montserrat 700 (titles) + Lato 400 (body) -->
    <link
      href="https://fonts.googleapis.com/css2?family=Lato:wght@400&family=Montserrat:wght@700&display=swap"
      rel="stylesheet"
    />

    <!-- App styles: design tokens first, then globals -->
    <link rel="stylesheet" href="/src/styles/tokens.css" />
    <link rel="stylesheet" href="/src/styles/globals.css" />

    <!-- PWA-friendly tags (safe to keep even if no manifest yet) -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
  </head>

  <body>
    <noscript>Enable JavaScript to run Ethereal Harmony.</noscript>

    <!-- Main mount point -->
    <div id="root" role="main" aria-label="Ethereal Harmony Root"></div>

    <!-- Entry script (Vite) -->
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "ethereal-harmony",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "lint": "eslint \"src/**/*.{ts,tsx}\"",
    "e2e": "playwright test",
    "tree": "node scripts/export-tree.mjs",
    "tree:src": "node scripts/export-tree.mjs --root src --out src-structure.txt"
  },
  "dependencies": {
    "framer-motion": "^12.23.12",
    "hls.js": "^1.6.10",
    "lucide-react": "^0.539.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "three": "^0.179.1",
    "zustand": "^5.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^24.2.1",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@typescript-eslint/eslint-plugin": "^8.39.1",
    "@typescript-eslint/parser": "^8.39.1",
    "@vitejs/plugin-react": "^5.0.0",
    "@vitest/coverage-v8": "^3.2.4",
    "eslint": "^9.33.0",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "jsdom": "^26.1.0",
    "playwright": "^1.54.2",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.39.1",
    "vite": "^7.1.2",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="project-structure.txt">
ethereal-harmony/
├── public/
│   ├── test.mp3
│   └── vite.svg
├── scripts/
│   └── export-tree.mjs
├── src/
│   ├── app/
│   │   ├── providers/
│   │   │   ├── ErrorProvider.tsx
│   │   │   ├── MotionProvider.tsx
│   │   │   └── ThemeProvider.tsx
│   │   ├── App.tsx
│   │   └── routes.tsx
│   ├── assets/
│   │   └── react.svg
│   ├── components/
│   │   ├── diagnostics/
│   │   │   ├── DevToggle.tsx
│   │   │   └── PerfOverlayMount.tsx
│   │   ├── feedback/
│   │   │   ├── ErrorBoundary.tsx
│   │   │   └── Toasts.tsx
│   │   ├── layout/
│   │   │   ├── AppChrome.tsx
│   │   │   ├── AppShell.tsx
│   │   │   ├── SidePanel.tsx
│   │   │   └── TopBar.tsx
│   │   ├── player/
│   │   │   ├── AlbumArt.css
│   │   │   ├── AlbumArt.tsx
│   │   │   ├── LocalFileLoader.tsx
│   │   │   ├── MediaKeyBridge.tsx
│   │   │   ├── PlaybackButtons.tsx
│   │   │   ├── PlayerCard.css
│   │   │   ├── PlayerCard.tsx
│   │   │   ├── Timeline.tsx
│   │   │   ├── TrackInfo.css
│   │   │   ├── TrackInfo.tsx
│   │   │   ├── TransportBar.tsx
│   │   │   ├── UrlLoader.tsx
│   │   │   └── VolumeSlider.tsx
│   │   ├── settings/
│   │   │   ├── AudioDevicePicker.tsx
│   │   │   ├── EqPanel.tsx
│   │   │   ├── SettingsPanel.tsx
│   │   │   └── VisualizerControls.tsx
│   │   ├── shortcuts/
│   │   │   └── GlobalHotkeys.tsx
│   │   ├── streaming/
│   │   │   └── StreamTestWizard.tsx
│   │   └── visualizer/
│   │       ├── DimmerToggle.tsx
│   │       ├── HdrToggle.tsx
│   │       ├── index.ts
│   │       ├── ParticlesCanvas.tsx
│   │       ├── PresetSelector.tsx
│   │       └── SceneCanvas.tsx
│   ├── lib/
│   │   ├── audio/
│   │   │   ├── AnalyserBus.ts
│   │   │   ├── AudioEngine.ts
│   │   │   ├── DeviceManager.ts
│   │   │   ├── EQGraph.ts
│   │   │   ├── eqPresets.json
│   │   │   ├── Limiter.ts
│   │   │   ├── OutputDeviceManager.ts
│   │   │   ├── PlaybackController.ts
│   │   │   └── TrackLoader.ts
│   │   ├── diagnostics/
│   │   │   ├── AdaptiveGuard.ts
│   │   │   ├── FpsGuard.ts
│   │   │   ├── PerfEvents.ts
│   │   │   ├── PerfOverlay.ts
│   │   │   └── Probe.ts
│   │   ├── state/
│   │   │   ├── types.ts
│   │   │   ├── usePlayerStore.ts
│   │   │   ├── useSettingsStore.ts
│   │   │   ├── useUIStore.ts
│   │   │   └── useVizStore.ts
│   │   ├── streaming/
│   │   │   └── HlsController.ts
│   │   ├── three/
│   │   │   ├── components/
│   │   │   │   ├── ParticlesField.ts
│   │   │   │   └── PostProcessing.ts
│   │   │   ├── shaders/
│   │   │   │   ├── particles.frag
│   │   │   │   └── particles.vert
│   │   │   ├── ContextLossHandler.ts
│   │   │   ├── SceneController.ts
│   │   │   ├── VisualizerParams.ts
│   │   │   └── VisualizerScene.ts
│   │   ├── utils/
│   │   │   ├── ContrastCheck.ts
│   │   │   ├── FocusRing.ts
│   │   │   ├── FpsGuard.ts
│   │   │   ├── Hotkeys.ts
│   │   │   ├── IconRegistry.ts
│   │   │   ├── MediaSession.ts
│   │   │   ├── ReducedMotion.ts
│   │   │   ├── UrlGuard.ts
│   │   │   ├── useHotkeys.ts
│   │   │   └── Visibility.ts
│   │   └── visualizer/
│   │       ├── QualityPresets.ts
│   │       └── SceneController.ts
│   ├── styles/
│   │   ├── globals.css
│   │   └── tokens.css
│   ├── App.css
│   ├── index.css
│   ├── index.tsx
│   └── vite-env.d.ts
├── .gitignore
├── eslint.config.js
├── ethereal-harmony.zip
├── index.html
├── package-lock.json
├── package.json
├── project-structure.txt
├── README.md
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts
</file>

<file path="README.md">
<picture width="500">
  <img
    src="https://github.com/russell-henderson/ethereal-harmony/blob/master/src/assets/title.jpg?raw=true"
    alt="Ethereal Harmony Music App"
  />
</picture>



# 🎶 Ethereal Harmony

A high-performance, immersive web audio player with a real-time, audio-reactive Three.js visualizer and a sleek glassmorphism UI. Built for speed, accessibility, and trust — all data stays local by default.

---

## ✨ Features

- **Modern Stack**: React 18 + TypeScript + Vite
- **Visualizer**: Three.js (WebGLRenderer) with adaptive quality presets
- **State Management**: Zustand with domain-driven stores (`usePlayerStore`, `useVizStore`)
- **Animations**: Framer Motion for smooth material-style interactions
- **Glassmorphism UI**:
  - Border radius: 16px  
  - Backdrop blur: 16px  
  - Background: `rgba(255, 255, 255, 0.12)`  
  - Border: `1px solid rgba(255, 255, 255, 0.25)`
  - Enhanced shadows: `0 2px 8px rgba(0, 0, 0, 0.2)`
  - Glass opacity: `0.75` for authentic glassmorphism
- **Typography**:
  - Titles: Montserrat (700)
  - Body: Lato (400)
- **Accessibility**: WCAG AA contrast, full keyboard navigation, ARIA roles for custom controls
- **Privacy**: All data stored locally (playlists, settings, EQ)
- **Media Support**:
  - Local file playback with drag & drop
  - Streaming (HLS with native + `hls.js` fallback)
  - Hardware media key integration (via MediaSession API)
- **Collapsible Interface**: 
  - TopBar with up/down toggle
  - SidePanel with left/right toggle
  - LED light indicator with pulsing animation

---

## 🆕 Recent Updates (Latest)

### 🎯 Major New Features
- **Functional Audio Player**: All controls now fully working with PlaybackController
- **File Upload System**: Upload and play local audio files instantly
- **Collapsible Panels**: Hide/show TopBar and SidePanel for more screen space
- **Enhanced Glassmorphism**: Consistent visual effects across all UI elements

### 🎵 Player Improvements
- **Transport Controls**: Working play/pause, previous/next track buttons
- **Progress Bar**: Real-time playback progress with seek functionality
- **Volume System**: Functional volume slider and mute controls
- **Speed Control**: Playback rate adjustment from 0.5x to 2x
- **Time Display**: Current time and duration indicators

### 🎨 UI Enhancements
- **Layout Refinements**: Better spacing, sizing, and positioning
- **Navigation Cleanup**: Organized menu structure and search placement
- **Responsive Design**: Improved mobile and desktop experience
- **Visual Consistency**: Unified glassmorphism effects throughout

---

## 📂 Project Structure

```bash
src/
components/
layout/ # TopBar, SidePanel, AppShell, SearchBar
player/ # PlayerCard, MediaKeyBridge
settings/ # SettingsPanel, EqPanel, VisualizerControls, AudioDevicePicker
visualizer/ # SceneCanvas (primary canvas wrapper)
lib/
audio/ # AudioEngine, HlsController, EQGraph, PlaybackController
state/ # useUIStore, usePlayerStore, useVizStore
utils/ # IconRegistry, useHotkeys
visualizer/ # SceneController, QualityPresets
shaders/ # Particle + postprocessing shaders
styles/
tokens.css # Design tokens (glass, palette)
globals.css # Global resets + imports tokens.css first
```

---

## ⚡ Performance

- Target **55–60 FPS** on mid-range hardware
- Lazy loading + dynamic imports (`hls.js` only loaded if needed)
- Adaptive quality presets scale particle counts & resolution
- Pauses rendering when tab is hidden
- Lightweight, incremental re-renders

---

## 🔊 Audio

- **PlaybackController** handles play/pause/seek/rate/volume
- **File Upload**: Direct file loading with automatic playback
- **EQ**:
  - `EqPanel.tsx` for UI
  - `EQGraph.ts` connected to `AudioEngine.ensureEq()`
  - Presets available, with gain/bypass toggles
- **Output Device Management**:
  - Migrated to `OutputDeviceManager`
  - Accessible through `AudioDevicePicker.tsx`

---

## 📺 Visualizer

- Single entry: `SceneCanvas.tsx`
- Controlled by `SceneController.ts` (quality, uniforms, scene lifecycle)
- Quality presets managed in `QualityPresets.ts`
- Presets: Nebula, Glass Waves, Strobe Pulse
- Stats overlay optional (`eh.dev.showStats` flag)

---

## 📡 HLS Playback

- **Safari / iOS**: Native HLS support
- **Chromium / Firefox**: Fallback to [`hls.js`](https://github.com/video-dev/hls.js)
- `hls.js` is shipped as a dependency but loaded dynamically at runtime  
  → Keeps bundle size lean while avoiding playback failures

---

## 🛠️ Development

### Prerequisites

- Node.js 18+
- npm 9+ or yarn 3+

### Install

```bash
npm install
```

### Run Dev

```bash
npm run dev
```

### Build

```bash
npm run build
```

### Preview

```bash
npm run preview
```

---

## 🎮 How to Use

### Audio Player
1. **Upload Audio**: Click the upload button (↑) to select local audio files
2. **Playback Controls**: Use the large center buttons for play/pause, previous/next
3. **Progress**: Click/drag on the progress bar to seek through tracks
4. **Volume**: Adjust with the slider or mute with the speaker button
5. **Speed**: Change playback rate with the dropdown selector

### Interface
- **Hide TopBar**: Click the up carrot (^) in the top-right
- **Hide SidePanel**: Click the left chevron (←) in the navigation header
- **Keyboard Shortcuts**: 
  - `Ctrl/Cmd + B`: Toggle SidePanel
  - `Escape`: Close SidePanel

---

## ✅ Accessibility Checklist

- Keyboard navigation verified for all custom components
- Proper ARIA roles in buttons, sliders, toggles
- WCAG AA contrast enforced
- Screen reader labels added where applicable
- Collapsible panels maintain accessibility when hidden

---

## 🧹 Code Quality

- TypeScript strict mode
- ESLint + Prettier configured
  - ```tsc --noEmit```
  - ```eslint . --ext .ts,.tsx```
- CSS order lint rule ensures ```tokens.css``` always imports first

---

## 📜 Changelog

For detailed information about all changes, see [CHANGELOG.md](./CHANGELOG.md).

### Recent Highlights
- ✅ **Functional Audio Player**: All controls now working
- ✅ **File Upload System**: Local audio file support
- ✅ **Collapsible Interface**: Hide/show panels for space
- ✅ **Enhanced Glassmorphism**: Consistent visual effects
- ✅ **Navigation Cleanup**: Organized menu structure
- ✅ **Responsive Design**: Better mobile/desktop experience

---

## 🧭 Roadmap (V1)

- [ ] Add missing icons for Playlists and Discovery navigation
- [ ] Implement playlist management functionality
- [ ] Add audio format detection and validation
- [ ] Enhance visualizer integration with audio playback
- [ ] Add keyboard shortcuts for all player controls
- [ ] Implement audio metadata extraction from uploaded files

---

## 📄 License

MIT © 2025 Ethereal Harmony contributors
</file>

<file path="TODO.md">
# TODO — Full‑Stack Master Documentation & Codebase Analysis (Cursor‑Ready Template)

> Purpose: Use this checklist to drive a **comprehensive analysis of an existing codebase** and generate a **Master Documentation Set** that covers architecture, backend, frontend, data, APIs, DevOps, security, performance, and operations. It’s optimized for AI‑assisted editors (e.g., Cursor) and can be adapted to any stack.

---

## 0) Project Variables (fill these in first)

* **Project Name:** `<PROJECT_NAME>`
* **Repo URL(s):** `<REPO_URLS>`
* **Monorepo or Polyrepo:** `<MONOREPO|POLYREPO>`
* **Primary Languages:** `<TS|JS|Python|Go|Java|C#|Ruby|PHP|Rust|Swift|Kotlin|...>`
* **Frameworks:** `<React|Next.js|Vue|Nuxt|Svelte|Angular|Node|NestJS|Express|FastAPI|Django|Rails|Spring|ASP.NET|Go Fiber|...>`
* **Datastores:** `<PostgreSQL|MySQL|MongoDB|Redis|Elasticsearch|DynamoDB|SQLite|...>`
* **Messaging/Streaming:** `<Kafka|RabbitMQ|SQS|SNS|Redis Streams|NATS|...>`
* **Hosting/Cloud:** `<AWS|GCP|Azure|Vercel|Netlify|Render|Fly.io|Kubernetes|Docker Compose|Bare‑metal|...>`
* **Infra‑as‑Code:** `<Terraform|Pulumi|CloudFormation|CDK|Ansible|...>`
* **CI/CD:** `<GitHub Actions|GitLab CI|CircleCI|Jenkins|Argo|Tekton|...>`
* **AuthN/AuthZ:** `<JWT|Sessions|OAuth2|OIDC|SAML|Auth0|Cognito|Clerk|NextAuth|...>`
* **Secrets Mgmt:** `<.env|Vault|SOPS|AWS SM|Google SM|Doppler|1Password|...>`
* **Preferred Doc Site:** `<Docusaurus|MkDocs|Sphinx|ReadTheDocs|GitHub Wiki|...>`
* **Compliance Needs:** `<PII|GDPR|HIPAA|SOC2|PCI DSS|None>`

---

## 1) How to Use This Template

* Work top‑down; tick every checkbox. Keep commits small and grouped by section.
* Create a `/docs` folder at repo root unless one exists. Generate all deliverables there.
* Prefer **automated extraction** over manual writing. Where possible, produce **diagrams + SBOM + OpenAPI** from code/config.
* Use the **Cursor prompts** provided to accelerate each step. Save outputs and scripts into `/tools` and `/docs`.

---

## 2) Definition of Done (DoD)

* [ ] `/docs/MASTER_OVERVIEW.md` summarizes the entire system with links to all sub‑docs.
* [ ] Architecture diagram(s) in `/docs/diagrams` (Mermaid and/or PNG/SVG) — app‑level, service‑level, and data‑flow.
* [ ] Backend, Frontend, Data, API, Security, Observability, DevOps, and Operations docs completed (see sections below).
* [ ] **Autogenerated artifacts**: SBOM, dependency graphs, OpenAPI/GraphQL schema, database ERD, code metrics, coverage report.
* [ ] **Runbooks** for common operational tasks and incident response.
* [ ] **CONTRIBUTING.md** + **ONBOARDING.md** finalized; linters/formatters configured; CI lint/test/docs pipelines green.
* [ ] **Glossary** and **Acronyms** section for domain terms.
* [ ] All docs cross‑linked, versioned, and published (e.g., Docusaurus site or GitHub Pages) if required.

---

## 3) Global Deliverables & Structure

Create the following tree (adjust as needed):

```bash
/docs
  /diagrams
    architecture-overview.mmd
    services-context.mmd
    sequence-auth.mmd
    deployment-topology.mmd
  /reports
    sbom.json
    dependencies-graph.html
    test-coverage/index.html
    code-metrics.md
  /api
    openapi.yaml
    graphql-schema.graphql
  /db
    schema.sql
    erd.mmd
  /ops
    runbooks.md
    sops-policy.md
    backup-restore.md
  /security
    threat-model.mmd
    security-review.md
  MASTER_OVERVIEW.md
  BACKEND.md
  FRONTEND.md
  DATABASE.md
  API_REFERENCE.md
  DEVOPS.md
  OBSERVABILITY.md
  SECURITY.md
  PERFORMANCE.md
  ONBOARDING.md
  CONTRIBUTING.md
  GLOSSARY.md
  ADR/0001-record-architecture-decisions.md
```

---

## 4) Repository Discovery & Inventory

* [ ] Clone all relevant repos; capture commit history size, active branches, tags, and deployment branches.
* [ ] Generate a filesystem map:

  ```bash
  git ls-files > /docs/reports/filelist.txt
  npx --yes cloc . > /docs/reports/cloc.txt || true
  npx --yes depcruise --include-only "src|app|packages" --output-type dot src | dot -Tsvg -o /docs/reports/dependency-graph.svg || true
  ```

* [ ] Identify **entrypoints** (web servers, CLIs, workers, cron jobs, serverless handlers). Document paths and invocation commands.
* [ ] Detect **monorepo tooling**: \[ ] Turborepo, \[ ] Nx, \[ ] Lerna, \[ ] Bazel, \[ ] pnpm workspaces, \[ ] Yarn workspaces.
* [ ] Inventory build tools: \[ ] Vite, \[ ] Webpack, \[ ] esbuild, \[ ] Rollup, \[ ] Babel, \[ ] tsc, \[ ] Poetry, \[ ] pipenv, \[ ] Maven/Gradle, \[ ] msbuild, \[ ] Cargo, \[ ] Make.
* [ ] Capture **package scripts** and make a task matrix (build/test/lint/start).
* [ ] List **environment files** (`.env*`, `config/*`, `settings.*`, `application.*`). Note secret handling.
* [ ] Enumerate **feature flags** and toggles (e.g., LaunchDarkly, Unleash, homemade), default states, and risk.

### **Cursor Prompt (Discovery)**

```bash
Scan the repo(s) and produce:
1) Entrypoints list by language with file paths.
2) Detected frameworks/libraries and versions.
3) Build/test/lint/start commands from package files and CI configs.
4) Any .env or secrets patterns (do not print secrets), note how they’re loaded.
5) A candidate /docs structure tailored to this project.
Output as Markdown with tables.
```

---

## 5) Architecture & Diagrams

* [ ] Document **system context** (users, external systems, trust boundaries).
* [ ] Draw **container/service diagram** (microservices, libs, shared packages).
* [ ] Create **sequence diagrams** for critical flows: auth/login, signup, checkout, data import, scheduled jobs.
* [ ] Map **deployment topology** (regions, VPC/VNet, clusters, edge/CDN, load balancers, autoscaling).
* [ ] Capture **cross‑cutting concerns**: caching, queues, feature flags, validation, serialization, rate limits.

## **Mermaid Templates**

```mermaid
flowchart LR
  user((User)) -->|HTTPS| web[Web/App Frontend]
  web --> api[API Gateway / BFF]
  api --> svcA[Service A]
  api --> svcB[Service B]
  svcA --> db[(Primary DB)]
  svcB --> cache[[Cache]]
  svcB --> mq[[Message Queue]]
  mq --> worker[Worker]
  worker --> ds[(Data Store)]
```

```mermaid
sequenceDiagram
  participant U as User
  participant FE as Frontend
  participant BFF as API/BFF
  participant S as Service
  participant DB as Database
  U->>FE: Submit Login
  FE->>BFF: POST /auth/login
  BFF->>S: Validate Credentials
  S->>DB: Query user
  DB-->>S: Result
  S-->>BFF: JWT + profile
  BFF-->>FE: 200 OK
  FE-->>U: Authenticated session
```

### **Cursor Prompt (Architecture Extraction)**

```bash
From the codebase, infer main components and interactions. Propose Mermaid diagrams for:
1) System context, 2) Service/container map, 3) One key sequence. Include file paths that support each arrow/interaction.
```

---

## 6) Backend Analysis & Documentation

* [ ] Identify backend frameworks and patterns (MVC, Hexagonal, Clean Architecture, DDD modules).
* [ ] List services, controllers, handlers, middlewares, interceptors.
* [ ] Enumerate background workers, schedulers (cron, Celery, Sidekiq, Bull), and event consumers.
* [ ] Detect configuration strategy (12‑factor), env var schema, configuration sources (files, flags, env).
* [ ] Summarize auth flows (JWT vs sessions, refresh tokens, CSRF), permission model (RBAC/ABAC), multi‑tenant handling.
* [ ] Capture validation, serialization, error handling, idempotency, retries and back‑off.
* [ ] Note performance features (connection pooling, caching, N+1 mitigations, pagination strategies).

**Deliverable:** `/docs/BACKEND.md` with code references and example requests/responses.

### **Cursor Prompt (Backend)**

```bash
Produce BACKEND.md that covers: frameworks, packages and versions; app entrypoints; middleware chain; auth/permissions; validation; error handling; background jobs; configuration (env var table); performance practices; with code path citations for each claim.
```

---

## 7) Frontend Analysis & Documentation

* [ ] Identify framework (React/Next/Vue/etc.), rendering mode (CSR/SSR/ISR/SSG), routing, state mgmt (Redux, Zustand, Vuex, Pinia), data‑fetching (SWR/React‑Query/Apollo/urql), and forms.
* [ ] Document design system (Storybook, Figma links), component library, CSS strategy (Tailwind, CSS‑in‑JS, SCSS).
* [ ] Accessibility posture (ARIA usage, keyboard nav, color contrast), i18n/l10n strategy.
* [ ] Performance: code‑splitting, image optimization, critical CSS, prefetching, caching headers.
* [ ] Error boundaries and logging; feature flags; analytics pixels/SDKs.

**Deliverable:** `/docs/FRONTEND.md` with route map, major components, data flows, and perf budget.

### **Cursor Prompt (Frontend)**

```bash
Generate FRONTEND.md with: routing tree; data fetching strategy; state stores; key components; styling approach; accessibility checklist; perf optimizations; and links to Storybook if present.
```

---

## 8) API Surface (REST/GraphQL/gRPC/Webhooks)

* [ ] Detect API types: \[ ] REST, \[ ] GraphQL, \[ ] gRPC, \[ ] Websockets, \[ ] Webhooks.
* [ ] For REST: extract OpenAPI (code annotations, routers) → `/docs/api/openapi.yaml`.
* [ ] For GraphQL: dump schema → `/docs/api/graphql-schema.graphql`.
* [ ] For gRPC: list protobufs and services; generate service list.
* [ ] For Webhooks: list topics/events, payloads, signature verification.

**Deliverables:** `/docs/API_REFERENCE.md` + generated specs.

### **Cursor Prompt (API)**

```bash
Locate all API definitions (controllers, routers, schema files) and produce:
- OpenAPI or GraphQL schema artifacts
- Endpoint tables (method/path/summary/auth/owner)
- Example requests/responses
Save outputs under /docs/api and write API_REFERENCE.md.
```

---

## 9) Data & Persistence

* [ ] Inventory databases (SQL/NoSQL/time‑series/search), connection URIs, ORMs (Prisma, TypeORM, Sequelize, Django ORM, ActiveRecord, Hibernate), and migration tools.
* [ ] Export schema and generate ERD.

  ```bash
  # Example: PostgreSQL (read‑only)
  pg_dump --schema-only "$DATABASE_URL" > /docs/db/schema.sql
  npx --yes prisma generate && npx --yes prisma format || true
  ```

* [ ] Describe data retention, archival, backups, restore drills, and encryption at rest.
* [ ] Identify PII/PHI/PCI fields; map data lineage across services.

**Deliverable:** `/docs/DATABASE.md` with ERD (`/docs/db/erd.mmd`).

### **Cursor Prompt (Data)**

```bash
Extract models/entities and relationships from ORM/migrations. Produce:
- Table/entity list with fields, types, indexes, FKs
- ERD in Mermaid
- Data retention/backups summary from scripts/infra
```

---

## 10) Integrations & External Services

* [ ] List third‑party services (payments, email, auth, storage, analytics, search, geo, ML) with SDKs and API keys used.
* [ ] Document retry policies, rate limits, idempotency keys, backoff strategies.
* [ ] Capture callback/webhook flows and signature validation.

**Deliverable:** Section in `/docs/MASTER_OVERVIEW.md` + per‑service notes.

---

## 11) Security Review & Threat Modeling

* [ ] Run SAST/linters (e.g., ESLint, Bandit, Semgrep) and record findings.
* [ ] Dependency scan (e.g., `npm audit`, `pip-audit`, `osv-scanner`) and generate **SBOM**.

  ```bash
  # Example SBOM via Syft
  syft dir:. -o cyclonedx-json > /docs/reports/sbom.json
  ```

* [ ] Check secrets in repo: `gitleaks detect` (store report).
* [ ] Review auth flows, token storage, cookie flags, CSRF, CORS, SSRF, RCE, path traversal, injections.
* [ ] Document threat model diagram and mitigations.

**Deliverables:** `/docs/security/security-review.md`, `/docs/security/threat-model.mmd`, `/docs/reports/sbom.json`.

## **Cursor Prompt (Security)**

```bash
Run a lightweight security review: enumerate auth mechanisms, sensitive data flows, storage protections, and common CWE vectors applicable to this stack. Propose a threat-model Mermaid diagram and list mitigations mapped to code paths.
```

---

## 12) Observability (Logging, Metrics, Tracing)

* [ ] Identify logging libraries, log levels, redaction filters, destinations (stdout, ELK, Datadog, CloudWatch, OpenSearch).
* [ ] Metrics sources (Prometheus, StatsD, Micrometer), dashboards, SLOs/SLIs, error budgets.
* [ ] Distributed tracing (OpenTelemetry/Jaeger/Zipkin), trace propagation.
* [ ] Add **RUNBOOKS** for on‑call: alerts, dashboards, diagnostic steps.

**Deliverables:** `/docs/OBSERVABILITY.md`, `/docs/ops/runbooks.md`.

---

## 13) Performance & Scalability

* [ ] Identify bottlenecks and hotspots (DB queries, N+1, slow endpoints, memory leaks).
* [ ] Caching layers (HTTP cache, CDN, Redis), invalidation strategy, TTLs.
* [ ] Load and soak test plan; performance budgets; autoscaling policies; concurrency models.

**Deliverable:** `/docs/PERFORMANCE.md` with proposed SLAs/SLOs and test plan.

---

## 14) Testing Strategy

* [ ] Inventory tests by type: unit, integration, e2e, contract, snapshot, property‑based.
* [ ] Generate coverage report; set target thresholds.
* [ ] Document test data strategy (fixtures, factories, anonymized prod copies), hermetic test envs, ephemeral DBs.
* [ ] Contract testing for services (Pact) and API schemas.

**Deliverables:** Coverage report in `/docs/reports/test-coverage/`, strategy section in `/docs/MASTER_OVERVIEW.md` and `/docs/CONTRIBUTING.md`.

---

## 15) DevEx & Repo Hygiene

* [ ] Linters/formatters configured (ESLint, Prettier, Black, gofmt, ktlint, rubocop, clang‑format).
* [ ] Git hooks (pre‑commit, commit‑msg for Conventional Commits), PR templates, ISSUE templates.
* [ ] CODEOWNERS and ownership mapping by domain/service.
* [ ] Branching model (trunk‑based vs GitFlow), release tagging, changelog automation.

**Deliverables:** `/CONTRIBUTING.md`, `.editorconfig`, `.gitattributes`, `.gitignore`, `CODEOWNERS`.

---

## 16) CI/CD & Infrastructure

* [ ] Catalog CI pipelines: lint, test, build, security, docs, release. Capture required secrets and environments.
* [ ] Document artifact storage (containers, packages), versioning scheme, provenance (SLSA/attestations).
* [ ] Deployment strategies (Blue/Green, Canary, Rolling), infra targets (VMs, containers, serverless, K8s).
* [ ] IaC review (Terraform/Pulumi): state backend, modules, variable files, drift detection.
* [ ] Config/secret management processes (SOPS/Vault/ASM/GSM), rotation policies.

**Deliverable:** `/docs/DEVOPS.md` with pipeline diagrams and deployment runbooks.

### **Mermaid (CI/CD Example)**

```mermaid
flowchart LR
  dev((Developer)) -->|push| ci[CI Pipeline]
  ci --> lint[Lint]
  ci --> test[Test]
  ci --> build[Build]
  build --> image[(Container Registry)]
  image --> cd[CD]
  cd -->|deploy| env[(Staging/Prod)]
  env --> obs[Observability]
```

---

## 17) Compliance & Licensing

* [ ] Enumerate licenses for dependencies; flag copyleft/viral licenses.
* [ ] Document data handling (PII/PHI), DPA agreements, data locality/retention, audit logging.
* [ ] Create **Glossary** for regulated terms.

**Deliverables:** `/docs/GLOSSARY.md`, `/docs/reports/licenses.md`.

---

## 18) Documentation Production Pipeline

* [ ] Choose doc toolchain (e.g., Docusaurus + Markdown). Add npm scripts:

  ```json
  {
    "scripts": {
      "docs:dev": "docusaurus start",
      "docs:build": "docusaurus build",
      "docs:publish": "docusaurus deploy"
    }
  }
  ```

* [ ] Wire CI job to build & publish docs on main releases.
* [ ] Add **ADRs** for architectural decisions; start with `ADR/0001-record-architecture-decisions.md`.
* [ ] Ensure internal links resolved; add sidebar/nav structure.

### **Cursor Prompt (Docs)**

```bash
Transform the Markdown files in /docs into a Docusaurus (or MkDocs) site, including sidebars, navbar, and landing page that summarizes MASTER_OVERVIEW.md. Provide the config and scripts and open PR diffs.
```

---

## 19) Master Overview Skeleton (fill as you go)

Create `/docs/MASTER_OVERVIEW.md` using this outline:

```md
# <PROJECT_NAME> — Master Overview

## System at a Glance
- Purpose & business capabilities
- High‑level diagram(s) (embed from /docs/diagrams)

## Stack Summary
- Languages, frameworks, hosting, datastores

## Key Flows
- Auth, critical user journeys, batch/cron

## Services
- Table with service name, repo path, owners, SLAs

## Data
- ERD link, sensitive fields, retention/backup summary

## APIs
- REST/GraphQL/gRPC overview with links to specs

## Security & Compliance
- AuthN/Z, threat model summary, compliance notes

## DevOps
- CI jobs, deploy strategy, environments, feature flags

## Observability
- Logs/metrics/traces, dashboards, SLOs

## Testing
- Levels, coverage, gate policies

## Runbooks & On‑Call
- Links to /docs/ops

## Roadmap & Risks
- Known gaps, tech debt, ADR links
```

---

## 20) Onboarding & Contributing

* [ ] Write `/docs/ONBOARDING.md`: setup steps, local env, seed data, common commands, debugging tips.
* [ ] Write `/CONTRIBUTING.md`: coding standards, commit style, PR checks, review process, DCO/CLA if any.

---

## 21) Validation & Review Checklist

* [ ] Every claim in docs references a file, path, or config.
* [ ] Diagrams render and reflect actual code/config.
* [ ] CI builds docs, runs linters/tests, and stores reports under `/docs/reports`.
* [ ] Security findings triaged with issues created.
* [ ] Onboarding guide tested by a new contributor.

---

## 22) Optional Appendices

### A) Useful Commands (multi‑language)

```bash
# JS/TS
npm run -s lint || true
npm run -s test -- --coverage || true
npx depcruise src -T dot | dot -Tsvg -o /docs/reports/ts-deps.svg || true

# Python
ruff check . || true
pytest --maxfail=1 --disable-warnings -q --cov=. --cov-report=html:/docs/reports/test-coverage || true
bandit -r . -f txt -o /docs/reports/bandit.txt || true

# Go
go vet ./...; go test ./... -coverprofile=coverage.out; go tool cover -html=coverage.out -o /docs/reports/go-coverage.html

# Java
mvn -q -DskipTests=false test

# SBOM (alternative)
osv-scanner -r . > /docs/reports/osv.txt || true
```

### B) Mermaid ERD Template

```mermaid
erDiagram
  USER ||--o{ ORDER : places
  ORDER ||--|{ ORDER_ITEM : contains
  PRODUCT ||--o{ ORDER_ITEM : referenced
  USER {
    uuid id
    string email
    string role
  }
  ORDER {
    uuid id
    date placed_at
    decimal total
  }
```

### C) ADR Template

```md
# ADR N: Title

- Date: YYYY‑MM‑DD
- Status: Proposed | Accepted | Deprecated | Superseded
- Context: <What problem are we solving?>
- Decision: <What did we decide and why?>
- Consequences: <Positive/negative outcomes>
- Alternatives considered: <List>
```

---

## 23) Cursor One‑Shot Prompts (copy/paste)

### **1) Whole‑Repo Summary**

```bash


You are a senior platform/architecture engineer. Summarize this repo as a system: components, entrypoints, data stores, external services, and deployment targets. Produce a 1‑page Markdown overview with a Mermaid diagram and a table of services with owners (infer from CODEOWNERS and commit history if present).
```

### **2) API Extraction**

```bash
Locate all API definitions and generate OpenAPI and/or GraphQL schema files under /docs/api. Then create API_REFERENCE.md with endpoint tables and example requests/responses.
```

### **3) Security Pass**

```bash
Perform a lightweight security review focusing on auth, secrets, input validation, and common CWEs. Draft security-review.md with risks ranked by severity and quick mitigations. Include a Mermaid threat‑model.
```

### **4) Doc Site Bootstrapping**

```bash
Generate a Docusaurus (or MkDocs) doc site from /docs, with sidebar/nav and a landing page that summarizes MASTER_OVERVIEW.md. Provide config files and npm scripts.
```

---

## 24) Final Handoff Items

* [ ] PR with `/docs` subtree and CI integration.
* [ ] Issue tracker seeded with security/perf/tech‑debt items.
* [ ] Calendar invite for **architecture review walkthrough** using the docs.
* [ ] Owner(s) assigned for each document’s maintenance.

---

### Notes

* Keep sensitive values redacted. Do not commit secrets.
* Prefer references to code paths and config over prose. Let the code speak and docs point.
* Keep docs living: wire CI to regenerate artifacts (SBOM, coverage, deps) periodically.
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "jsx": "react-jsx",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ESNext",
    "lib": ["ESNext"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },
  server: {
    port: 5173,
    strictPort: true,
    host: true
  },
  optimizeDeps: {
    include: ['react', 'react-dom']
  },
  assetsInclude: ['**/*.vert', '**/*.frag'],
  esbuild: {
    loader: 'tsx',
    include: /src\/.*\.(tsx|ts)$/,
  }
})
</file>

</files>
